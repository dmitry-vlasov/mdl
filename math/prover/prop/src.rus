/*****************************************************************************/
/* Project name: Russell language pure mathematics library                   */
/* File name:    src.rus                                                     */
/* Description:  Russell language pure mathematics library                   */
/* Created:      automatically decompiled by mm program from metamath base   */
/* Email:        vlasov at academ.org                                        */
/* URL:          http://russellmath.org                                      */
/* License:      Creative Commons Public Domain Dedication                   */
/*****************************************************************************/

theory src;

contents of src {

	/* 
	#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
	                           Pre-logic
	#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
	 */
	/*  Declare the primitive constant symbols for propositional calculus.  */
	/*  Left parenthesis  */
	constant 
	{
		symbol ( ;
	}

	/*  Right parenthesis  */
	constant 
	{
		symbol ) ;
	}

	/*  Right arrow (read:  "implies")  */
	constant 
	{
		symbol -> ;
	}

	/*  Right handle (read:  "not")  */
	constant 
	{
		symbol -. ;
	}

	type wff ;

	/* 
	#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
	                           Propositional calculus
	#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
	 */
	/* 
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	        Recursively define primitive wffs for propositional calculus
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	 */
	/*  If ` ph ` is a wff, so is ` -. ph ` or "not ` ph ` ."  Part of the
	     recursive definition of a wff (well-formed formula).  In classical logic
	     (which is our logic), a wff is interpreted as either true or false.
	     So if ` ph ` is true, then ` -. ph ` is false; if ` ph ` is false, then
	     ` -. ph ` is true.  Traditionally, Greek letters are used to represent
	     wffs, and we follow this convention.  In propositional calculus, we define
	     only wffs built up from other wffs, i.e. there is no starting or "atomic"
	     wff.  Later, in predicate calculus, we will extend the basic wff
	     definition by including atomic wffs ( ~ weq and ~ wel ).  */
	rule wn (var ph : wff ) 
	{
		term : wff = # -. ph ;
	}

	/*  If ` ph ` and ` ps ` are wff's, so is ` ( ph -> ps ) ` or " ` ph ` implies
	     ` ps ` ."  Part of the recursive definition of a wff.  The resulting wff
	     is (interpreted as) false when ` ph ` is true and ` ps ` is false; it is
	     true otherwise.  (Think of the truth table for an OR gate with input
	     ` ph ` connected through an inverter.)  The left-hand wff is called the
	     antecedent, and the right-hand wff is called the consequent.  In the case
	     of ` ( ph -> ( ps -> ch ) ) ` , the middle ` ps ` may be informally called
	     either an antecedent or part of the consequent depending on context.  */
	rule wi (var ph : wff , var ps : wff ) 
	{
		term : wff = # ( ph -> ps ) ;
	}

	/* 
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	        The axioms of propositional calculus
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	 */
	/* 
	     Postulate the three axioms of classical propositional calculus.
	   */
	/*  Axiom _Simp_.  Axiom A1 of [Margaris] p. 49.  One of the 3 axioms of
	     propositional calculus.  The 3 axioms are also given as Definition 2.1
	     of [Hamilton] p. 28.  This axiom is called _Simp_ or "the principle of
	     simplification" in _Principia Mathematica_ (Theorem *2.02 of
	     [WhiteheadRussell] p. 100) because "it enables us to pass from the joint
	     assertion of ` ph ` and ` ps ` to the assertion of ` ph ` simply."
	
	     _General remarks_:  Propositional calculus (axioms ~ ax-1 through ~ ax-3
	     and rule ~ ax-mp ) can be thought of as asserting formulas that are
	     universally "true" when their variables are replaced by any combination
	     of "true" and "false."  Propositional calculus was first formalized by
	     Frege in 1879, using as his axioms (in addition to rule ~ ax-mp ) the
	     wffs ~ ax-1 , ~ ax-2 , ~ pm2.04 , ~ con3 , ~ nega , and ~ negb .  Around
	     1930, Lukasiewicz simplified the system by eliminating the third (which
	     follows from the first two, as you can see by looking at the proof of
	     ~ pm2.04 ) and replacing the last three with our ~ ax-3 .  (Thanks to Ted
	     Ulrich for this information.)
	
	     The theorems of propositional calculus are also called _tautologies_.
	     Tautologies can be proved very simply using truth tables, based on the
	     true/false interpretation of propositional calculus.  To do this, we
	     assign all possible combinations of true and false to the wff variables
	     and verify that the result (using the rules described in ~ wi and ~ wn )
	     always evaluates to true.  This is called the _semantic_ approach.  Our
	     approach is called the _syntactic_ approach, in which everything is
	     derived from axioms.  A metatheorem called the Completeness Theorem for
	     Propositional Calculus shows that the two approaches are equivalent and
	     even provides an algorithm for automatically generating syntactic proofs
	     from a truth table.  Those proofs, however, tend to be long, and the
	     much shorter proofs that we show here were found manually.  Truth tables
	     grow exponentially with the number of variables, but it is unknown if the
	     same is true of proofs - an answer to this would resolve the P=NP
	     conjecture in complexity theory.  */
	axiom ax-1 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ps -> ph ) ) ;
	}

	/*  Axiom _Frege_.  Axiom A2 of [Margaris] p. 49.  One of the 3 axioms of
	     propositional calculus.  It "distributes" an antecedent over two
	     consequents.  This axiom was part of Frege's original system and is known
	     as _Frege_ in the literature.  It is also proved as Theorem *2.77 of
	     [WhiteheadRussell] p. 108.  The other direction of this axiom also
	     turns out to be true, as demonstrated by ~ pm5.41 .  */
	axiom ax-2 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ps -> ch ) ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ;
	}

	/*  Axiom _Transp_.  Axiom A3 of [Margaris] p. 49.  One of the 3 axioms of
	     propositional calculus.  It swaps or "transposes" the order of the
	     consequents when negation is removed.  An informal example is that the
	     statement "if there are no clouds in the sky, it is not raining" implies
	     the statement "if it is raining, there are clouds in the sky."  This
	     axiom is called _Transp_ or "the principle of transposition" in
	     _Principia Mathematica_ (Theorem *2.17 of [WhiteheadRussell] p. 103).
	     We will also use the term "contraposition" for this principle, although
	     the reader is advised that in the field of philosophical logic,
	     "contraposition" has a different technical meaning.  */
	axiom ax-3 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( -. ph -> -. ps ) -> ( ps -> ph ) ) ;
	}

	/*  Rule of Modus Ponens.  The postulated inference rule of propositional
	       calculus.  See e.g. Rule 1 of [Hamilton] p. 73.  The rule says, "if
	       ` ph ` is true, and ` ph ` implies ` ps ` , then ` ps ` must also be
	       true."  This rule is sometimes called "detachment," since it detaches
	       the minor premise from the major premise.  */
	axiom ax-mp (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ps ;
	}

	/*  Inference derived from axiom ~ ax-1 .  See ~ a1d for an explanation of
	       our informal use of the terms "inference" and "deduction."  */
	theorem a1i (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ph ;
		-----------------
		prop : wff = |- ( ps -> ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of a1i {
		step 1 : wff = axiom ax-1 () |- ( ph -> ( ps -> ph ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ps -> ph ) ;
		qed prop = step 2 ;
	}

	/*  Inference derived from axiom ~ ax-2 .  */
	theorem a2i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ph -> ps ) -> ( ph -> ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of a2i {
		step 1 : wff = axiom ax-2 () |- ( ( ph -> ( ps -> ch ) ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ( ph -> ps ) -> ( ph -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  An inference version of the transitive laws for implication ~ imim2 and
	       ~ imim1 , which Russell and Whitehead call "the principle of the
	       syllogism...because...the syllogism in Barbara is derived from them"
	       (quote after Theorem *2.06 of [WhiteheadRussell] p. 101).  Some authors
	       call this law a "hypothetical syllogism."
	
	       (A bit of trivia:  this is the most commonly referenced assertion in our
	       database.  In second place is ~ ax-mp , followed by ~ visset , ~ bitr ,
	       ~ imp , and ~ ex .  The Metamath program command 'show usage' shows the
	       number of references.)  */
	theorem syl (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ps -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl {
		step 1 : wff = theorem a1i (hyp 2) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem a2i (step 1) |- ( ( ph -> ps ) -> ( ph -> ch ) ) ;
		step 3 : wff = axiom ax-mp (hyp 1, step 2) |- ( ph -> ch ) ;
		qed prop = step 3 ;
	}

	/*  Inference that swaps (commutes) antecedents in an implication.  */
	theorem com12 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ps -> ( ph -> ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of com12 {
		step 1 : wff = axiom ax-1 () |- ( ps -> ( ph -> ps ) ) ;
		step 2 : wff = theorem a2i (hyp 1) |- ( ( ph -> ps ) -> ( ph -> ch ) ) ;
		step 3 : wff = theorem syl (step 1, step 2) |- ( ps -> ( ph -> ch ) ) ;
		qed prop = step 3 ;
	}

	/*  Deduction introducing an embedded antecedent.  (The proof was revised by
	       Stefan Allan, 20-Mar-06.)
	
	       _Naming convention_:  We often call a theorem a "deduction" and suffix
	       its label with "d" whenever the hypotheses and conclusion are each
	       prefixed with the same antecedent.  This allows us to use the theorem in
	       places where (in traditional textbook formalizations) the standard
	       Deduction Theorem would be used; here ` ph ` would be replaced with a
	       conjunction ( ~ df-an ) of the hypotheses of the would-be deduction.  By
	       contrast, we tend to call the simpler version with no common antecedent
	       an "inference" and suffix its label with "i"; compare theorem ~ a1i .
	       Finally, a "theorem" would be the form with no hypotheses; in this case
	       the "theorem" form would be the original axiom ~ ax-1 .  In
	       propositional calculus we usually prove the theorem form first without a
	       suffix on its label (e.g.  ~ pm2.43 vs.  ~ pm2.43i vs.  ~ pm2.43d ), but
	       (much) later we often suffix the theorem form's label with "t" as in
	       ~ negnegt vs. ~ negneg , especially when our "weak deduction theorem"
	       ~ dedth is used to prove the theorem form from its inference form.  When
	       an inference is converted to a theorem by eliminating an "is a set"
	       hypothesis, we sometimes suffix the theorem form with "g" (for somewhat
	       overstated "generalized") as in ~ uniex vs.  ~ uniexg .  */
	theorem a1d (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( ch -> ps ) ) ;
	}

	/*  [20-Mar-2006]  */ /*  [5-Aug-1993]  */ 
	proof of a1d {
		step 1 : wff = axiom ax-1 () |- ( ps -> ( ch -> ps ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( ch -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction distributing an embedded antecedent.  */
	theorem a2d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps -> ch ) -> ( ps -> th ) ) ) ;
	}

	/*  [23-Jun-1994]  */ 
	proof of a2d {
		step 1 : wff = axiom ax-2 () |- ( ( ps -> ( ch -> th ) ) -> ( ( ps -> ch ) -> ( ps -> th ) ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( ( ps -> ch ) -> ( ps -> th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  A closed form of syllogism (see ~ syl ).  Theorem *2.05 of
	     [WhiteheadRussell] p. 100.  */
	theorem imim2 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( ch -> ph ) -> ( ch -> ps ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of imim2 {
		step 1 : wff = axiom ax-1 () |- ( ( ph -> ps ) -> ( ch -> ( ph -> ps ) ) ) ;
		step 2 : wff = theorem a2d (step 1) |- ( ( ph -> ps ) -> ( ( ch -> ph ) -> ( ch -> ps ) ) ) ;
		qed prop = step 2 ;
	}

	/*  A closed form of syllogism (see ~ syl ).  Theorem *2.06 of
	     [WhiteheadRussell] p. 100.  */
	theorem imim1 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( ps -> ch ) -> ( ph -> ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of imim1 {
		step 1 : wff = theorem imim2 () |- ( ( ps -> ch ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( ( ph -> ps ) -> ( ( ps -> ch ) -> ( ph -> ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Inference adding common consequents in an implication, thereby
	       interchanging the original antecedent and consequent.  */
	theorem imim1i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ( ps -> ch ) -> ( ph -> ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of imim1i {
		step 1 : wff = theorem imim1 () |- ( ( ph -> ps ) -> ( ( ps -> ch ) -> ( ph -> ch ) ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ( ps -> ch ) -> ( ph -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Inference adding common antecedents in an implication.  */
	theorem imim2i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ( ch -> ph ) -> ( ch -> ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of imim2i {
		step 1 : wff = theorem a1i (hyp 1) |- ( ch -> ( ph -> ps ) ) ;
		step 2 : wff = theorem a2i (step 1) |- ( ( ch -> ph ) -> ( ch -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Inference joining two implications.  */
	theorem imim12i (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ch -> th ) ;
		-----------------
		prop : wff = |- ( ( ps -> ch ) -> ( ph -> th ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of imim12i {
		step 1 : wff = theorem imim2i (hyp 2) |- ( ( ps -> ch ) -> ( ps -> th ) ) ;
		step 2 : wff = theorem imim1i (hyp 1) |- ( ( ps -> th ) -> ( ph -> th ) ) ;
		step 3 : wff = theorem syl (step 1, step 2) |- ( ( ps -> ch ) -> ( ph -> th ) ) ;
		qed prop = step 3 ;
	}

	/*  Inference adding three nested antecedents.  */
	theorem imim3i (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ( th -> ph ) -> ( ( th -> ps ) -> ( th -> ch ) ) ) ;
	}

	/*  [19-Dec-2006]  */ /*  [19-Dec-2006]  */ 
	proof of imim3i {
		step 1 : wff = theorem imim2i (hyp 1) |- ( ( th -> ph ) -> ( th -> ( ps -> ch ) ) ) ;
		step 2 : wff = theorem a2d (step 1) |- ( ( th -> ph ) -> ( ( th -> ps ) -> ( th -> ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Inference chaining two syllogisms.  */
	theorem _3syl (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ps -> ch ) ;
		hyp 3 : wff = |- ( ch -> th ) ;
		-----------------
		prop : wff = |- ( ph -> th ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of _3syl {
		step 1 : wff = theorem syl (hyp 1, hyp 2) |- ( ph -> ch ) ;
		step 2 : wff = theorem syl (step 1, hyp 3) |- ( ph -> th ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism rule of inference.  The second premise is used to replace
	       the second antecedent of the first premise.  */
	theorem syl5 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( th -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( th -> ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl5 {
		step 1 : wff = theorem imim1i (hyp 2) |- ( ( ps -> ch ) -> ( th -> ch ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( th -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism rule of inference.  The second premise is used to replace
	       the consequent of the first premise.  */
	theorem syl6 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ch -> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl6 {
		step 1 : wff = theorem imim2i (hyp 2) |- ( ( ps -> ch ) -> ( ps -> th ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism rule of inference.  The second premise is used to replace
	       the third antecedent of the first premise.  */
	theorem syl7 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		hyp 2 : wff = |- ( ta -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ta -> th ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl7 {
		step 1 : wff = theorem imim1i (hyp 2) |- ( ( ch -> th ) -> ( ta -> th ) ) ;
		step 2 : wff = theorem syl6 (hyp 1, step 1) |- ( ph -> ( ps -> ( ta -> th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism rule of inference.  The second premise is used to replace
	       the consequent of the first premise.  */
	theorem syl8 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		hyp 2 : wff = |- ( th -> ta ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ta ) ) ) ;
	}

	/*  [1-Aug-1994]  */ 
	proof of syl8 {
		step 1 : wff = theorem imim2i (hyp 2) |- ( ( ch -> th ) -> ( ch -> ta ) ) ;
		step 2 : wff = theorem syl6 (hyp 1, step 1) |- ( ph -> ( ps -> ( ch -> ta ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding nested antecedents.  */
	theorem imim2d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( th -> ps ) -> ( th -> ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of imim2d {
		step 1 : wff = theorem a1d (hyp 1) |- ( ph -> ( th -> ( ps -> ch ) ) ) ;
		step 2 : wff = theorem a2d (step 1) |- ( ph -> ( ( th -> ps ) -> ( th -> ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  A modus ponens deduction.  */
	theorem mpd (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of mpd {
		step 1 : wff = theorem a2i (hyp 2) |- ( ( ph -> ps ) -> ( ph -> ch ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Syllogism deduction.  (The proof was shortened by Mel L. O'Cat,
	       19-Feb-2008.  See ~ syldOLD for previous version.)  */
	theorem syld (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ch -> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [19-Feb-2008]  */ /*  [5-Aug-1993]  */ 
	proof of syld {
		step 1 : wff = theorem imim2d (hyp 2) |- ( ph -> ( ( ps -> ch ) -> ( ps -> th ) ) ) ;
		step 2 : wff = theorem mpd (hyp 1, step 1) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  Syllogism deduction.  (The proof was shortened by Mel L. O'Cat,
	       7-Aug-2004.)  */
	theorem syldOLD (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ch -> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [7-Aug-2004]  */ /*  [5-Aug-1993]  */ 
	proof of syldOLD {
		step 1 : wff = theorem imim2d (hyp 2) |- ( ph -> ( ( ps -> ch ) -> ( ps -> th ) ) ) ;
		step 2 : wff = theorem a2i (step 1) |- ( ( ph -> ( ps -> ch ) ) -> ( ph -> ( ps -> th ) ) ) ;
		step 3 : wff = axiom ax-mp (hyp 1, step 2) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding nested consequents.  */
	theorem imim1d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ch -> th ) -> ( ps -> th ) ) ) ;
	}

	/*  [3-Apr-1994]  */ 
	proof of imim1d {
		step 1 : wff = theorem imim1 () |- ( ( ps -> ch ) -> ( ( ch -> th ) -> ( ps -> th ) ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( ( ch -> th ) -> ( ps -> th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction combining antecedents and consequents.  */
	theorem imim12d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th -> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ch -> th ) -> ( ps -> ta ) ) ) ;
	}

	/*  [7-Aug-1994]  */ 
	proof of imim12d {
		step 1 : wff = theorem imim1d (hyp 1) |- ( ph -> ( ( ch -> th ) -> ( ps -> th ) ) ) ;
		step 2 : wff = theorem imim2d (hyp 2) |- ( ph -> ( ( ps -> th ) -> ( ps -> ta ) ) ) ;
		step 3 : wff = theorem syld (step 1, step 2) |- ( ph -> ( ( ch -> th ) -> ( ps -> ta ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Swap antecedents.  Theorem *2.04 of [WhiteheadRussell] p. 100.  */
	theorem pm2_04 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ps -> ch ) ) -> ( ps -> ( ph -> ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm2_04 {
		step 1 : wff = axiom ax-2 () |- ( ( ph -> ( ps -> ch ) ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ;
		step 2 : wff = axiom ax-1 () |- ( ps -> ( ph -> ps ) ) ;
		step 3 : wff = theorem syl5 (step 1, step 2) |- ( ( ph -> ( ps -> ch ) ) -> ( ps -> ( ph -> ch ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.83 of [WhiteheadRussell] p. 108.  */
	theorem pm2_83 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ps -> ch ) ) -> ( ( ph -> ( ch -> th ) ) -> ( ph -> ( ps -> th ) ) ) ) ;
	}

	/*  [13-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_83 {
		step 1 : wff = theorem imim1 () |- ( ( ps -> ch ) -> ( ( ch -> th ) -> ( ps -> th ) ) ) ;
		step 2 : wff = theorem imim3i (step 1) |- ( ( ph -> ( ps -> ch ) ) -> ( ( ph -> ( ch -> th ) ) -> ( ph -> ( ps -> th ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Commutation of antecedents.  Swap 2nd and 3rd.  */
	theorem com23 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ch -> ( ps -> th ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of com23 {
		step 1 : wff = theorem pm2_04 () |- ( ( ps -> ( ch -> th ) ) -> ( ch -> ( ps -> th ) ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( ch -> ( ps -> th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Commutation of antecedents.  Swap 1st and 3rd.  */
	theorem com13 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ch -> ( ps -> ( ph -> th ) ) ) ;
	}

	/*  [25-Apr-1994]  */ 
	proof of com13 {
		step 1 : wff = theorem com12 (hyp 1) |- ( ps -> ( ph -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem com23 (step 1) |- ( ps -> ( ch -> ( ph -> th ) ) ) ;
		step 3 : wff = theorem com12 (step 2) |- ( ch -> ( ps -> ( ph -> th ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Commutation of antecedents.  Rotate left.  */
	theorem com3l (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ps -> ( ch -> ( ph -> th ) ) ) ;
	}

	/*  [25-Apr-1994]  */ 
	proof of com3l {
		step 1 : wff = theorem com23 (hyp 1) |- ( ph -> ( ch -> ( ps -> th ) ) ) ;
		step 2 : wff = theorem com13 (step 1) |- ( ps -> ( ch -> ( ph -> th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Commutation of antecedents.  Rotate right.  */
	theorem com3r (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ch -> ( ph -> ( ps -> th ) ) ) ;
	}

	/*  [25-Apr-1994]  */ 
	proof of com3r {
		step 1 : wff = theorem com3l (hyp 1) |- ( ps -> ( ch -> ( ph -> th ) ) ) ;
		step 2 : wff = theorem com3l (step 1) |- ( ch -> ( ph -> ( ps -> th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Commutation of antecedents.  Swap 3rd and 4th.  */
	theorem com34 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( th -> ( ch -> ta ) ) ) ) ;
	}

	/*  [25-Apr-1994]  */ 
	proof of com34 {
		step 1 : wff = theorem pm2_04 () |- ( ( ch -> ( th -> ta ) ) -> ( th -> ( ch -> ta ) ) ) ;
		step 2 : wff = theorem syl6 (hyp 1, step 1) |- ( ph -> ( ps -> ( th -> ( ch -> ta ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Commutation of antecedents.  Swap 2nd and 4th.  */
	theorem com24 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( th -> ( ch -> ( ps -> ta ) ) ) ) ;
	}

	/*  [25-Apr-1994]  */ 
	proof of com24 {
		step 1 : wff = theorem com34 (hyp 1) |- ( ph -> ( ps -> ( th -> ( ch -> ta ) ) ) ) ;
		step 2 : wff = theorem com23 (step 1) |- ( ph -> ( th -> ( ps -> ( ch -> ta ) ) ) ) ;
		step 3 : wff = theorem com34 (step 2) |- ( ph -> ( th -> ( ch -> ( ps -> ta ) ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Commutation of antecedents.  Swap 1st and 4th.  */
	theorem com14 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( th -> ( ps -> ( ch -> ( ph -> ta ) ) ) ) ;
	}

	/*  [25-Apr-1994]  */ 
	proof of com14 {
		step 1 : wff = theorem com34 (hyp 1) |- ( ph -> ( ps -> ( th -> ( ch -> ta ) ) ) ) ;
		step 2 : wff = theorem com13 (step 1) |- ( th -> ( ps -> ( ph -> ( ch -> ta ) ) ) ) ;
		step 3 : wff = theorem com34 (step 2) |- ( th -> ( ps -> ( ch -> ( ph -> ta ) ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Commutation of antecedents.  Rotate left.  (The proof was shortened by
	       Mel L. O'Cat, 15-Aug-2004.)  */
	theorem com4l (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( ps -> ( ch -> ( th -> ( ph -> ta ) ) ) ) ;
	}

	/*  [15-Aug-2004]  */ /*  [25-Apr-1994]  */ 
	proof of com4l {
		step 1 : wff = theorem com14 (hyp 1) |- ( th -> ( ps -> ( ch -> ( ph -> ta ) ) ) ) ;
		step 2 : wff = theorem com3l (step 1) |- ( ps -> ( ch -> ( th -> ( ph -> ta ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Commutation of antecedents.  Rotate twice.  */
	theorem com4t (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( ch -> ( th -> ( ph -> ( ps -> ta ) ) ) ) ;
	}

	/*  [25-Apr-1994]  */ 
	proof of com4t {
		step 1 : wff = theorem com4l (hyp 1) |- ( ps -> ( ch -> ( th -> ( ph -> ta ) ) ) ) ;
		step 2 : wff = theorem com4l (step 1) |- ( ch -> ( th -> ( ph -> ( ps -> ta ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Commutation of antecedents.  Rotate right.  */
	theorem com4r (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( th -> ( ph -> ( ps -> ( ch -> ta ) ) ) ) ;
	}

	/*  [25-Apr-1994]  */ 
	proof of com4r {
		step 1 : wff = theorem com4t (hyp 1) |- ( ch -> ( th -> ( ph -> ( ps -> ta ) ) ) ) ;
		step 2 : wff = theorem com4l (step 1) |- ( th -> ( ph -> ( ps -> ( ch -> ta ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction introducing a nested embedded antecedent.  (The proof was
	       shortened by Mel L. O'Cat, 15-Jan-2008.)  */
	theorem a1dd (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( th -> ch ) ) ) ;
	}

	/*  [15-Jan-2008]  */ /*  [17-Dec-2004]  */ 
	proof of a1dd {
		step 1 : wff = axiom ax-1 () |- ( ch -> ( th -> ch ) ) ;
		step 2 : wff = theorem syl6 (hyp 1, step 1) |- ( ph -> ( ps -> ( th -> ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  A double modus ponens inference.  */
	theorem mp2 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- ps ;
		hyp 3 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ch ;
	}

	/*  [5-Apr-1994]  */ 
	proof of mp2 {
		step 1 : wff = axiom ax-mp (hyp 1, hyp 3) |- ( ps -> ch ) ;
		step 2 : wff = axiom ax-mp (hyp 2, step 1) |- ch ;
		qed prop = step 2 ;
	}

	/*  A nested modus ponens inference.  (The proof was shortened by Stefan
	       Allan, 20-Mar-06.  */
	theorem mpi (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ps ;
		hyp 2 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [20-Mar-2006]  */ /*  [5-Aug-1993]  */ 
	proof of mpi {
		step 1 : wff = theorem a1i (hyp 1) |- ( ph -> ps ) ;
		step 2 : wff = theorem mpd (step 1, hyp 2) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A doubly nested modus ponens inference.  */
	theorem mpii (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ch ;
		hyp 2 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [31-Dec-1993]  */ 
	proof of mpii {
		step 1 : wff = theorem com23 (hyp 2) |- ( ph -> ( ch -> ( ps -> th ) ) ) ;
		step 2 : wff = theorem mpi (hyp 1, step 1) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A nested modus ponens deduction.  */
	theorem mpdd (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [13-Dec-2004]  */ /*  [12-Dec-2004]  */ 
	proof of mpdd {
		step 1 : wff = theorem a2d (hyp 2) |- ( ph -> ( ( ps -> ch ) -> ( ps -> th ) ) ) ;
		step 2 : wff = theorem mpd (hyp 1, step 1) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A nested modus ponens deduction.  */
	theorem mpid (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ch ) ;
		hyp 2 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [16-Dec-2004]  */ /*  [14-Dec-2004]  */ 
	proof of mpid {
		step 1 : wff = theorem a1d (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem mpdd (step 1, hyp 2) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A nested modus ponens deduction.  (The proof was shortened by Mel L.
	       O'Cat, 15-Jan-2008.)  */
	theorem mpdi (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ps -> ch ) ;
		hyp 2 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [15-Jan-2008]  */ /*  [16-Apr-2005]  */ 
	proof of mpdi {
		step 1 : wff = theorem a1i (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem mpdd (step 1, hyp 2) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  Modus ponens inference with commutation of antecedents.  */
	theorem mpcom (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ps -> ph ) ;
		hyp 2 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ps -> ch ) ;
	}

	/*  [17-Mar-1996]  */ 
	proof of mpcom {
		step 1 : wff = theorem com12 (hyp 2) |- ( ps -> ( ph -> ch ) ) ;
		step 2 : wff = theorem mpd (hyp 1, step 1) |- ( ps -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Nested syllogism deduction.  */
	theorem syldd (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		hyp 2 : wff = |- ( ph -> ( ps -> ( th -> ta ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ta ) ) ) ;
	}

	/*  [13-Dec-2004]  */ /*  [12-Dec-2004]  */ 
	proof of syldd {
		step 1 : wff = theorem imim2 () |- ( ( th -> ta ) -> ( ( ch -> th ) -> ( ch -> ta ) ) ) ;
		step 2 : wff = theorem syl6 (hyp 2, step 1) |- ( ph -> ( ps -> ( ( ch -> th ) -> ( ch -> ta ) ) ) ) ;
		step 3 : wff = theorem mpdd (hyp 1, step 2) |- ( ph -> ( ps -> ( ch -> ta ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Syllogism inference with commutation of antecedents.  (The proof was
	       shortened by Mel O'Cat, 2-Feb-06 and shortened further by Stefan Allan,
	       23-Feb-06.)  */
	theorem sylcom (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ps -> ( ch -> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [24-Feb-2006]  */ /*  [29-Aug-2004]  */ 
	proof of sylcom {
		step 1 : wff = theorem a2i (hyp 2) |- ( ( ps -> ch ) -> ( ps -> th ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  Syllogism inference with commuted antecedents.  */
	theorem syl5com (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( th -> ps ) ;
		-----------------
		prop : wff = |- ( th -> ( ph -> ch ) ) ;
	}

	/*  [25-May-2005]  */ /*  [24-May-2005]  */ 
	proof of syl5com {
		step 1 : wff = theorem a1d (hyp 2) |- ( th -> ( ph -> ps ) ) ;
		step 2 : wff = theorem sylcom (step 1, hyp 1) |- ( th -> ( ph -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Syllogism inference with commuted antecedents.  */
	theorem syl6com (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ch -> th ) ;
		-----------------
		prop : wff = |- ( ps -> ( ph -> th ) ) ;
	}

	/*  [26-May-2005]  */ /*  [25-May-2005]  */ 
	proof of syl6com {
		step 1 : wff = theorem syl6 (hyp 1, hyp 2) |- ( ph -> ( ps -> th ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( ps -> ( ph -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  Syllogism inference with common nested antecedent.  */
	theorem syli (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ps -> ( ph -> ch ) ) ;
		hyp 2 : wff = |- ( ch -> ( ph -> th ) ) ;
		-----------------
		prop : wff = |- ( ps -> ( ph -> th ) ) ;
	}

	/*  [5-Nov-2004]  */ /*  [4-Nov-2004]  */ 
	proof of syli {
		step 1 : wff = theorem com12 (hyp 2) |- ( ph -> ( ch -> th ) ) ;
		step 2 : wff = theorem sylcom (hyp 1, step 1) |- ( ps -> ( ph -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A nested syllogism deduction.  (The proof was shortened by Josh
	       Purinton, 29-Dec-00 and shortened further by Mel O'Cat, 2-Feb-06.)  */
	theorem syl5d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		hyp 2 : wff = |- ( ph -> ( ta -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ta -> th ) ) ) ;
	}

	/*  [3-Feb-2006]  */ /*  [5-Aug-1993]  */ 
	proof of syl5d {
		step 1 : wff = theorem a1d (hyp 2) |- ( ph -> ( ps -> ( ta -> ch ) ) ) ;
		step 2 : wff = theorem syldd (step 1, hyp 1) |- ( ph -> ( ps -> ( ta -> th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  A nested syllogism deduction.  (The proof was shortened by Josh
	       Purinton, 29-Dec-00 and shortened further by Mel O'Cat, 2-Feb-06.)  */
	theorem syl6d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		hyp 2 : wff = |- ( ph -> ( th -> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ta ) ) ) ;
	}

	/*  [3-Feb-2006]  */ /*  [5-Aug-1993]  */ 
	proof of syl6d {
		step 1 : wff = theorem a1d (hyp 2) |- ( ph -> ( ps -> ( th -> ta ) ) ) ;
		step 2 : wff = theorem syldd (hyp 1, step 1) |- ( ph -> ( ps -> ( ch -> ta ) ) ) ;
		qed prop = step 2 ;
	}

	/*  A nested syllogism inference with different antecedents.  (The proof
	       was shortened by Josh Purinton, 29-Dec-00.)  */
	theorem syl9 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( th -> ( ch -> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( th -> ( ps -> ta ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl9 {
		step 1 : wff = theorem a1i (hyp 2) |- ( ph -> ( th -> ( ch -> ta ) ) ) ;
		step 2 : wff = theorem syl5d (step 1, hyp 1) |- ( ph -> ( th -> ( ps -> ta ) ) ) ;
		qed prop = step 2 ;
	}

	/*  A nested syllogism inference with different antecedents.  */
	theorem syl9r (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( th -> ( ch -> ta ) ) ;
		-----------------
		prop : wff = |- ( th -> ( ph -> ( ps -> ta ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl9r {
		step 1 : wff = theorem syl9 (hyp 1, hyp 2) |- ( ph -> ( th -> ( ps -> ta ) ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( th -> ( ph -> ( ps -> ta ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Principle of identity.  Theorem *2.08 of [WhiteheadRussell] p. 101.
	     For another version of the proof directly from axioms, see ~ id1 .
	     (The proof was shortened by Stefan Allan, 20-Mar-06.)  */
	theorem id (var ph : wff ) 
	{
		prop : wff = |- ( ph -> ph ) ;
	}

	/*  [20-Mar-2006]  */ /*  [20-Mar-2006]  */ 
	proof of id {
		step 1 : wff = axiom ax-1 () |- ( ph -> ( ph -> ph ) ) ;
		step 2 : wff = axiom ax-1 () |- ( ph -> ( ( ph -> ph ) -> ph ) ) ;
		step 3 : wff = theorem mpd (step 1, step 2) |- ( ph -> ph ) ;
		qed prop = step 3 ;
	}

	/*  Principle of identity.  Theorem *2.08 of [WhiteheadRussell] p. 101.  This
	     version is proved directly from the axioms for demonstration purposes.
	     This proof is a very popular example in the literature and is identical,
	     step for step, to the proofs of Theorem 1 of [Margaris] p. 51,
	     Example 2.7(a) of [Hamilton] p. 31, Lemma 10.3 of [BellMachover] p. 36,
	     and Lemma 1.8 of [Mendelson] p. 36.  It is also
	     "Our first proof" in Hirst and Hirst's _A Primer for Logic and Proof_
	     p. 16 (PDF p. 22) at
	     ~ http://www.mathsci.appstate.edu/~~jlh/primer/hirst.pdf .
	     For a shorter version of the proof that takes advantage of previously
	     proved theorems, see ~ id .  */
	theorem id1 (var ph : wff ) 
	{
		prop : wff = |- ( ph -> ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of id1 {
		step 1 : wff = axiom ax-1 () |- ( ph -> ( ph -> ph ) ) ;
		step 2 : wff = axiom ax-1 () |- ( ph -> ( ( ph -> ph ) -> ph ) ) ;
		step 3 : wff = axiom ax-2 () |- ( ( ph -> ( ( ph -> ph ) -> ph ) ) -> ( ( ph -> ( ph -> ph ) ) -> ( ph -> ph ) ) ) ;
		step 4 : wff = axiom ax-mp (step 2, step 3) |- ( ( ph -> ( ph -> ph ) ) -> ( ph -> ph ) ) ;
		step 5 : wff = axiom ax-mp (step 1, step 4) |- ( ph -> ph ) ;
		qed prop = step 5 ;
	}

	/*  Principle of identity with antecedent.  */
	theorem idd (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ps -> ps ) ) ;
	}

	/*  [26-Nov-1995]  */ 
	proof of idd {
		step 1 : wff = theorem id () |- ( ps -> ps ) ;
		step 2 : wff = theorem a1i (step 1) |- ( ph -> ( ps -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  This theorem, called "Assertion," can be thought of as closed form of
	     modus ponens.  Theorem *2.27 of [WhiteheadRussell] p. 104.  */
	theorem pm2_27 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ( ph -> ps ) -> ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm2_27 {
		step 1 : wff = theorem id () |- ( ( ph -> ps ) -> ( ph -> ps ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( ph -> ( ( ph -> ps ) -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Absorption of redundant antecedent.  Also called the "Contraction" or
	     "Hilbert" axiom.  Theorem *2.43 of [WhiteheadRussell] p. 106.  (The proof
	     was shortened by Mel L. O'Cat, 15-Aug-2004.)  */
	theorem pm2_43 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ph -> ps ) ) -> ( ph -> ps ) ) ;
	}

	/*  [15-Aug-2004]  */ /*  [5-Aug-1993]  */ 
	proof of pm2_43 {
		step 1 : wff = theorem pm2_27 () |- ( ph -> ( ( ph -> ps ) -> ps ) ) ;
		step 2 : wff = theorem a2i (step 1) |- ( ( ph -> ( ph -> ps ) ) -> ( ph -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Inference absorbing redundant antecedent.  */
	theorem pm2_43i (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ph -> ps ) ) ;
		-----------------
		prop : wff = |- ( ph -> ps ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm2_43i {
		step 1 : wff = theorem pm2_43 () |- ( ( ph -> ( ph -> ps ) ) -> ( ph -> ps ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ph -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Deduction absorbing redundant antecedent.  (The proof was shortened by
	       Mel O'Cat, 3-Feb-06.)  */
	theorem pm2_43d (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ps -> ch ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ch ) ) ;
	}

	/*  [4-Feb-2006]  */ /*  [18-Aug-1993]  */ 
	proof of pm2_43d {
		step 1 : wff = theorem idd () |- ( ph -> ( ps -> ps ) ) ;
		step 2 : wff = theorem mpdd (step 1, hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Inference absorbing redundant antecedent.  (The proof was shortened by
	       Mel O'Cat, 3-Feb-06.)  */
	theorem pm2_43a (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ps -> ( ph -> ( ps -> ch ) ) ) ;
		-----------------
		prop : wff = |- ( ps -> ( ph -> ch ) ) ;
	}

	/*  [4-Feb-2006]  */ /*  [7-Nov-1995]  */ 
	proof of pm2_43a {
		step 1 : wff = axiom ax-1 () |- ( ps -> ( ph -> ps ) ) ;
		step 2 : wff = theorem mpdd (step 1, hyp 1) |- ( ps -> ( ph -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Inference absorbing redundant antecedent.  */
	theorem pm2_43b (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ps -> ( ph -> ( ps -> ch ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ch ) ) ;
	}

	/*  [31-Oct-1995]  */ 
	proof of pm2_43b {
		step 1 : wff = theorem pm2_43a (hyp 1) |- ( ps -> ( ph -> ch ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( ph -> ( ps -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference combined with contraction.  */
	theorem sylc (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( th -> ph ) ;
		hyp 3 : wff = |- ( th -> ps ) ;
		-----------------
		prop : wff = |- ( th -> ch ) ;
	}

	/*  [4-May-1994]  */ 
	proof of sylc {
		step 1 : wff = theorem syl (hyp 2, hyp 1) |- ( th -> ( ps -> ch ) ) ;
		step 2 : wff = theorem mpd (hyp 3, step 1) |- ( th -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Converse of axiom ~ ax-2 .  Theorem *2.86 of [WhiteheadRussell] p. 108.  */
	theorem pm2_86 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) -> ( ph -> ch ) ) -> ( ph -> ( ps -> ch ) ) ) ;
	}

	/*  [25-Apr-1994]  */ 
	proof of pm2_86 {
		step 1 : wff = axiom ax-1 () |- ( ps -> ( ph -> ps ) ) ;
		step 2 : wff = theorem imim1i (step 1) |- ( ( ( ph -> ps ) -> ( ph -> ch ) ) -> ( ps -> ( ph -> ch ) ) ) ;
		step 3 : wff = theorem com23 (step 2) |- ( ( ( ph -> ps ) -> ( ph -> ch ) ) -> ( ph -> ( ps -> ch ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Inference based on ~ pm2.86 .  */
	theorem pm2_86i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph -> ps ) -> ( ph -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm2_86i {
		step 1 : wff = theorem pm2_86 () |- ( ( ( ph -> ps ) -> ( ph -> ch ) ) -> ( ph -> ( ps -> ch ) ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ph -> ( ps -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction based on ~ pm2.86 .  */
	theorem pm2_86d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ps -> ch ) -> ( ps -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
	}

	/*  [29-Jun-1995]  */ 
	proof of pm2_86d {
		step 1 : wff = theorem pm2_86 () |- ( ( ( ps -> ch ) -> ( ps -> th ) ) -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  The Linearity Axiom of the infinite-valued sentential logic (L-infinity)
	     of Lukasiewicz.  (Contributed by Mel L. O'Cat, 12-Aug-2004.)  */
	theorem loolin (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) -> ( ps -> ph ) ) -> ( ps -> ph ) ) ;
	}

	/*  [14-Aug-2004]  */ /*  [12-Aug-2004]  */ 
	proof of loolin {
		step 1 : wff = axiom ax-1 () |- ( ps -> ( ph -> ps ) ) ;
		step 2 : wff = theorem imim1i (step 1) |- ( ( ( ph -> ps ) -> ( ps -> ph ) ) -> ( ps -> ( ps -> ph ) ) ) ;
		step 3 : wff = theorem pm2_43d (step 2) |- ( ( ( ph -> ps ) -> ( ps -> ph ) ) -> ( ps -> ph ) ) ;
		qed prop = step 3 ;
	}

	/*  An alternate for the Linearity Axiom of the infinite-valued sentential
	     logic (L-infinity) of Lukasiewicz, due to Barbara Wozniakowska, _Reports
	     on Mathematical Logic_ 10, 129-137 (1978).  (Contributed by Mel L. O'Cat,
	     8-Aug-2004.)  */
	theorem loowoz (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) -> ( ph -> ch ) ) -> ( ( ps -> ph ) -> ( ps -> ch ) ) ) ;
	}

	/*  [9-Aug-2004]  */ /*  [8-Aug-2004]  */ 
	proof of loowoz {
		step 1 : wff = axiom ax-1 () |- ( ps -> ( ph -> ps ) ) ;
		step 2 : wff = theorem imim1i (step 1) |- ( ( ( ph -> ps ) -> ( ph -> ch ) ) -> ( ps -> ( ph -> ch ) ) ) ;
		step 3 : wff = theorem a2d (step 2) |- ( ( ( ph -> ps ) -> ( ph -> ch ) ) -> ( ( ps -> ph ) -> ( ps -> ch ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Inference rule derived from axiom ~ ax-3 .  */
	theorem a3i (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( -. ph -> -. ps ) ;
		-----------------
		prop : wff = |- ( ps -> ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of a3i {
		step 1 : wff = axiom ax-3 () |- ( ( -. ph -> -. ps ) -> ( ps -> ph ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ps -> ph ) ;
		qed prop = step 2 ;
	}

	/*  Deduction derived from axiom ~ ax-3 .  */
	theorem a3d (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( -. ps -> -. ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ch -> ps ) ) ;
	}

	/*  [26-Mar-1995]  */ 
	proof of a3d {
		step 1 : wff = axiom ax-3 () |- ( ( -. ps -> -. ch ) -> ( ch -> ps ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( ch -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  From a wff and its negation, anything is true.  Theorem *2.21 of
	     [WhiteheadRussell] p. 104.  Also called the Duns Scotus law.  */
	theorem pm2_21 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ph -> ( ph -> ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm2_21 {
		step 1 : wff = axiom ax-1 () |- ( -. ph -> ( -. ps -> -. ph ) ) ;
		step 2 : wff = theorem a3d (step 1) |- ( -. ph -> ( ph -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  A contradiction implies anything.  Inference from ~ pm2.21 .  */
	theorem pm2_21i (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- -. ph ;
		-----------------
		prop : wff = |- ( ph -> ps ) ;
	}

	/*  [16-Sep-1993]  */ 
	proof of pm2_21i {
		step 1 : wff = theorem a1i (hyp 1) |- ( -. ps -> -. ph ) ;
		step 2 : wff = theorem a3i (step 1) |- ( ph -> ps ) ;
		qed prop = step 2 ;
	}

	/*  A contradiction implies anything.  Deduction from ~ pm2.21 .  */
	theorem pm2_21d (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> -. ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ch ) ) ;
	}

	/*  [10-Feb-1996]  */ 
	proof of pm2_21d {
		step 1 : wff = theorem a1d (hyp 1) |- ( ph -> ( -. ch -> -. ps ) ) ;
		step 2 : wff = theorem a3d (step 1) |- ( ph -> ( ps -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.24 of [WhiteheadRussell] p. 104.  */
	theorem pm2_24 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( -. ph -> ps ) ) ;
	}

	/*  [6-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_24 {
		step 1 : wff = theorem pm2_21 () |- ( -. ph -> ( ph -> ps ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( ph -> ( -. ph -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  A contradiction implies anything.  Inference from ~ pm2.24 .  */
	theorem pm2_24ii (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- -. ph ;
		-----------------
		prop : wff = |- ps ;
	}

	/*  [27-Feb-2008]  */ /*  [27-Feb-2008]  */ 
	proof of pm2_24ii {
		step 1 : wff = theorem pm2_21i (hyp 2) |- ( ph -> ps ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ps ;
		qed prop = step 2 ;
	}

	/*  Proof by contradiction.  Theorem *2.18 of [WhiteheadRussell] p. 103.
	     Also called the Law of Clavius.  */
	theorem pm2_18 (var ph : wff ) 
	{
		prop : wff = |- ( ( -. ph -> ph ) -> ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm2_18 {
		step 1 : wff = theorem pm2_21 () |- ( -. ph -> ( ph -> -. ( -. ph -> ph ) ) ) ;
		step 2 : wff = theorem a2i (step 1) |- ( ( -. ph -> ph ) -> ( -. ph -> -. ( -. ph -> ph ) ) ) ;
		step 3 : wff = theorem a3d (step 2) |- ( ( -. ph -> ph ) -> ( ( -. ph -> ph ) -> ph ) ) ;
		step 4 : wff = theorem pm2_43i (step 3) |- ( ( -. ph -> ph ) -> ph ) ;
		qed prop = step 4 ;
	}

	/*  Peirce's axiom.  This odd-looking theorem is the "difference" between
	     an intuitionistic system of propositional calculus and a classical system
	     and is not accepted by intuitionists.  When Peirce's axiom is added to an
	     intuitionistic system, the system becomes equivalent to our classical
	     system ~ ax-1 through ~ ax-3 .  A curious fact about this
	     theorem is that it requires ~ ax-3 for its proof even though the
	     result has no negation connectives in it.  */
	theorem peirce (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) -> ph ) -> ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of peirce {
		step 1 : wff = theorem pm2_21 () |- ( -. ph -> ( ph -> ps ) ) ;
		step 2 : wff = theorem imim1i (step 1) |- ( ( ( ph -> ps ) -> ph ) -> ( -. ph -> ph ) ) ;
		step 3 : wff = theorem pm2_18 () |- ( ( -. ph -> ph ) -> ph ) ;
		step 4 : wff = theorem syl (step 2, step 3) |- ( ( ( ph -> ps ) -> ph ) -> ph ) ;
		qed prop = step 4 ;
	}

	/*  The Inversion Axiom of the infinite-valued sentential logic (L-infinity)
	     of Lukasiewicz.  Using ~ dfor2 , we can see that this essentially
	     expresses "disjunction commutes."  Theorem *2.69 of [WhiteheadRussell]
	     p. 108.  */
	theorem looinv (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) -> ps ) -> ( ( ps -> ph ) -> ph ) ) ;
	}

	/*  [20-Aug-2004]  */ /*  [12-Aug-2004]  */ 
	proof of looinv {
		step 1 : wff = theorem imim1 () |- ( ( ( ph -> ps ) -> ps ) -> ( ( ps -> ph ) -> ( ( ph -> ps ) -> ph ) ) ) ;
		step 2 : wff = theorem peirce () |- ( ( ( ph -> ps ) -> ph ) -> ph ) ;
		step 3 : wff = theorem syl6 (step 1, step 2) |- ( ( ( ph -> ps ) -> ps ) -> ( ( ps -> ph ) -> ph ) ) ;
		qed prop = step 3 ;
	}

	/*  Converse of double negation.  Theorem *2.14 of [WhiteheadRussell] p. 102.
	     (The proof was shortened by David Harvey, 5-Sep-99.  An even shorter
	     proof found by Josh Purinton, 29-Dec-00.)  */
	theorem nega (var ph : wff ) 
	{
		prop : wff = |- ( -. -. ph -> ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of nega {
		step 1 : wff = theorem pm2_21 () |- ( -. -. ph -> ( -. ph -> ph ) ) ;
		step 2 : wff = theorem pm2_18 () |- ( ( -. ph -> ph ) -> ph ) ;
		step 3 : wff = theorem syl (step 1, step 2) |- ( -. -. ph -> ph ) ;
		qed prop = step 3 ;
	}

	/*  Inference from double negation.  */
	theorem negai (var ph : wff ) 
	{
		hyp 1 : wff = |- -. -. ph ;
		-----------------
		prop : wff = |- ph ;
	}

	/*  [27-Feb-2008]  */ /*  [27-Feb-2008]  */ 
	proof of negai {
		step 1 : wff = theorem nega () |- ( -. -. ph -> ph ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ph ;
		qed prop = step 2 ;
	}

	/*  Converse of double negation.  Theorem *2.12 of [WhiteheadRussell]
	     p. 101.  */
	theorem negb (var ph : wff ) 
	{
		prop : wff = |- ( ph -> -. -. ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of negb {
		step 1 : wff = theorem nega () |- ( -. -. -. ph -> -. ph ) ;
		step 2 : wff = theorem a3i (step 1) |- ( ph -> -. -. ph ) ;
		qed prop = step 2 ;
	}

	/*  Infer double negation.  */
	theorem negbi (var ph : wff ) 
	{
		hyp 1 : wff = |- ph ;
		-----------------
		prop : wff = |- -. -. ph ;
	}

	/*  [27-Feb-2008]  */ /*  [27-Feb-2008]  */ 
	proof of negbi {
		step 1 : wff = theorem negb () |- ( ph -> -. -. ph ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- -. -. ph ;
		qed prop = step 2 ;
	}

	/*  Reductio ad absurdum.  Theorem *2.01 of [WhiteheadRussell] p. 100.  */
	theorem pm2_01 (var ph : wff ) 
	{
		prop : wff = |- ( ( ph -> -. ph ) -> -. ph ) ;
	}

	/*  [18-Aug-1993]  */ 
	proof of pm2_01 {
		step 1 : wff = theorem nega () |- ( -. -. ph -> ph ) ;
		step 2 : wff = theorem imim1i (step 1) |- ( ( ph -> -. ph ) -> ( -. -. ph -> -. ph ) ) ;
		step 3 : wff = theorem pm2_18 () |- ( ( -. -. ph -> -. ph ) -> -. ph ) ;
		step 4 : wff = theorem syl (step 2, step 3) |- ( ( ph -> -. ph ) -> -. ph ) ;
		qed prop = step 4 ;
	}

	/*  Deduction based on reductio ad absurdum.  */
	theorem pm2_01d (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> -. ps ) ) ;
		-----------------
		prop : wff = |- ( ph -> -. ps ) ;
	}

	/*  [18-Aug-1993]  */ 
	proof of pm2_01d {
		step 1 : wff = theorem pm2_01 () |- ( ( ps -> -. ps ) -> -. ps ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> -. ps ) ;
		qed prop = step 2 ;
	}

	/*  Contraposition.  Theorem *2.03 of [WhiteheadRussell] p. 100.  */
	theorem con2 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> -. ps ) -> ( ps -> -. ph ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of con2 {
		step 1 : wff = theorem nega () |- ( -. -. ph -> ph ) ;
		step 2 : wff = theorem imim1i (step 1) |- ( ( ph -> -. ps ) -> ( -. -. ph -> -. ps ) ) ;
		step 3 : wff = theorem a3d (step 2) |- ( ( ph -> -. ps ) -> ( ps -> -. ph ) ) ;
		qed prop = step 3 ;
	}

	/*  A contraposition deduction.  */
	theorem con2d (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> -. ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ch -> -. ps ) ) ;
	}

	/*  [19-Aug-1993]  */ 
	proof of con2d {
		step 1 : wff = theorem con2 () |- ( ( ps -> -. ch ) -> ( ch -> -. ps ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( ch -> -. ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Contraposition.  Theorem *2.15 of [WhiteheadRussell] p. 102.  */
	theorem con1 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( -. ph -> ps ) -> ( -. ps -> ph ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of con1 {
		step 1 : wff = theorem negb () |- ( ps -> -. -. ps ) ;
		step 2 : wff = theorem imim2i (step 1) |- ( ( -. ph -> ps ) -> ( -. ph -> -. -. ps ) ) ;
		step 3 : wff = theorem a3d (step 2) |- ( ( -. ph -> ps ) -> ( -. ps -> ph ) ) ;
		qed prop = step 3 ;
	}

	/*  A contraposition deduction.  */
	theorem con1d (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( -. ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( -. ch -> ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of con1d {
		step 1 : wff = theorem con1 () |- ( ( -. ps -> ch ) -> ( -. ch -> ps ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( -. ch -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Contraposition.  Theorem *2.16 of [WhiteheadRussell] p. 103.  */
	theorem con3 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( -. ps -> -. ph ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of con3 {
		step 1 : wff = theorem negb () |- ( ps -> -. -. ps ) ;
		step 2 : wff = theorem imim2i (step 1) |- ( ( ph -> ps ) -> ( ph -> -. -. ps ) ) ;
		step 3 : wff = theorem con2d (step 2) |- ( ( ph -> ps ) -> ( -. ps -> -. ph ) ) ;
		qed prop = step 3 ;
	}

	/*  A contraposition deduction.  */
	theorem con3d (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( -. ch -> -. ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of con3d {
		step 1 : wff = theorem con3 () |- ( ( ps -> ch ) -> ( -. ch -> -. ps ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( -. ch -> -. ps ) ) ;
		qed prop = step 2 ;
	}

	/*  A contraposition inference.  */
	theorem con1i (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( -. ph -> ps ) ;
		-----------------
		prop : wff = |- ( -. ps -> ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of con1i {
		step 1 : wff = theorem negb () |- ( ps -> -. -. ps ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( -. ph -> -. -. ps ) ;
		step 3 : wff = theorem a3i (step 2) |- ( -. ps -> ph ) ;
		qed prop = step 3 ;
	}

	/*  A contraposition inference.  */
	theorem con2i (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph -> -. ps ) ;
		-----------------
		prop : wff = |- ( ps -> -. ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of con2i {
		step 1 : wff = theorem nega () |- ( -. -. ph -> ph ) ;
		step 2 : wff = theorem syl (step 1, hyp 1) |- ( -. -. ph -> -. ps ) ;
		step 3 : wff = theorem a3i (step 2) |- ( ps -> -. ph ) ;
		qed prop = step 3 ;
	}

	/*  A contraposition inference.  */
	theorem con3i (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( -. ps -> -. ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of con3i {
		step 1 : wff = theorem nega () |- ( -. -. ph -> ph ) ;
		step 2 : wff = theorem syl (step 1, hyp 1) |- ( -. -. ph -> ps ) ;
		step 3 : wff = theorem con1i (step 2) |- ( -. ps -> -. ph ) ;
		qed prop = step 3 ;
	}

	/*  This is NOT theorem *2.37 of [WhiteheadRussell] p. 105.  */
	theorem pm2_37OLD (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ps -> ch ) -> ( ( -. ps -> ph ) -> ( -. ph -> ch ) ) ) ;
	}

	/*  [23-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_37OLD {
		step 1 : wff = theorem con1 () |- ( ( -. ps -> ph ) -> ( -. ph -> ps ) ) ;
		step 2 : wff = theorem imim1d (step 1) |- ( ( -. ps -> ph ) -> ( ( ps -> ch ) -> ( -. ph -> ch ) ) ) ;
		step 3 : wff = theorem com12 (step 2) |- ( ( ps -> ch ) -> ( ( -. ps -> ph ) -> ( -. ph -> ch ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.5 of [WhiteheadRussell] p. 107.  */
	theorem pm2_5 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph -> ps ) -> ( -. ph -> ps ) ) ;
	}

	/*  [27-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_5 {
		step 1 : wff = theorem pm2_21 () |- ( -. ph -> ( ph -> ps ) ) ;
		step 2 : wff = theorem con3i (step 1) |- ( -. ( ph -> ps ) -> -. -. ph ) ;
		step 3 : wff = theorem pm2_21d (step 2) |- ( -. ( ph -> ps ) -> ( -. ph -> ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.51 of [WhiteheadRussell] p. 107.  */
	theorem pm2_51 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph -> ps ) -> ( ph -> -. ps ) ) ;
	}

	/*  [27-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_51 {
		step 1 : wff = axiom ax-1 () |- ( ps -> ( ph -> ps ) ) ;
		step 2 : wff = theorem con3i (step 1) |- ( -. ( ph -> ps ) -> -. ps ) ;
		step 3 : wff = theorem a1d (step 2) |- ( -. ( ph -> ps ) -> ( ph -> -. ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.52 of [WhiteheadRussell] p. 107.  */
	theorem pm2_52 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph -> ps ) -> ( -. ph -> -. ps ) ) ;
	}

	/*  [27-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_52 {
		step 1 : wff = axiom ax-1 () |- ( ps -> ( ph -> ps ) ) ;
		step 2 : wff = theorem con3i (step 1) |- ( -. ( ph -> ps ) -> -. ps ) ;
		step 3 : wff = theorem a1d (step 2) |- ( -. ( ph -> ps ) -> ( -. ph -> -. ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.521 of [WhiteheadRussell] p. 107.  */
	theorem pm2_521 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph -> ps ) -> ( ps -> ph ) ) ;
	}

	/*  [6-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_521 {
		step 1 : wff = theorem pm2_52 () |- ( -. ( ph -> ps ) -> ( -. ph -> -. ps ) ) ;
		step 2 : wff = theorem a3d (step 1) |- ( -. ( ph -> ps ) -> ( ps -> ph ) ) ;
		qed prop = step 2 ;
	}

	/*  Inference version of ~ pm2.24 .  */
	theorem pm2_24i (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ph ;
		-----------------
		prop : wff = |- ( -. ph -> ps ) ;
	}

	/*  [20-Aug-2001]  */ 
	proof of pm2_24i {
		step 1 : wff = theorem a1i (hyp 1) |- ( -. ps -> ph ) ;
		step 2 : wff = theorem con1i (step 1) |- ( -. ph -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Deduction version of ~ pm2.21 .  */
	theorem pm2_24d (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( -. ps -> ch ) ) ;
	}

	/*  [31-Jan-2006]  */ /*  [30-Jan-2006]  */ 
	proof of pm2_24d {
		step 1 : wff = theorem a1d (hyp 1) |- ( ph -> ( -. ch -> ps ) ) ;
		step 2 : wff = theorem con1d (step 1) |- ( ph -> ( -. ps -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  The rule of modus tollens.  */
	theorem mto (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- -. ps ;
		hyp 2 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- -. ph ;
	}

	/*  [19-Aug-1993]  */ 
	proof of mto {
		step 1 : wff = theorem con3i (hyp 2) |- ( -. ps -> -. ph ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- -. ph ;
		qed prop = step 2 ;
	}

	/*  Modus tollens inference.  */
	theorem mtoi (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- -. ch ;
		hyp 2 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> -. ps ) ;
	}

	/*  [5-Jul-1994]  */ 
	proof of mtoi {
		step 1 : wff = theorem con3d (hyp 2) |- ( ph -> ( -. ch -> -. ps ) ) ;
		step 2 : wff = theorem mpi (hyp 1, step 1) |- ( ph -> -. ps ) ;
		qed prop = step 2 ;
	}

	/*  Modus tollens deduction.  */
	theorem mtod (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> -. ch ) ;
		hyp 2 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> -. ps ) ;
	}

	/*  [3-Apr-1994]  */ 
	proof of mtod {
		step 1 : wff = theorem con3d (hyp 2) |- ( ph -> ( -. ch -> -. ps ) ) ;
		step 2 : wff = theorem mpd (hyp 1, step 1) |- ( ph -> -. ps ) ;
		qed prop = step 2 ;
	}

	/*  A rule similar to modus tollens.  */
	theorem mt2 (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ps ;
		hyp 2 : wff = |- ( ph -> -. ps ) ;
		-----------------
		prop : wff = |- -. ph ;
	}

	/*  [19-Aug-1993]  */ 
	proof of mt2 {
		step 1 : wff = theorem con2i (hyp 2) |- ( ps -> -. ph ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- -. ph ;
		qed prop = step 2 ;
	}

	/*  Modus tollens inference.  */
	theorem mt2i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ch ;
		hyp 2 : wff = |- ( ph -> ( ps -> -. ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> -. ps ) ;
	}

	/*  [26-Mar-1995]  */ 
	proof of mt2i {
		step 1 : wff = theorem con2d (hyp 2) |- ( ph -> ( ch -> -. ps ) ) ;
		step 2 : wff = theorem mpi (hyp 1, step 1) |- ( ph -> -. ps ) ;
		qed prop = step 2 ;
	}

	/*  Modus tollens deduction.  */
	theorem mt2d (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ch ) ;
		hyp 2 : wff = |- ( ph -> ( ps -> -. ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> -. ps ) ;
	}

	/*  [4-Jul-1994]  */ 
	proof of mt2d {
		step 1 : wff = theorem con2d (hyp 2) |- ( ph -> ( ch -> -. ps ) ) ;
		step 2 : wff = theorem mpd (hyp 1, step 1) |- ( ph -> -. ps ) ;
		qed prop = step 2 ;
	}

	/*  A rule similar to modus tollens.  */
	theorem mt3 (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- -. ps ;
		hyp 2 : wff = |- ( -. ph -> ps ) ;
		-----------------
		prop : wff = |- ph ;
	}

	/*  [18-May-1994]  */ 
	proof of mt3 {
		step 1 : wff = theorem con1i (hyp 2) |- ( -. ps -> ph ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ph ;
		qed prop = step 2 ;
	}

	/*  Modus tollens inference.  */
	theorem mt3i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- -. ch ;
		hyp 2 : wff = |- ( ph -> ( -. ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ps ) ;
	}

	/*  [26-Mar-1995]  */ 
	proof of mt3i {
		step 1 : wff = theorem con1d (hyp 2) |- ( ph -> ( -. ch -> ps ) ) ;
		step 2 : wff = theorem mpi (hyp 1, step 1) |- ( ph -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Modus tollens deduction.  */
	theorem mt3d (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> -. ch ) ;
		hyp 2 : wff = |- ( ph -> ( -. ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ps ) ;
	}

	/*  [26-Mar-1995]  */ 
	proof of mt3d {
		step 1 : wff = theorem con1d (hyp 2) |- ( ph -> ( -. ch -> ps ) ) ;
		step 2 : wff = theorem mpd (hyp 1, step 1) |- ( ph -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Modus tollens deduction.  */
	theorem mt4d (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ph -> ( -. ch -> -. ps ) ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [18-Jun-2006]  */ /*  [9-Jun-2006]  */ 
	proof of mt4d {
		step 1 : wff = theorem a3d (hyp 2) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem mpd (hyp 1, step 1) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A negated syllogism inference.  */
	theorem nsyl (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> -. ps ) ;
		hyp 2 : wff = |- ( ch -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> -. ch ) ;
	}

	/*  [31-Dec-1993]  */ 
	proof of nsyl {
		step 1 : wff = theorem con3i (hyp 2) |- ( -. ps -> -. ch ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> -. ch ) ;
		qed prop = step 2 ;
	}

	/*  A negated syllogism deduction.  */
	theorem nsyld (var ph : wff , var ps : wff , var ch : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> -. ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ta -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> -. ta ) ) ;
	}

	/*  [10-Apr-2005]  */ /*  [9-Apr-2005]  */ 
	proof of nsyld {
		step 1 : wff = theorem con3d (hyp 2) |- ( ph -> ( -. ch -> -. ta ) ) ;
		step 2 : wff = theorem syld (hyp 1, step 1) |- ( ph -> ( ps -> -. ta ) ) ;
		qed prop = step 2 ;
	}

	/*  A negated syllogism inference.  */
	theorem nsyl2 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> -. ps ) ;
		hyp 2 : wff = |- ( -. ch -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [26-Jun-1994]  */ 
	proof of nsyl2 {
		step 1 : wff = theorem con1i (hyp 2) |- ( -. ps -> ch ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A negated syllogism inference.  */
	theorem nsyl3 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> -. ps ) ;
		hyp 2 : wff = |- ( ch -> ps ) ;
		-----------------
		prop : wff = |- ( ch -> -. ph ) ;
	}

	/*  [1-Dec-1995]  */ 
	proof of nsyl3 {
		step 1 : wff = theorem con2i (hyp 1) |- ( ps -> -. ph ) ;
		step 2 : wff = theorem syl (hyp 2, step 1) |- ( ch -> -. ph ) ;
		qed prop = step 2 ;
	}

	/*  A negated syllogism inference.  */
	theorem nsyl4 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( -. ph -> ch ) ;
		-----------------
		prop : wff = |- ( -. ch -> ps ) ;
	}

	/*  [15-Feb-1996]  */ 
	proof of nsyl4 {
		step 1 : wff = theorem con1i (hyp 2) |- ( -. ch -> ph ) ;
		step 2 : wff = theorem syl (step 1, hyp 1) |- ( -. ch -> ps ) ;
		qed prop = step 2 ;
	}

	/*  A negated syllogism inference.  */
	theorem nsyli (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( th -> -. ch ) ;
		-----------------
		prop : wff = |- ( ph -> ( th -> -. ps ) ) ;
	}

	/*  [3-May-1994]  */ 
	proof of nsyli {
		step 1 : wff = theorem con3d (hyp 1) |- ( ph -> ( -. ch -> -. ps ) ) ;
		step 2 : wff = theorem syl5 (step 1, hyp 2) |- ( ph -> ( th -> -. ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *3.2 of [WhiteheadRussell] p. 111, expressed with primitive
	     connectives.  (The proof was shortened by Josh Purinton, 29-Dec-00.)  */
	theorem pm3_2im (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ps -> -. ( ph -> -. ps ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm3_2im {
		step 1 : wff = theorem pm2_27 () |- ( ph -> ( ( ph -> -. ps ) -> -. ps ) ) ;
		step 2 : wff = theorem con2d (step 1) |- ( ph -> ( ps -> -. ( ph -> -. ps ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem 8 of [Margaris] p. 60.  (The proof was shortened by Josh Purinton,
	     29-Dec-00.)  */
	theorem mth8 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( -. ps -> -. ( ph -> ps ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of mth8 {
		step 1 : wff = theorem pm2_27 () |- ( ph -> ( ( ph -> ps ) -> ps ) ) ;
		step 2 : wff = theorem con3d (step 1) |- ( ph -> ( -. ps -> -. ( ph -> ps ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.61 of [WhiteheadRussell] p. 107.  Useful for eliminating an
	     antecedent.  (The proof was shortened by Mel L. O'Cat, 19-Feb-2008.)  */
	theorem pm2_61 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( -. ph -> ps ) -> ps ) ) ;
	}

	/*  [6-Mar-2008]  */ /*  [5-Aug-1993]  */ 
	proof of pm2_61 {
		step 1 : wff = theorem con1 () |- ( ( -. ph -> ps ) -> ( -. ps -> ph ) ) ;
		step 2 : wff = theorem imim1d (step 1) |- ( ( -. ph -> ps ) -> ( ( ph -> ps ) -> ( -. ps -> ps ) ) ) ;
		step 3 : wff = theorem pm2_18 () |- ( ( -. ps -> ps ) -> ps ) ;
		step 4 : wff = theorem syl6com (step 2, step 3) |- ( ( ph -> ps ) -> ( ( -. ph -> ps ) -> ps ) ) ;
		qed prop = step 4 ;
	}

	/*  Theorem *2.61 of [WhiteheadRussell] p. 107.  Useful for eliminating an
	     antecedent.  (The proof was shortened by Mel L. O'Cat, 19-Feb-2008.)  */
	theorem pm2_61-ocatOLD (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( -. ph -> ps ) -> ps ) ) ;
	}

	/*  [19-Feb-2008]  */ /*  [5-Aug-1993]  */ 
	proof of pm2_61-ocatOLD {
		step 1 : wff = theorem pm2_37OLD () |- ( ( ph -> ps ) -> ( ( -. ph -> ps ) -> ( -. ps -> ps ) ) ) ;
		step 2 : wff = theorem pm2_18 () |- ( ( -. ps -> ps ) -> ps ) ;
		step 3 : wff = theorem syl6 (step 1, step 2) |- ( ( ph -> ps ) -> ( ( -. ph -> ps ) -> ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.61 of [WhiteheadRussell] p. 107.  Useful for eliminating an
	     antecedent.  */
	theorem pm2_61OLD (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( -. ph -> ps ) -> ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm2_61OLD {
		step 1 : wff = theorem imim2 () |- ( ( ph -> ps ) -> ( ( -. ps -> ph ) -> ( -. ps -> ps ) ) ) ;
		step 2 : wff = theorem pm2_18 () |- ( ( -. ps -> ps ) -> ps ) ;
		step 3 : wff = theorem syl6 (step 1, step 2) |- ( ( ph -> ps ) -> ( ( -. ps -> ph ) -> ps ) ) ;
		step 4 : wff = theorem con1 () |- ( ( -. ph -> ps ) -> ( -. ps -> ph ) ) ;
		step 5 : wff = theorem syl5 (step 3, step 4) |- ( ( ph -> ps ) -> ( ( -. ph -> ps ) -> ps ) ) ;
		qed prop = step 5 ;
	}

	/*  Inference eliminating an antecedent.  */
	theorem pm2_61i (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( -. ph -> ps ) ;
		-----------------
		prop : wff = |- ps ;
	}

	/*  [5-Apr-1994]  */ 
	proof of pm2_61i {
		step 1 : wff = theorem pm2_61 () |- ( ( ph -> ps ) -> ( ( -. ph -> ps ) -> ps ) ) ;
		step 2 : wff = theorem mp2 (hyp 1, hyp 2, step 1) |- ps ;
		qed prop = step 2 ;
	}

	/*  Deduction eliminating an antecedent.  */
	theorem pm2_61d (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( -. ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [27-Apr-1994]  */ 
	proof of pm2_61d {
		step 1 : wff = theorem com12 (hyp 1) |- ( ps -> ( ph -> ch ) ) ;
		step 2 : wff = theorem com12 (hyp 2) |- ( -. ps -> ( ph -> ch ) ) ;
		step 3 : wff = theorem pm2_61i (step 1, step 2) |- ( ph -> ch ) ;
		qed prop = step 3 ;
	}

	/*  Inference eliminating an antecedent.  */
	theorem pm2_61d1 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( -. ps -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [20-Jul-2005]  */ /*  [15-Jul-2005]  */ 
	proof of pm2_61d1 {
		step 1 : wff = theorem a1i (hyp 2) |- ( ph -> ( -. ps -> ch ) ) ;
		step 2 : wff = theorem pm2_61d (hyp 1, step 1) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Inference eliminating an antecedent.  */
	theorem pm2_61d2 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( -. ps -> ch ) ) ;
		hyp 2 : wff = |- ( ps -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [18-Aug-1993]  */ 
	proof of pm2_61d2 {
		step 1 : wff = theorem a1i (hyp 2) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem pm2_61d (step 1, hyp 1) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Inference eliminating two antecedents.  (The proof was shortened by Josh
	       Purinton,  29-Dec-00.)  */
	theorem pm2_61ii (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( -. ph -> ( -. ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ch ) ;
		hyp 3 : wff = |- ( ps -> ch ) ;
		-----------------
		prop : wff = |- ch ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm2_61ii {
		step 1 : wff = theorem pm2_61d2 (hyp 1, hyp 3) |- ( -. ph -> ch ) ;
		step 2 : wff = theorem pm2_61i (hyp 2, step 1) |- ch ;
		qed prop = step 2 ;
	}

	/*  Inference eliminating two antecedents.  */
	theorem pm2_61nii (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( -. ph -> ch ) ;
		hyp 3 : wff = |- ( -. ps -> ch ) ;
		-----------------
		prop : wff = |- ch ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm2_61nii {
		step 1 : wff = theorem com12 (hyp 1) |- ( ps -> ( ph -> ch ) ) ;
		step 2 : wff = theorem pm2_61d1 (step 1, hyp 2) |- ( ps -> ch ) ;
		step 3 : wff = theorem pm2_61i (step 2, hyp 3) |- ch ;
		qed prop = step 3 ;
	}

	/*  Inference eliminating three antecedents.  */
	theorem pm2_61iii (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( -. ph -> ( -. ps -> ( -. ch -> th ) ) ) ;
		hyp 2 : wff = |- ( ph -> th ) ;
		hyp 3 : wff = |- ( ps -> th ) ;
		hyp 4 : wff = |- ( ch -> th ) ;
		-----------------
		prop : wff = |- th ;
	}

	/*  [2-Jan-2002]  */ 
	proof of pm2_61iii {
		step 1 : wff = theorem a1d (hyp 2) |- ( ph -> ( -. ch -> th ) ) ;
		step 2 : wff = theorem a1d (step 1) |- ( ph -> ( -. ps -> ( -. ch -> th ) ) ) ;
		step 3 : wff = theorem pm2_61i (step 2, hyp 1) |- ( -. ps -> ( -. ch -> th ) ) ;
		step 4 : wff = theorem pm2_61ii (step 3, hyp 3, hyp 4) |- th ;
		qed prop = step 4 ;
	}

	/*  Theorem *2.6 of [WhiteheadRussell] p. 107.  */
	theorem pm2_6 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( -. ph -> ps ) -> ( ( ph -> ps ) -> ps ) ) ;
	}

	/*  [1-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_6 {
		step 1 : wff = theorem pm2_61 () |- ( ( ph -> ps ) -> ( ( -. ph -> ps ) -> ps ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( ( -. ph -> ps ) -> ( ( ph -> ps ) -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.65 of [WhiteheadRussell] p. 107.  Useful for eliminating a
	     consequent.  */
	theorem pm2_65 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( ph -> -. ps ) -> -. ph ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm2_65 {
		step 1 : wff = theorem pm3_2im () |- ( ph -> ( ps -> -. ( ph -> -. ps ) ) ) ;
		step 2 : wff = theorem a2i (step 1) |- ( ( ph -> ps ) -> ( ph -> -. ( ph -> -. ps ) ) ) ;
		step 3 : wff = theorem con2d (step 2) |- ( ( ph -> ps ) -> ( ( ph -> -. ps ) -> -. ph ) ) ;
		qed prop = step 3 ;
	}

	/*  Inference rule for proof by contradiction.  */
	theorem pm2_65i (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ph -> -. ps ) ;
		-----------------
		prop : wff = |- -. ph ;
	}

	/*  [18-May-1994]  */ 
	proof of pm2_65i {
		step 1 : wff = theorem nsyl (hyp 2, hyp 1) |- ( ph -> -. ph ) ;
		step 2 : wff = theorem pm2_01 () |- ( ( ph -> -. ph ) -> -. ph ) ;
		step 3 : wff = axiom ax-mp (step 1, step 2) |- -. ph ;
		qed prop = step 3 ;
	}

	/*  Deduction rule for proof by contradiction.  */
	theorem pm2_65d (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ps -> -. ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> -. ps ) ;
	}

	/*  [26-Jun-1994]  */ 
	proof of pm2_65d {
		step 1 : wff = theorem pm2_65 () |- ( ( ps -> ch ) -> ( ( ps -> -. ch ) -> -. ps ) ) ;
		step 2 : wff = theorem sylc (step 1, hyp 1, hyp 2) |- ( ph -> -. ps ) ;
		qed prop = step 2 ;
	}

	/*  Inference joining the antecedents of two premises.  (The proof was
	       shortened by Mel L. O'Cat, 19-Feb-2008.)  */
	theorem ja (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( -. ph -> ch ) ;
		hyp 2 : wff = |- ( ps -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph -> ps ) -> ch ) ;
	}

	/*  [19-Feb-2008]  */ /*  [5-Aug-1993]  */ 
	proof of ja {
		step 1 : wff = theorem imim2i (hyp 2) |- ( ( ph -> ps ) -> ( ph -> ch ) ) ;
		step 2 : wff = theorem pm2_61d1 (step 1, hyp 1) |- ( ( ph -> ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Inference joining the antecedents of two premises.  (The proof was
	       shortened by Mel L. O'Cat, 30-Aug-2004.)  */
	theorem jaOLD (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( -. ph -> ch ) ;
		hyp 2 : wff = |- ( ps -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph -> ps ) -> ch ) ;
	}

	/*  [30-Aug-2004]  */ /*  [5-Aug-1993]  */ 
	proof of jaOLD {
		step 1 : wff = theorem pm2_27 () |- ( ph -> ( ( ph -> ps ) -> ps ) ) ;
		step 2 : wff = theorem syl6 (step 1, hyp 2) |- ( ph -> ( ( ph -> ps ) -> ch ) ) ;
		step 3 : wff = theorem a1d (hyp 1) |- ( -. ph -> ( ( ph -> ps ) -> ch ) ) ;
		step 4 : wff = theorem pm2_61i (step 2, step 3) |- ( ( ph -> ps ) -> ch ) ;
		qed prop = step 4 ;
	}

	/*  Inference joining the consequents of two premises.  */
	theorem jc (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ph -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> -. ( ps -> -. ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of jc {
		step 1 : wff = theorem pm3_2im () |- ( ps -> ( ch -> -. ( ps -> -. ch ) ) ) ;
		step 2 : wff = theorem sylc (step 1, hyp 1, hyp 2) |- ( ph -> -. ( ps -> -. ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Simplification.  Similar to Theorem *3.26 (Simp) of [WhiteheadRussell]
	     p. 112.  */
	theorem pm3_26im (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph -> -. ps ) -> ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm3_26im {
		step 1 : wff = theorem pm2_21 () |- ( -. ph -> ( ph -> -. ps ) ) ;
		step 2 : wff = theorem con1i (step 1) |- ( -. ( ph -> -. ps ) -> ph ) ;
		qed prop = step 2 ;
	}

	/*  Simplification.  Similar to Theorem *3.27 (Simp) of [WhiteheadRussell]
	     p. 112.  */
	theorem pm3_27im (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph -> -. ps ) -> ps ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm3_27im {
		step 1 : wff = axiom ax-1 () |- ( -. ps -> ( ph -> -. ps ) ) ;
		step 2 : wff = theorem con1i (step 1) |- ( -. ( ph -> -. ps ) -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Importation theorem expressed with primitive connectives.  */
	theorem impt (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ps -> ch ) ) -> ( -. ( ph -> -. ps ) -> ch ) ) ;
	}

	/*  [25-Apr-1994]  */ 
	proof of impt {
		step 1 : wff = theorem con3 () |- ( ( ps -> ch ) -> ( -. ch -> -. ps ) ) ;
		step 2 : wff = theorem imim2i (step 1) |- ( ( ph -> ( ps -> ch ) ) -> ( ph -> ( -. ch -> -. ps ) ) ) ;
		step 3 : wff = theorem com23 (step 2) |- ( ( ph -> ( ps -> ch ) ) -> ( -. ch -> ( ph -> -. ps ) ) ) ;
		step 4 : wff = theorem con1d (step 3) |- ( ( ph -> ( ps -> ch ) ) -> ( -. ( ph -> -. ps ) -> ch ) ) ;
		qed prop = step 4 ;
	}

	/*  Exportation theorem expressed with primitive connectives.  */
	theorem expt (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( -. ( ph -> -. ps ) -> ch ) -> ( ph -> ( ps -> ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of expt {
		step 1 : wff = theorem pm3_2im () |- ( ph -> ( ps -> -. ( ph -> -. ps ) ) ) ;
		step 2 : wff = theorem imim1d (step 1) |- ( ph -> ( ( -. ( ph -> -. ps ) -> ch ) -> ( ps -> ch ) ) ) ;
		step 3 : wff = theorem com12 (step 2) |- ( ( -. ( ph -> -. ps ) -> ch ) -> ( ph -> ( ps -> ch ) ) ) ;
		qed prop = step 3 ;
	}

	/*  An importation inference.  */
	theorem impi (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( -. ( ph -> -. ps ) -> ch ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of impi {
		step 1 : wff = theorem impt () |- ( ( ph -> ( ps -> ch ) ) -> ( -. ( ph -> -. ps ) -> ch ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( -. ( ph -> -. ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  An exportation inference.  */
	theorem expi (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( -. ( ph -> -. ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of expi {
		step 1 : wff = theorem expt () |- ( ( -. ( ph -> -. ps ) -> ch ) -> ( ph -> ( ps -> ch ) ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ph -> ( ps -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem used to justify definition of biconditional ~ def-bi .  (The proof
	     was shortened by Josh Purinton, 29-Dec-00.)  */
	theorem bijust (var ph : wff ) 
	{
		prop : wff = |- -. ( ( ph -> ph ) -> -. ( ph -> ph ) ) ;
	}

	/*  [11-May-1999]  */ 
	proof of bijust {
		step 1 : wff = theorem id () |- ( ph -> ph ) ;
		step 2 : wff = theorem pm2_01 () |- ( ( ( ph -> ph ) -> -. ( ph -> ph ) ) -> -. ( ph -> ph ) ) ;
		step 3 : wff = theorem mt2 (step 1, step 2) |- -. ( ( ph -> ph ) -> -. ( ph -> ph ) ) ;
		qed prop = step 3 ;
	}

	/* 
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	        Logical equivalence
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	 */
	/*  Declare the biconditional connective.  */
	/*  Double arrow (read:  'if and only if' or
	               'is logically equivalent to')  */
	/*  Extend our wff definition to include the biconditional connective.  */
	constant 
	{
		symbol <-> ;
	}

	rule wb (var ph : wff , var ps : wff ) 
	{
		term : wff = # ( ph <-> ps ) ;
	}

	/*  This is our first definition, which introduces and defines the
	     biconditional connective ` <-> ` .  We define a wff of the form
	     ` ( ph <-> ps ) ` as an abbreviation for
	     ` -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ` .
	
	     Unlike most traditional developments, we have chosen not to have a
	     separate symbol such as "Df." to mean "is defined as."  Instead, we will
	     later use the biconditional connective for this purpose ( ~ df-or is its
	     first use), as it allows us to use logic to manipulate definitions
	     directly.  This greatly simplifies many proofs since it eliminates the
	     need for a separate mechanism for introducing and eliminating
	     definitions.  Of course, we cannot use this mechanism to define the
	     biconditional itself, since it hasn't been introduced yet.
	
	     In its most general form, a definition is simply an assertion that
	     introduces a new symbol (or a new combination of existing symbols, as in
	     ~ df-3an ) that is eliminable and does not strengthen the existing
	     language.  The latter requirement means that the set of provable
	     statements not containing the new symbol (or new combination) should
	     remain exactly the same after the definition is introduced.  Our
	     definition of the biconditional may look unusual compared to most
	     definitions, but it strictly satisfies these requirements.
	
	     The justification for our definition is that if we mechanically replace
	     the first wff above (the definiendum i.e. the thing being defined) with
	     the second (the definiens i.e. the defining expression) in the
	     definition, the definition becomes a substitution instance of previously
	     proved theorem ~ bijust .  It is impossible to use ~ def-bi to prove any
	     statement expressed in the original language that can't be proved from
	     the original axioms.  For if it were, we could replace it with instances
	     of ~ bijust throughout the proof, thus obtaining a proof from the
	     original axioms (contradiction).
	
	     Note that from Metamath's point of view, a definition is just another
	     axiom - i.e. an assertion we claim to be true - but from our high level
	     point of view, we are are not strengthening the language.  To indicate
	     this fact, we prefix definition labels with "df-" instead of "ax-".
	     (This prefixing is an informal convention that means nothing to the
	     Metamath proof verifier; it is just for human readability.)
	
	     See ~ bii and ~ bi for theorems suggesting the typical textbook
	     definition of ` <-> ` , showing that our definition has the properties
	     we expect.   */
	axiom def-bi (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ;
	}

	/*  Property of the biconditional connective.  */
	theorem bi1 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph <-> ps ) -> ( ph -> ps ) ) ;
	}

	/*  [11-May-1999]  */ 
	proof of bi1 {
		step 1 : wff = axiom def-bi () |- -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ;
		step 2 : wff = theorem pm3_26im () |- ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ;
		step 3 : wff = axiom ax-mp (step 1, step 2) |- ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ;
		step 4 : wff = theorem pm3_26im () |- ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph -> ps ) ) ;
		step 5 : wff = theorem syl (step 3, step 4) |- ( ( ph <-> ps ) -> ( ph -> ps ) ) ;
		qed prop = step 5 ;
	}

	/*  Property of the biconditional connective.  */
	theorem bi2 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph <-> ps ) -> ( ps -> ph ) ) ;
	}

	/*  [11-May-1999]  */ 
	proof of bi2 {
		step 1 : wff = axiom def-bi () |- -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ;
		step 2 : wff = theorem pm3_26im () |- ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ;
		step 3 : wff = axiom ax-mp (step 1, step 2) |- ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ;
		step 4 : wff = theorem pm3_27im () |- ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ps -> ph ) ) ;
		step 5 : wff = theorem syl (step 3, step 4) |- ( ( ph <-> ps ) -> ( ps -> ph ) ) ;
		qed prop = step 5 ;
	}

	/*  Property of the biconditional connective.  */
	theorem bi3 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( ps -> ph ) -> ( ph <-> ps ) ) ) ;
	}

	/*  [11-May-1999]  */ 
	proof of bi3 {
		step 1 : wff = axiom def-bi () |- -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ;
		step 2 : wff = theorem pm3_27im () |- ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ;
		step 3 : wff = axiom ax-mp (step 1, step 2) |- ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ;
		step 4 : wff = theorem expi (step 3) |- ( ( ph -> ps ) -> ( ( ps -> ph ) -> ( ph <-> ps ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Infer an implication from a logical equivalence.  */
	theorem biimp (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ps ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of biimp {
		step 1 : wff = theorem bi1 () |- ( ( ph <-> ps ) -> ( ph -> ps ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ph -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Infer a converse implication from a logical equivalence.  */
	theorem biimpr (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ( ps -> ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of biimpr {
		step 1 : wff = theorem bi2 () |- ( ( ph <-> ps ) -> ( ps -> ph ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ps -> ph ) ;
		qed prop = step 2 ;
	}

	/*  Deduce an implication from a logical equivalence.  */
	theorem biimpd (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of biimpd {
		step 1 : wff = theorem bi1 () |- ( ( ps <-> ch ) -> ( ps -> ch ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( ps -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduce a converse implication from a logical equivalence.  */
	theorem biimprd (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ch -> ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of biimprd {
		step 1 : wff = theorem bi2 () |- ( ( ps <-> ch ) -> ( ch -> ps ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( ch -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduce a commuted implication from a logical equivalence.  */
	theorem biimpcd (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ps -> ( ph -> ch ) ) ;
	}

	/*  [3-May-1994]  */ 
	proof of biimpcd {
		step 1 : wff = theorem biimpd (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( ps -> ( ph -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduce a converse commuted implication from a logical equivalence.  */
	theorem biimprcd (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ch -> ( ph -> ps ) ) ;
	}

	/*  [3-May-1994]  */ 
	proof of biimprcd {
		step 1 : wff = theorem biimprd (hyp 1) |- ( ph -> ( ch -> ps ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( ch -> ( ph -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Infer an equivalence from an implication and its converse.  */
	theorem impbi (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ps -> ph ) ;
		-----------------
		prop : wff = |- ( ph <-> ps ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of impbi {
		step 1 : wff = theorem bi3 () |- ( ( ph -> ps ) -> ( ( ps -> ph ) -> ( ph <-> ps ) ) ) ;
		step 2 : wff = theorem mp2 (hyp 1, hyp 2, step 1) |- ( ph <-> ps ) ;
		qed prop = step 2 ;
	}

	/*  Relate the biconditional connective to primitive connectives.  See ~ biigb
	     for an unusual version proved directly from axioms.  */
	theorem bii (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bii {
		step 1 : wff = theorem bi1 () |- ( ( ph <-> ps ) -> ( ph -> ps ) ) ;
		step 2 : wff = theorem bi2 () |- ( ( ph <-> ps ) -> ( ps -> ph ) ) ;
		step 3 : wff = theorem jc (step 1, step 2) |- ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ;
		step 4 : wff = theorem bi3 () |- ( ( ph -> ps ) -> ( ( ps -> ph ) -> ( ph <-> ps ) ) ) ;
		step 5 : wff = theorem impi (step 4) |- ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ;
		step 6 : wff = theorem impbi (step 3, step 5) |- ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ;
		qed prop = step 6 ;
	}

	/*  This proof of ~ bii , discovered by Gregory Bush on 8-Mar-2004, has
	     several curious properties.  First, it has only 17 steps directly
	     from the axioms and ~ def-bi , compared to over 800 steps were the proof
	     of ~ bii expanded into axioms.  Second, step 2 demands only the property
	     of "true"; any axiom (or theorem) could be used.  It might be thought,
	     therefore, that it is in some sense redundant, but in fact no proof
	     is shorter than this (measured by number of steps).  Third, it illustrates
	     how intermediate steps can "blow up" in size even in short proofs.
	     Fourth, the compressed proof is only 182 bytes (or 17 bytes in D-proof
	     notation), but the generated web page is over 200kB with intermediate
	     steps that are essentially incomprehensible to humans (other than Gregory
	     Bush).  If there were an obfuscated code contest for proofs, this would be
	     a contender.  */
	theorem biigb (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ;
	}

	/*  [10-Mar-2004]  */ /*  [10-Mar-2004]  */ 
	proof of biigb {
		step 1 : wff = axiom def-bi () |- -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ;
		var ch : wff ;
		var th : wff ;
		step 2 : wff = axiom ax-1 () |- ( ch -> ( th -> ch ) ) ;
		step 3 : wff = axiom ax-1 () |- ( -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) -> ( ( ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ) -> -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ) ) ;
		step 4 : wff = axiom def-bi () |- -. ( ( ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ) -> -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ) ;
		step 5 : wff = axiom ax-1 () |- ( -. ( ( ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ) -> -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ) -> ( -. -. ( ch -> ( th -> ch ) ) -> -. ( ( ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ) -> -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ) ) ) ;
		step 6 : wff = axiom ax-mp (step 4, step 5) |- ( -. -. ( ch -> ( th -> ch ) ) -> -. ( ( ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ) -> -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ) ) ;
		step 7 : wff = axiom ax-3 () |- ( ( -. -. ( ch -> ( th -> ch ) ) -> -. ( ( ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ) -> -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ) ) -> ( ( ( ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ) -> -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ) -> -. ( ch -> ( th -> ch ) ) ) ) ;
		step 8 : wff = axiom ax-mp (step 6, step 7) |- ( ( ( ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ) -> -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ) -> -. ( ch -> ( th -> ch ) ) ) ;
		step 9 : wff = axiom ax-1 () |- ( ( ( ( ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ) -> -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ) -> -. ( ch -> ( th -> ch ) ) ) -> ( -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) -> ( ( ( ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ) -> -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ) -> -. ( ch -> ( th -> ch ) ) ) ) ) ;
		step 10 : wff = axiom ax-mp (step 8, step 9) |- ( -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) -> ( ( ( ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ) -> -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ) -> -. ( ch -> ( th -> ch ) ) ) ) ;
		step 11 : wff = axiom ax-2 () |- ( ( -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) -> ( ( ( ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ) -> -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ) -> -. ( ch -> ( th -> ch ) ) ) ) -> ( ( -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) -> ( ( ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ) -> -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ) ) -> ( -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) -> -. ( ch -> ( th -> ch ) ) ) ) ) ;
		step 12 : wff = axiom ax-mp (step 10, step 11) |- ( ( -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) -> ( ( ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) ) -> -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ) ) -> ( -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) -> -. ( ch -> ( th -> ch ) ) ) ) ;
		step 13 : wff = axiom ax-mp (step 3, step 12) |- ( -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) -> -. ( ch -> ( th -> ch ) ) ) ;
		step 14 : wff = axiom ax-3 () |- ( ( -. ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) -> -. ( ch -> ( th -> ch ) ) ) -> ( ( ch -> ( th -> ch ) ) -> ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ) ) ;
		step 15 : wff = axiom ax-mp (step 13, step 14) |- ( ( ch -> ( th -> ch ) ) -> ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ) ;
		step 16 : wff = axiom ax-mp (step 2, step 15) |- ( -. ( ( ( ph <-> ps ) -> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) -> -. ( -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) -> ( ph <-> ps ) ) ) -> ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ) ;
		step 17 : wff = axiom ax-mp (step 1, step 16) |- ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ;
		qed prop = step 17 ;
	}

	/*  Logical equivalence of commuted antecedents.  Part of Theorem *4.87 of
	     [WhiteheadRussell] p. 122.  */
	theorem bi2_04 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ps -> ch ) ) <-> ( ps -> ( ph -> ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bi2_04 {
		step 1 : wff = theorem pm2_04 () |- ( ( ph -> ( ps -> ch ) ) -> ( ps -> ( ph -> ch ) ) ) ;
		step 2 : wff = theorem pm2_04 () |- ( ( ps -> ( ph -> ch ) ) -> ( ph -> ( ps -> ch ) ) ) ;
		step 3 : wff = theorem impbi (step 1, step 2) |- ( ( ph -> ( ps -> ch ) ) <-> ( ps -> ( ph -> ch ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Double negation.  Theorem *4.13 of [WhiteheadRussell] p. 117.  */
	theorem pm4_13 (var ph : wff ) 
	{
		prop : wff = |- ( ph <-> -. -. ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm4_13 {
		step 1 : wff = theorem negb () |- ( ph -> -. -. ph ) ;
		step 2 : wff = theorem nega () |- ( -. -. ph -> ph ) ;
		step 3 : wff = theorem impbi (step 1, step 2) |- ( ph <-> -. -. ph ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *4.8 of [WhiteheadRussell] p. 122.  */
	theorem pm4_8 (var ph : wff ) 
	{
		prop : wff = |- ( ( ph -> -. ph ) <-> -. ph ) ;
	}

	/*  [5-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_8 {
		step 1 : wff = theorem pm2_01 () |- ( ( ph -> -. ph ) -> -. ph ) ;
		step 2 : wff = axiom ax-1 () |- ( -. ph -> ( ph -> -. ph ) ) ;
		step 3 : wff = theorem impbi (step 1, step 2) |- ( ( ph -> -. ph ) <-> -. ph ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *4.81 of [WhiteheadRussell] p. 122.  */
	theorem pm4_81 (var ph : wff ) 
	{
		prop : wff = |- ( ( -. ph -> ph ) <-> ph ) ;
	}

	/*  [10-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_81 {
		step 1 : wff = theorem pm2_18 () |- ( ( -. ph -> ph ) -> ph ) ;
		step 2 : wff = theorem pm2_24 () |- ( ph -> ( -. ph -> ph ) ) ;
		step 3 : wff = theorem impbi (step 1, step 2) |- ( ( -. ph -> ph ) <-> ph ) ;
		qed prop = step 3 ;
	}

	/*  Contraposition.  Theorem *4.1 of [WhiteheadRussell] p. 116.  */
	theorem pm4_1 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) <-> ( -. ps -> -. ph ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm4_1 {
		step 1 : wff = theorem con3 () |- ( ( ph -> ps ) -> ( -. ps -> -. ph ) ) ;
		step 2 : wff = axiom ax-3 () |- ( ( -. ps -> -. ph ) -> ( ph -> ps ) ) ;
		step 3 : wff = theorem impbi (step 1, step 2) |- ( ( ph -> ps ) <-> ( -. ps -> -. ph ) ) ;
		qed prop = step 3 ;
	}

	/*  Contraposition.  Bidirectional version of ~ con2 .  */
	theorem bi2_03 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> -. ps ) <-> ( ps -> -. ph ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bi2_03 {
		step 1 : wff = theorem con2 () |- ( ( ph -> -. ps ) -> ( ps -> -. ph ) ) ;
		step 2 : wff = theorem con2 () |- ( ( ps -> -. ph ) -> ( ph -> -. ps ) ) ;
		step 3 : wff = theorem impbi (step 1, step 2) |- ( ( ph -> -. ps ) <-> ( ps -> -. ph ) ) ;
		qed prop = step 3 ;
	}

	/*  Contraposition.  Bidirectional version of ~ con1 .  */
	theorem bi2_15 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( -. ph -> ps ) <-> ( -. ps -> ph ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bi2_15 {
		step 1 : wff = theorem con1 () |- ( ( -. ph -> ps ) -> ( -. ps -> ph ) ) ;
		step 2 : wff = theorem con1 () |- ( ( -. ps -> ph ) -> ( -. ph -> ps ) ) ;
		step 3 : wff = theorem impbi (step 1, step 2) |- ( ( -. ph -> ps ) <-> ( -. ps -> ph ) ) ;
		qed prop = step 3 ;
	}

	/*  Antecedent absorption implication.  Theorem *5.4 of
	     [WhiteheadRussell] p. 125.  */
	theorem pm5_4 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ph -> ps ) ) <-> ( ph -> ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm5_4 {
		step 1 : wff = theorem pm2_43 () |- ( ( ph -> ( ph -> ps ) ) -> ( ph -> ps ) ) ;
		step 2 : wff = axiom ax-1 () |- ( ( ph -> ps ) -> ( ph -> ( ph -> ps ) ) ) ;
		step 3 : wff = theorem impbi (step 1, step 2) |- ( ( ph -> ( ph -> ps ) ) <-> ( ph -> ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Distributive law for implication.  Compare Theorem *5.41 of
	     [WhiteheadRussell] p. 125.  */
	theorem imdi (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ps -> ch ) ) <-> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of imdi {
		step 1 : wff = axiom ax-2 () |- ( ( ph -> ( ps -> ch ) ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ;
		step 2 : wff = theorem pm2_86 () |- ( ( ( ph -> ps ) -> ( ph -> ch ) ) -> ( ph -> ( ps -> ch ) ) ) ;
		step 3 : wff = theorem impbi (step 1, step 2) |- ( ( ph -> ( ps -> ch ) ) <-> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *5.41 of [WhiteheadRussell] p. 125.  */
	theorem pm5_41 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) -> ( ph -> ch ) ) <-> ( ph -> ( ps -> ch ) ) ) ;
	}

	/*  [10-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_41 {
		step 1 : wff = theorem pm2_86 () |- ( ( ( ph -> ps ) -> ( ph -> ch ) ) -> ( ph -> ( ps -> ch ) ) ) ;
		step 2 : wff = axiom ax-2 () |- ( ( ph -> ( ps -> ch ) ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ;
		step 3 : wff = theorem impbi (step 1, step 2) |- ( ( ( ph -> ps ) -> ( ph -> ch ) ) <-> ( ph -> ( ps -> ch ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Principle of identity for logical equivalence.  Theorem *4.2 of
	     [WhiteheadRussell] p. 117.  */
	theorem pm4_2 (var ph : wff ) 
	{
		prop : wff = |- ( ph <-> ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm4_2 {
		step 1 : wff = theorem id () |- ( ph -> ph ) ;
		step 2 : wff = theorem id () |- ( ph -> ph ) ;
		step 3 : wff = theorem impbi (step 1, step 2) |- ( ph <-> ph ) ;
		qed prop = step 3 ;
	}

	/*  Principle of identity with antecedent.  */
	theorem pm4_2i (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ps <-> ps ) ) ;
	}

	/*  [25-Nov-1995]  */ 
	proof of pm4_2i {
		step 1 : wff = theorem pm4_2 () |- ( ps <-> ps ) ;
		step 2 : wff = theorem a1i (step 1) |- ( ph -> ( ps <-> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Inference from commutative law for logical equivalence.  */
	theorem bicomi (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ( ps <-> ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bicomi {
		step 1 : wff = theorem biimpr (hyp 1) |- ( ps -> ph ) ;
		step 2 : wff = theorem biimp (hyp 1) |- ( ph -> ps ) ;
		step 3 : wff = theorem impbi (step 1, step 2) |- ( ps <-> ph ) ;
		qed prop = step 3 ;
	}

	/*  An inference from transitive law for logical equivalence.  */
	theorem bitr (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ps <-> ch ) ;
		-----------------
		prop : wff = |- ( ph <-> ch ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bitr {
		step 1 : wff = theorem biimp (hyp 1) |- ( ph -> ps ) ;
		step 2 : wff = theorem biimp (hyp 2) |- ( ps -> ch ) ;
		step 3 : wff = theorem syl (step 1, step 2) |- ( ph -> ch ) ;
		step 4 : wff = theorem biimpr (hyp 2) |- ( ch -> ps ) ;
		step 5 : wff = theorem biimpr (hyp 1) |- ( ps -> ph ) ;
		step 6 : wff = theorem syl (step 4, step 5) |- ( ch -> ph ) ;
		step 7 : wff = theorem impbi (step 3, step 6) |- ( ph <-> ch ) ;
		qed prop = step 7 ;
	}

	/*  An inference from transitive law for logical equivalence.  */
	theorem bitr2 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ps <-> ch ) ;
		-----------------
		prop : wff = |- ( ch <-> ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bitr2 {
		step 1 : wff = theorem bitr (hyp 1, hyp 2) |- ( ph <-> ch ) ;
		step 2 : wff = theorem bicomi (step 1) |- ( ch <-> ph ) ;
		qed prop = step 2 ;
	}

	/*  An inference from transitive law for logical equivalence.  */
	theorem bitr3 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ps <-> ph ) ;
		hyp 2 : wff = |- ( ps <-> ch ) ;
		-----------------
		prop : wff = |- ( ph <-> ch ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bitr3 {
		step 1 : wff = theorem bicomi (hyp 1) |- ( ph <-> ps ) ;
		step 2 : wff = theorem bitr (step 1, hyp 2) |- ( ph <-> ch ) ;
		qed prop = step 2 ;
	}

	/*  An inference from transitive law for logical equivalence.  */
	theorem bitr4 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ch <-> ps ) ;
		-----------------
		prop : wff = |- ( ph <-> ch ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bitr4 {
		step 1 : wff = theorem bicomi (hyp 2) |- ( ps <-> ch ) ;
		step 2 : wff = theorem bitr (hyp 1, step 1) |- ( ph <-> ch ) ;
		qed prop = step 2 ;
	}

	/*  A chained inference from transitive law for logical equivalence.  */
	theorem _3bitr (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ps <-> ch ) ;
		hyp 3 : wff = |- ( ch <-> th ) ;
		-----------------
		prop : wff = |- ( ph <-> th ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of _3bitr {
		step 1 : wff = theorem bitr (hyp 2, hyp 3) |- ( ps <-> th ) ;
		step 2 : wff = theorem bitr (hyp 1, step 1) |- ( ph <-> th ) ;
		qed prop = step 2 ;
	}

	/*  A chained inference from transitive law for logical equivalence.  */
	theorem _3bitrr (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ps <-> ch ) ;
		hyp 3 : wff = |- ( ch <-> th ) ;
		-----------------
		prop : wff = |- ( th <-> ph ) ;
	}

	/*  [10-Aug-2006]  */ /*  [4-Aug-2006]  */ 
	proof of _3bitrr {
		step 1 : wff = theorem bitr2 (hyp 1, hyp 2) |- ( ch <-> ph ) ;
		step 2 : wff = theorem bitr3 (hyp 3, step 1) |- ( th <-> ph ) ;
		qed prop = step 2 ;
	}

	/*  A chained inference from transitive law for logical equivalence.  */
	theorem _3bitr2 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ch <-> ps ) ;
		hyp 3 : wff = |- ( ch <-> th ) ;
		-----------------
		prop : wff = |- ( ph <-> th ) ;
	}

	/*  [10-Aug-2006]  */ /*  [4-Aug-2006]  */ 
	proof of _3bitr2 {
		step 1 : wff = theorem bitr4 (hyp 1, hyp 2) |- ( ph <-> ch ) ;
		step 2 : wff = theorem bitr (step 1, hyp 3) |- ( ph <-> th ) ;
		qed prop = step 2 ;
	}

	/*  A chained inference from transitive law for logical equivalence.  */
	theorem _3bitr2r (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ch <-> ps ) ;
		hyp 3 : wff = |- ( ch <-> th ) ;
		-----------------
		prop : wff = |- ( th <-> ph ) ;
	}

	/*  [10-Aug-2006]  */ /*  [4-Aug-2006]  */ 
	proof of _3bitr2r {
		step 1 : wff = theorem bitr4 (hyp 1, hyp 2) |- ( ph <-> ch ) ;
		step 2 : wff = theorem bitr2 (step 1, hyp 3) |- ( th <-> ph ) ;
		qed prop = step 2 ;
	}

	/*  A chained inference from transitive law for logical equivalence.  */
	theorem _3bitr3 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ph <-> ch ) ;
		hyp 3 : wff = |- ( ps <-> th ) ;
		-----------------
		prop : wff = |- ( ch <-> th ) ;
	}

	/*  [19-Aug-1993]  */ 
	proof of _3bitr3 {
		step 1 : wff = theorem bitr3 (hyp 2, hyp 1) |- ( ch <-> ps ) ;
		step 2 : wff = theorem bitr (step 1, hyp 3) |- ( ch <-> th ) ;
		qed prop = step 2 ;
	}

	/*  A chained inference from transitive law for logical equivalence.  */
	theorem _3bitr3r (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ph <-> ch ) ;
		hyp 3 : wff = |- ( ps <-> th ) ;
		-----------------
		prop : wff = |- ( th <-> ch ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of _3bitr3r {
		step 1 : wff = theorem bitr3 (hyp 1, hyp 2) |- ( ps <-> ch ) ;
		step 2 : wff = theorem bitr3 (hyp 3, step 1) |- ( th <-> ch ) ;
		qed prop = step 2 ;
	}

	/*  A chained inference from transitive law for logical equivalence.  This
	       inference is frequently used to apply a definition to both sides of a
	       logical equivalence.  */
	theorem _3bitr4 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ch <-> ph ) ;
		hyp 3 : wff = |- ( th <-> ps ) ;
		-----------------
		prop : wff = |- ( ch <-> th ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of _3bitr4 {
		step 1 : wff = theorem bitr4 (hyp 1, hyp 3) |- ( ph <-> th ) ;
		step 2 : wff = theorem bitr (hyp 2, step 1) |- ( ch <-> th ) ;
		qed prop = step 2 ;
	}

	/*  A chained inference from transitive law for logical equivalence.  */
	theorem _3bitr4r (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ch <-> ph ) ;
		hyp 3 : wff = |- ( th <-> ps ) ;
		-----------------
		prop : wff = |- ( th <-> ch ) ;
	}

	/*  [2-Sep-1995]  */ 
	proof of _3bitr4r {
		step 1 : wff = theorem bitr4 (hyp 1, hyp 3) |- ( ph <-> th ) ;
		step 2 : wff = theorem bitr2 (hyp 2, step 1) |- ( th <-> ch ) ;
		qed prop = step 2 ;
	}

	/*  Introduce an antecedent to both sides of a logical equivalence.  */
	theorem imbi2i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ( ( ch -> ph ) <-> ( ch -> ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of imbi2i {
		step 1 : wff = theorem biimp (hyp 1) |- ( ph -> ps ) ;
		step 2 : wff = theorem imim2i (step 1) |- ( ( ch -> ph ) -> ( ch -> ps ) ) ;
		step 3 : wff = theorem biimpr (hyp 1) |- ( ps -> ph ) ;
		step 4 : wff = theorem imim2i (step 3) |- ( ( ch -> ps ) -> ( ch -> ph ) ) ;
		step 5 : wff = theorem impbi (step 2, step 4) |- ( ( ch -> ph ) <-> ( ch -> ps ) ) ;
		qed prop = step 5 ;
	}

	/*  Introduce a consequent to both sides of a logical equivalence.  */
	theorem imbi1i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ( ( ph -> ch ) <-> ( ps -> ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of imbi1i {
		step 1 : wff = theorem biimpr (hyp 1) |- ( ps -> ph ) ;
		step 2 : wff = theorem imim1i (step 1) |- ( ( ph -> ch ) -> ( ps -> ch ) ) ;
		step 3 : wff = theorem biimp (hyp 1) |- ( ph -> ps ) ;
		step 4 : wff = theorem imim1i (step 3) |- ( ( ps -> ch ) -> ( ph -> ch ) ) ;
		step 5 : wff = theorem impbi (step 2, step 4) |- ( ( ph -> ch ) <-> ( ps -> ch ) ) ;
		qed prop = step 5 ;
	}

	/*  Negate both sides of a logical equivalence.  */
	theorem negbii (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ( -. ph <-> -. ps ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of negbii {
		step 1 : wff = theorem biimpr (hyp 1) |- ( ps -> ph ) ;
		step 2 : wff = theorem con3i (step 1) |- ( -. ph -> -. ps ) ;
		step 3 : wff = theorem biimp (hyp 1) |- ( ph -> ps ) ;
		step 4 : wff = theorem con3i (step 3) |- ( -. ps -> -. ph ) ;
		step 5 : wff = theorem impbi (step 2, step 4) |- ( -. ph <-> -. ps ) ;
		qed prop = step 5 ;
	}

	/*  Join two logical equivalences to form equivalence of implications.  */
	theorem imbi12i (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ch <-> th ) ;
		-----------------
		prop : wff = |- ( ( ph -> ch ) <-> ( ps -> th ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of imbi12i {
		step 1 : wff = theorem imbi2i (hyp 2) |- ( ( ph -> ch ) <-> ( ph -> th ) ) ;
		step 2 : wff = theorem imbi1i (hyp 1) |- ( ( ph -> th ) <-> ( ps -> th ) ) ;
		step 3 : wff = theorem bitr (step 1, step 2) |- ( ( ph -> ch ) <-> ( ps -> th ) ) ;
		qed prop = step 3 ;
	}

	/*  An inference from a biconditional, related to modus ponens.  */
	theorem mpbi (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ps ;
	}

	/*  [5-Aug-1993]  */ 
	proof of mpbi {
		step 1 : wff = theorem biimp (hyp 2) |- ( ph -> ps ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ps ;
		qed prop = step 2 ;
	}

	/*  An inference from a biconditional, related to modus ponens.  */
	theorem mpbir (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ps ;
		hyp 2 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ph ;
	}

	/*  [5-Aug-1993]  */ 
	proof of mpbir {
		step 1 : wff = theorem biimpr (hyp 2) |- ( ps -> ph ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ph ;
		qed prop = step 2 ;
	}

	/*  An inference from a biconditional, related to modus tollens.  */
	theorem mtbi (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- -. ph ;
		hyp 2 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- -. ps ;
	}

	/*  [15-Nov-1994]  */ 
	proof of mtbi {
		step 1 : wff = theorem negbii (hyp 2) |- ( -. ph <-> -. ps ) ;
		step 2 : wff = theorem mpbi (hyp 1, step 1) |- -. ps ;
		qed prop = step 2 ;
	}

	/*  An inference from a biconditional, related to modus tollens.  */
	theorem mtbir (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- -. ps ;
		hyp 2 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- -. ph ;
	}

	/*  [15-Nov-1994]  */ 
	proof of mtbir {
		step 1 : wff = theorem negbii (hyp 2) |- ( -. ph <-> -. ps ) ;
		step 2 : wff = theorem mpbir (hyp 1, step 1) |- -. ph ;
		qed prop = step 2 ;
	}

	/*  An inference from a nested biconditional, related to modus ponens.  */
	theorem mpbii (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ps ;
		hyp 2 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of mpbii {
		step 1 : wff = theorem biimpd (hyp 2) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem mpi (hyp 1, step 1) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  An inference from a nested biconditional, related to modus ponens.  */
	theorem mpbiri (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ch ;
		hyp 2 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ps ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of mpbiri {
		step 1 : wff = theorem biimprd (hyp 2) |- ( ph -> ( ch -> ps ) ) ;
		step 2 : wff = theorem mpi (hyp 1, step 1) |- ( ph -> ps ) ;
		qed prop = step 2 ;
	}

	/*  A deduction from a biconditional, related to modus ponens.  */
	theorem mpbid (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of mpbid {
		step 1 : wff = theorem biimpd (hyp 2) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem mpd (hyp 1, step 1) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A deduction from a biconditional, related to modus ponens.  */
	theorem mpbird (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ch ) ;
		hyp 2 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ps ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of mpbird {
		step 1 : wff = theorem biimprd (hyp 2) |- ( ph -> ( ch -> ps ) ) ;
		step 2 : wff = theorem mpd (hyp 1, step 1) |- ( ph -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Inference rule introducing a theorem as an antecedent.  */
	theorem a1bi (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ph ;
		-----------------
		prop : wff = |- ( ps <-> ( ph -> ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of a1bi {
		step 1 : wff = axiom ax-1 () |- ( ps -> ( ph -> ps ) ) ;
		step 2 : wff = theorem pm2_27 () |- ( ph -> ( ( ph -> ps ) -> ps ) ) ;
		step 3 : wff = axiom ax-mp (hyp 1, step 2) |- ( ( ph -> ps ) -> ps ) ;
		step 4 : wff = theorem impbi (step 1, step 3) |- ( ps <-> ( ph -> ps ) ) ;
		qed prop = step 4 ;
	}

	/*  A mixed syllogism inference from an implication and a biconditional.  */
	theorem sylib (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ps <-> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of sylib {
		step 1 : wff = theorem biimp (hyp 2) |- ( ps -> ch ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A mixed syllogism inference from a biconditional and an implication.
	       Useful for substituting an antecedent with a definition.  */
	theorem sylbi (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ps -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of sylbi {
		step 1 : wff = theorem biimp (hyp 1) |- ( ph -> ps ) ;
		step 2 : wff = theorem syl (step 1, hyp 2) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A mixed syllogism inference from an implication and a biconditional.
	       Useful for substituting a consequent with a definition.  */
	theorem sylibr (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ch <-> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of sylibr {
		step 1 : wff = theorem biimpr (hyp 2) |- ( ps -> ch ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A mixed syllogism inference from a biconditional and an implication.  */
	theorem sylbir (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ps <-> ph ) ;
		hyp 2 : wff = |- ( ps -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of sylbir {
		step 1 : wff = theorem biimpr (hyp 1) |- ( ph -> ps ) ;
		step 2 : wff = theorem syl (step 1, hyp 2) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism deduction.  */
	theorem sylibd (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ch <-> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [3-Aug-1994]  */ 
	proof of sylibd {
		step 1 : wff = theorem biimpd (hyp 2) |- ( ph -> ( ch -> th ) ) ;
		step 2 : wff = theorem syld (hyp 1, step 1) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism deduction.  */
	theorem sylbid (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ch -> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [3-Aug-1994]  */ 
	proof of sylbid {
		step 1 : wff = theorem biimpd (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem syld (step 1, hyp 2) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism deduction.  */
	theorem sylibrd (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [3-Aug-1994]  */ 
	proof of sylibrd {
		step 1 : wff = theorem biimprd (hyp 2) |- ( ph -> ( ch -> th ) ) ;
		step 2 : wff = theorem syld (hyp 1, step 1) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism deduction.  */
	theorem sylbird (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ch <-> ps ) ) ;
		hyp 2 : wff = |- ( ph -> ( ch -> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [3-Aug-1994]  */ 
	proof of sylbird {
		step 1 : wff = theorem biimprd (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem syld (step 1, hyp 2) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A mixed syllogism inference from a nested implication and a
	       biconditional.  Useful for substituting an embedded antecedent with a
	       definition.  */
	theorem syl5ib (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( th <-> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( th -> ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl5ib {
		step 1 : wff = theorem biimp (hyp 2) |- ( th -> ps ) ;
		step 2 : wff = theorem syl5 (hyp 1, step 1) |- ( ph -> ( th -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  A mixed syllogism inference from a nested implication and a
	       biconditional.  */
	theorem syl5ibr (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ps <-> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( th -> ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl5ibr {
		step 1 : wff = theorem biimpr (hyp 2) |- ( th -> ps ) ;
		step 2 : wff = theorem syl5 (hyp 1, step 1) |- ( ph -> ( th -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  A mixed syllogism inference.  */
	theorem syl5bi (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( th -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( th -> ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl5bi {
		step 1 : wff = theorem biimpd (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem syl5 (step 1, hyp 2) |- ( ph -> ( th -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  A mixed syllogism inference.  */
	theorem syl5cbi (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( th -> ps ) ;
		-----------------
		prop : wff = |- ( th -> ( ph -> ch ) ) ;
	}

	/*  [22-Jun-2007]  */ /*  [19-Jun-2007]  */ 
	proof of syl5cbi {
		step 1 : wff = theorem syl5bi (hyp 1, hyp 2) |- ( ph -> ( th -> ch ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( th -> ( ph -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  A mixed syllogism inference.  */
	theorem syl5bir (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( th -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ( th -> ps ) ) ;
	}

	/*  [3-Apr-1994]  */ 
	proof of syl5bir {
		step 1 : wff = theorem biimprd (hyp 1) |- ( ph -> ( ch -> ps ) ) ;
		step 2 : wff = theorem syl5 (step 1, hyp 2) |- ( ph -> ( th -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  A mixed syllogism inference.  */
	theorem syl5cbir (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( th -> ch ) ;
		-----------------
		prop : wff = |- ( th -> ( ph -> ps ) ) ;
	}

	/*  [20-Jun-2007]  */ /*  [20-Jun-2007]  */ 
	proof of syl5cbir {
		step 1 : wff = theorem syl5bir (hyp 1, hyp 2) |- ( ph -> ( th -> ps ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( th -> ( ph -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  A mixed syllogism inference from a nested implication and a
	       biconditional.  */
	theorem syl6ib (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ch <-> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl6ib {
		step 1 : wff = theorem biimp (hyp 2) |- ( ch -> th ) ;
		step 2 : wff = theorem syl6 (hyp 1, step 1) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A mixed syllogism inference from a nested implication and a
	       biconditional.  Useful for substituting an embedded consequent with a
	       definition.  */
	theorem syl6ibr (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( th <-> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl6ibr {
		step 1 : wff = theorem biimpr (hyp 2) |- ( ch -> th ) ;
		step 2 : wff = theorem syl6 (hyp 1, step 1) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A mixed syllogism inference.  */
	theorem syl6bi (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ch -> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [2-Jan-1994]  */ 
	proof of syl6bi {
		step 1 : wff = theorem biimpd (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem syl6 (step 1, hyp 2) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A mixed syllogism inference.  */
	theorem syl6bir (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ch <-> ps ) ) ;
		hyp 2 : wff = |- ( ch -> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [18-May-1994]  */ 
	proof of syl6bir {
		step 1 : wff = theorem biimprd (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem syl6 (step 1, hyp 2) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A mixed syllogism inference from a doubly nested implication and a
	       biconditional.  */
	theorem syl7ib (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		hyp 2 : wff = |- ( ta <-> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ta -> th ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl7ib {
		step 1 : wff = theorem biimp (hyp 2) |- ( ta -> ch ) ;
		step 2 : wff = theorem syl7 (hyp 1, step 1) |- ( ph -> ( ps -> ( ta -> th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism rule of inference.  The second premise is used to replace
	       the consequent of the first premise.  */
	theorem syl8ib (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		hyp 2 : wff = |- ( th <-> ta ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ta ) ) ) ;
	}

	/*  [1-Aug-1994]  */ 
	proof of syl8ib {
		step 1 : wff = theorem biimp (hyp 2) |- ( th -> ta ) ;
		step 2 : wff = theorem syl8 (hyp 1, step 1) |- ( ph -> ( ps -> ( ch -> ta ) ) ) ;
		qed prop = step 2 ;
	}

	/*  A mixed syllogism inference, useful for removing a definition from both
	       sides of an implication.  */
	theorem _3imtr3 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ph <-> ch ) ;
		hyp 3 : wff = |- ( ps <-> th ) ;
		-----------------
		prop : wff = |- ( ch -> th ) ;
	}

	/*  [10-Aug-1994]  */ 
	proof of _3imtr3 {
		step 1 : wff = theorem sylbir (hyp 2, hyp 1) |- ( ch -> ps ) ;
		step 2 : wff = theorem sylib (step 1, hyp 3) |- ( ch -> th ) ;
		qed prop = step 2 ;
	}

	/*  A mixed syllogism inference, useful for applying a definition to both
	       sides of an implication.  */
	theorem _3imtr4 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ch <-> ph ) ;
		hyp 3 : wff = |- ( th <-> ps ) ;
		-----------------
		prop : wff = |- ( ch -> th ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of _3imtr4 {
		step 1 : wff = theorem sylbi (hyp 2, hyp 1) |- ( ch -> ps ) ;
		step 2 : wff = theorem sylibr (step 1, hyp 3) |- ( ch -> th ) ;
		qed prop = step 2 ;
	}

	/*  A contraposition inference.  */
	theorem con1bii (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( -. ph <-> ps ) ;
		-----------------
		prop : wff = |- ( -. ps <-> ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of con1bii {
		step 1 : wff = theorem biimp (hyp 1) |- ( -. ph -> ps ) ;
		step 2 : wff = theorem con1i (step 1) |- ( -. ps -> ph ) ;
		step 3 : wff = theorem biimpr (hyp 1) |- ( ps -> -. ph ) ;
		step 4 : wff = theorem con2i (step 3) |- ( ph -> -. ps ) ;
		step 5 : wff = theorem impbi (step 2, step 4) |- ( -. ps <-> ph ) ;
		qed prop = step 5 ;
	}

	/*  A contraposition inference.  */
	theorem con2bii (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> -. ps ) ;
		-----------------
		prop : wff = |- ( ps <-> -. ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of con2bii {
		step 1 : wff = theorem bicomi (hyp 1) |- ( -. ps <-> ph ) ;
		step 2 : wff = theorem con1bii (step 1) |- ( -. ph <-> ps ) ;
		step 3 : wff = theorem bicomi (step 2) |- ( ps <-> -. ph ) ;
		qed prop = step 3 ;
	}

	/*  For ~ bicon3 :  See ~ negbii .  */
	/*  For ~ con4bii :  Later.  */
	/* 
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	        Logical disjunction and conjunction
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	 */
	/*  Declare connectives for disjunction ('or') and conjunction ('and').  */
	/*  Vee (read:  'or')  */
	constant 
	{
		symbol \/ ;
	}

	/*  Wedge (read:  'and')  */
	/*  Extend wff definition to include disjunction ('or').  */
	constant 
	{
		symbol /\ ;
	}

	rule wo (var ph : wff , var ps : wff ) 
	{
		term : wff = # ( ph \/ ps ) ;
	}

	/*  Extend wff definition to include conjunction ('and').  */
	rule wa (var ph : wff , var ps : wff ) 
	{
		term : wff = # ( ph /\ ps ) ;
	}

	/*  Define disjunction (logical 'or').  This is our first use of the
	     biconditional connective in a definition; we use it in place of the
	     traditional "<=def=>", which means the same thing, except that we can
	     manipulate the biconditional connective directly in proofs rather than
	     having to rely on an informal definition substitution rule.  Note that
	     if we mechanically substitute ` ( -. ph -> ps ) ` for ` ( ph \/ ps ) ` ,
	     we end up with an instance of previously proved theorem ~ pm4.2 .  This
	     is the justification for the definition, along with the fact that it
	     introduces a new symbol ` \/ ` .  Definition of [Margaris] p. 49.  */
	definition df-or (var ph : wff , var ps : wff ) 
	{
		defiendum : wff = # ( ph \/ ps ) ;
		definiens : wff = # ( -. ph -> ps ) ;
		-----------------
		prop : wff = |- ( defiendum <-> definiens ) ;
	}

	/*  Define conjunction (logical 'and').  Definition of [Margaris] p. 49.  */
	definition df-an (var ph : wff , var ps : wff ) 
	{
		defiendum : wff = # ( ph /\ ps ) ;
		definiens : wff = # -. ( ph -> -. ps ) ;
		-----------------
		prop : wff = |- ( defiendum <-> definiens ) ;
	}

	/*  Theorem *4.64 of [WhiteheadRussell] p. 120.  */
	theorem pm4_64 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( -. ph -> ps ) <-> ( ph \/ ps ) ) ;
	}

	/*  [1-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_64 {
		step 1 : wff = definition df-or () |- ( ( ph \/ ps ) <-> ( -. ph -> ps ) ) ;
		step 2 : wff = theorem bicomi (step 1) |- ( ( -. ph -> ps ) <-> ( ph \/ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.54 of [WhiteheadRussell] p. 107.  */
	theorem pm2_54 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( -. ph -> ps ) -> ( ph \/ ps ) ) ;
	}

	/*  [10-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_54 {
		step 1 : wff = definition df-or () |- ( ( ph \/ ps ) <-> ( -. ph -> ps ) ) ;
		step 2 : wff = theorem biimpr (step 1) |- ( ( -. ph -> ps ) -> ( ph \/ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *4.63 of [WhiteheadRussell] p. 120.  */
	theorem pm4_63 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph -> -. ps ) <-> ( ph /\ ps ) ) ;
	}

	/*  [19-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_63 {
		step 1 : wff = definition df-an () |- ( ( ph /\ ps ) <-> -. ( ph -> -. ps ) ) ;
		step 2 : wff = theorem bicomi (step 1) |- ( -. ( ph -> -. ps ) <-> ( ph /\ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Logical 'or' expressed in terms of implication only.  Theorem *5.25 of
	     [WhiteheadRussell] p. 124.  */
	theorem dfor2 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph \/ ps ) <-> ( ( ph -> ps ) -> ps ) ) ;
	}

	/*  [20-Aug-2004]  */ /*  [12-Aug-2004]  */ 
	proof of dfor2 {
		step 1 : wff = definition df-or () |- ( ( ph \/ ps ) <-> ( -. ph -> ps ) ) ;
		step 2 : wff = theorem pm2_6 () |- ( ( -. ph -> ps ) -> ( ( ph -> ps ) -> ps ) ) ;
		step 3 : wff = theorem pm2_21 () |- ( -. ph -> ( ph -> ps ) ) ;
		step 4 : wff = theorem imim1i (step 3) |- ( ( ( ph -> ps ) -> ps ) -> ( -. ph -> ps ) ) ;
		step 5 : wff = theorem impbi (step 2, step 4) |- ( ( -. ph -> ps ) <-> ( ( ph -> ps ) -> ps ) ) ;
		step 6 : wff = theorem bitr (step 1, step 5) |- ( ( ph \/ ps ) <-> ( ( ph -> ps ) -> ps ) ) ;
		qed prop = step 6 ;
	}

	/*  Infer implication from disjunction.  */
	theorem ori (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph \/ ps ) ;
		-----------------
		prop : wff = |- ( -. ph -> ps ) ;
	}

	/*  [11-Jun-1994]  */ 
	proof of ori {
		step 1 : wff = definition df-or () |- ( ( ph \/ ps ) <-> ( -. ph -> ps ) ) ;
		step 2 : wff = theorem mpbi (hyp 1, step 1) |- ( -. ph -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Infer implication from disjunction.  */
	theorem orri (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( -. ph -> ps ) ;
		-----------------
		prop : wff = |- ( ph \/ ps ) ;
	}

	/*  [11-Jun-1994]  */ 
	proof of orri {
		step 1 : wff = definition df-or () |- ( ( ph \/ ps ) <-> ( -. ph -> ps ) ) ;
		step 2 : wff = theorem mpbir (hyp 1, step 1) |- ( ph \/ ps ) ;
		qed prop = step 2 ;
	}

	/*  Deduce implication from disjunction.  */
	theorem ord (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps \/ ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( -. ps -> ch ) ) ;
	}

	/*  [18-May-1994]  */ 
	proof of ord {
		step 1 : wff = definition df-or () |- ( ( ps \/ ch ) <-> ( -. ps -> ch ) ) ;
		step 2 : wff = theorem sylib (hyp 1, step 1) |- ( ph -> ( -. ps -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduce implication from disjunction.  */
	theorem orrd (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( -. ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps \/ ch ) ) ;
	}

	/*  [27-Nov-1995]  */ 
	proof of orrd {
		step 1 : wff = definition df-or () |- ( ( ps \/ ch ) <-> ( -. ps -> ch ) ) ;
		step 2 : wff = theorem sylibr (hyp 1, step 1) |- ( ph -> ( ps \/ ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Implication in terms of disjunction.  Theorem *4.6 of
	     [WhiteheadRussell] p. 120.  */
	theorem imor (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) <-> ( -. ph \/ ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of imor {
		step 1 : wff = theorem pm4_13 () |- ( ph <-> -. -. ph ) ;
		step 2 : wff = theorem imbi1i (step 1) |- ( ( ph -> ps ) <-> ( -. -. ph -> ps ) ) ;
		step 3 : wff = definition df-or () |- ( ( -. ph \/ ps ) <-> ( -. -. ph -> ps ) ) ;
		step 4 : wff = theorem bitr4 (step 2, step 3) |- ( ( ph -> ps ) <-> ( -. ph \/ ps ) ) ;
		qed prop = step 4 ;
	}

	/*  Theorem *4.62 of [WhiteheadRussell] p. 120.  */
	theorem pm4_62 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> -. ps ) <-> ( -. ph \/ -. ps ) ) ;
	}

	/*  [24-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_62 {
		step 1 : wff = theorem imor () |- ( ( ph -> -. ps ) <-> ( -. ph \/ -. ps ) ) ;
		qed prop = step 1 ;
	}

	/*  Theorem *4.66 of [WhiteheadRussell] p. 120.  */
	theorem pm4_66 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( -. ph -> -. ps ) <-> ( ph \/ -. ps ) ) ;
	}

	/*  [1-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_66 {
		step 1 : wff = theorem pm4_64 () |- ( ( -. ph -> -. ps ) <-> ( ph \/ -. ps ) ) ;
		qed prop = step 1 ;
	}

	/*  Express implication in terms of conjunction.  Theorem 3.4(27) of [Stoll]
	     p. 176.  */
	theorem iman (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) <-> -. ( ph /\ -. ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of iman {
		step 1 : wff = theorem pm4_13 () |- ( ps <-> -. -. ps ) ;
		step 2 : wff = theorem imbi2i (step 1) |- ( ( ph -> ps ) <-> ( ph -> -. -. ps ) ) ;
		step 3 : wff = definition df-an () |- ( ( ph /\ -. ps ) <-> -. ( ph -> -. -. ps ) ) ;
		step 4 : wff = theorem con2bii (step 3) |- ( ( ph -> -. -. ps ) <-> -. ( ph /\ -. ps ) ) ;
		step 5 : wff = theorem bitr (step 2, step 4) |- ( ( ph -> ps ) <-> -. ( ph /\ -. ps ) ) ;
		qed prop = step 5 ;
	}

	/*  Express conjunction in terms of implication.  */
	theorem annim (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph /\ -. ps ) <-> -. ( ph -> ps ) ) ;
	}

	/*  [2-Aug-1994]  */ 
	proof of annim {
		step 1 : wff = theorem iman () |- ( ( ph -> ps ) <-> -. ( ph /\ -. ps ) ) ;
		step 2 : wff = theorem con2bii (step 1) |- ( ( ph /\ -. ps ) <-> -. ( ph -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *4.61 of [WhiteheadRussell] p. 120.  */
	theorem pm4_61 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph -> ps ) <-> ( ph /\ -. ps ) ) ;
	}

	/*  [24-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_61 {
		step 1 : wff = theorem annim () |- ( ( ph /\ -. ps ) <-> -. ( ph -> ps ) ) ;
		step 2 : wff = theorem bicomi (step 1) |- ( -. ( ph -> ps ) <-> ( ph /\ -. ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *4.65 of [WhiteheadRussell] p. 120.  */
	theorem pm4_65 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( -. ph -> ps ) <-> ( -. ph /\ -. ps ) ) ;
	}

	/*  [24-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_65 {
		step 1 : wff = theorem pm4_61 () |- ( -. ( -. ph -> ps ) <-> ( -. ph /\ -. ps ) ) ;
		qed prop = step 1 ;
	}

	/*  Theorem *4.67 of [WhiteheadRussell] p. 120.  */
	theorem pm4_67 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( -. ph -> -. ps ) <-> ( -. ph /\ ps ) ) ;
	}

	/*  [27-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_67 {
		step 1 : wff = theorem pm4_63 () |- ( -. ( -. ph -> -. ps ) <-> ( -. ph /\ ps ) ) ;
		qed prop = step 1 ;
	}

	/*  Express implication in terms of conjunction.  */
	theorem imnan (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> -. ps ) <-> -. ( ph /\ ps ) ) ;
	}

	/*  [9-Apr-1994]  */ 
	proof of imnan {
		step 1 : wff = definition df-an () |- ( ( ph /\ ps ) <-> -. ( ph -> -. ps ) ) ;
		step 2 : wff = theorem con2bii (step 1) |- ( ( ph -> -. ps ) <-> -. ( ph /\ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Idempotent law for disjunction.  Theorem *4.25 of [WhiteheadRussell]
	     p. 117.  */
	theorem oridm (var ph : wff ) 
	{
		prop : wff = |- ( ( ph \/ ph ) <-> ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of oridm {
		step 1 : wff = definition df-or () |- ( ( ph \/ ph ) <-> ( -. ph -> ph ) ) ;
		step 2 : wff = theorem pm2_24 () |- ( ph -> ( -. ph -> ph ) ) ;
		step 3 : wff = theorem pm2_18 () |- ( ( -. ph -> ph ) -> ph ) ;
		step 4 : wff = theorem impbi (step 2, step 3) |- ( ph <-> ( -. ph -> ph ) ) ;
		step 5 : wff = theorem bitr4 (step 1, step 4) |- ( ( ph \/ ph ) <-> ph ) ;
		qed prop = step 5 ;
	}

	/*  Theorem *4.25 of [WhiteheadRussell] p. 117.  */
	theorem pm4_25 (var ph : wff ) 
	{
		prop : wff = |- ( ph <-> ( ph \/ ph ) ) ;
	}

	/*  [27-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_25 {
		step 1 : wff = theorem oridm () |- ( ( ph \/ ph ) <-> ph ) ;
		step 2 : wff = theorem bicomi (step 1) |- ( ph <-> ( ph \/ ph ) ) ;
		qed prop = step 2 ;
	}

	/*  Axiom *1.2 (Taut) of [WhiteheadRussell] p. 96.  */
	theorem pm1_2 (var ph : wff ) 
	{
		prop : wff = |- ( ( ph \/ ph ) -> ph ) ;
	}

	/*  [27-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm1_2 {
		step 1 : wff = theorem oridm () |- ( ( ph \/ ph ) <-> ph ) ;
		step 2 : wff = theorem biimp (step 1) |- ( ( ph \/ ph ) -> ph ) ;
		qed prop = step 2 ;
	}

	/*  Commutative law for disjunction.  Theorem *4.31 of [WhiteheadRussell]
	     p. 118.  */
	theorem orcom (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph \/ ps ) <-> ( ps \/ ph ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of orcom {
		step 1 : wff = theorem bi2_15 () |- ( ( -. ph -> ps ) <-> ( -. ps -> ph ) ) ;
		step 2 : wff = definition df-or () |- ( ( ph \/ ps ) <-> ( -. ph -> ps ) ) ;
		step 3 : wff = definition df-or () |- ( ( ps \/ ph ) <-> ( -. ps -> ph ) ) ;
		step 4 : wff = theorem _3bitr4 (step 1, step 2, step 3) |- ( ( ph \/ ps ) <-> ( ps \/ ph ) ) ;
		qed prop = step 4 ;
	}

	/*  Axiom *1.4 of [WhiteheadRussell] p. 96.  */
	theorem pm1_4 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph \/ ps ) -> ( ps \/ ph ) ) ;
	}

	/*  [27-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm1_4 {
		step 1 : wff = theorem orcom () |- ( ( ph \/ ps ) <-> ( ps \/ ph ) ) ;
		step 2 : wff = theorem biimp (step 1) |- ( ( ph \/ ps ) -> ( ps \/ ph ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.62 of [WhiteheadRussell] p. 107.  */
	theorem pm2_62 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph \/ ps ) -> ( ( ph -> ps ) -> ps ) ) ;
	}

	/*  [6-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_62 {
		step 1 : wff = theorem dfor2 () |- ( ( ph \/ ps ) <-> ( ( ph -> ps ) -> ps ) ) ;
		step 2 : wff = theorem biimp (step 1) |- ( ( ph \/ ps ) -> ( ( ph -> ps ) -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.621 of [WhiteheadRussell] p. 107.  */
	theorem pm2_621 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( ph \/ ps ) -> ps ) ) ;
	}

	/*  [6-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_621 {
		step 1 : wff = theorem pm2_62 () |- ( ( ph \/ ps ) -> ( ( ph -> ps ) -> ps ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( ( ph -> ps ) -> ( ( ph \/ ps ) -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.68 of [WhiteheadRussell] p. 108.  */
	theorem pm2_68 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) -> ps ) -> ( ph \/ ps ) ) ;
	}

	/*  [27-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_68 {
		step 1 : wff = theorem dfor2 () |- ( ( ph \/ ps ) <-> ( ( ph -> ps ) -> ps ) ) ;
		step 2 : wff = theorem biimpr (step 1) |- ( ( ( ph -> ps ) -> ps ) -> ( ph \/ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Elimination of disjunction by denial of a disjunct.  Theorem *2.55 of
	     [WhiteheadRussell] p. 107.  */
	theorem orel1 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ph -> ( ( ph \/ ps ) -> ps ) ) ;
	}

	/*  [12-Aug-1994]  */ 
	proof of orel1 {
		step 1 : wff = definition df-or () |- ( ( ph \/ ps ) <-> ( -. ph -> ps ) ) ;
		step 2 : wff = theorem biimp (step 1) |- ( ( ph \/ ps ) -> ( -. ph -> ps ) ) ;
		step 3 : wff = theorem com12 (step 2) |- ( -. ph -> ( ( ph \/ ps ) -> ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Elimination of disjunction by denial of a disjunct.  Theorem *2.56 of
	     [WhiteheadRussell] p. 107.  */
	theorem orel2 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ph -> ( ( ps \/ ph ) -> ps ) ) ;
	}

	/*  [12-Aug-1994]  */ 
	proof of orel2 {
		step 1 : wff = theorem orel1 () |- ( -. ph -> ( ( ph \/ ps ) -> ps ) ) ;
		step 2 : wff = theorem orcom () |- ( ( ps \/ ph ) <-> ( ph \/ ps ) ) ;
		step 3 : wff = theorem syl5ib (step 1, step 2) |- ( -. ph -> ( ( ps \/ ph ) -> ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.25 of [WhiteheadRussell] p. 104.  */
	theorem pm2_25 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph \/ ( ( ph \/ ps ) -> ps ) ) ;
	}

	/*  [1-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_25 {
		step 1 : wff = theorem orel1 () |- ( -. ph -> ( ( ph \/ ps ) -> ps ) ) ;
		step 2 : wff = theorem orri (step 1) |- ( ph \/ ( ( ph \/ ps ) -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.53 of [WhiteheadRussell] p. 107.  */
	theorem pm2_53 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph \/ ps ) -> ( -. ph -> ps ) ) ;
	}

	/*  [1-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_53 {
		step 1 : wff = theorem orel1 () |- ( -. ph -> ( ( ph \/ ps ) -> ps ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( ( ph \/ ps ) -> ( -. ph -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Inference adding a left disjunct to both sides of a logical
	       equivalence.  */
	theorem orbi2i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ( ( ch \/ ph ) <-> ( ch \/ ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of orbi2i {
		step 1 : wff = theorem imbi2i (hyp 1) |- ( ( -. ch -> ph ) <-> ( -. ch -> ps ) ) ;
		step 2 : wff = definition df-or () |- ( ( ch \/ ph ) <-> ( -. ch -> ph ) ) ;
		step 3 : wff = definition df-or () |- ( ( ch \/ ps ) <-> ( -. ch -> ps ) ) ;
		step 4 : wff = theorem _3bitr4 (step 1, step 2, step 3) |- ( ( ch \/ ph ) <-> ( ch \/ ps ) ) ;
		qed prop = step 4 ;
	}

	/*  Inference adding a right disjunct to both sides of a logical
	       equivalence.  */
	theorem orbi1i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ( ( ph \/ ch ) <-> ( ps \/ ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of orbi1i {
		step 1 : wff = theorem orcom () |- ( ( ph \/ ch ) <-> ( ch \/ ph ) ) ;
		step 2 : wff = theorem orbi2i (hyp 1) |- ( ( ch \/ ph ) <-> ( ch \/ ps ) ) ;
		step 3 : wff = theorem orcom () |- ( ( ch \/ ps ) <-> ( ps \/ ch ) ) ;
		step 4 : wff = theorem _3bitr (step 1, step 2, step 3) |- ( ( ph \/ ch ) <-> ( ps \/ ch ) ) ;
		qed prop = step 4 ;
	}

	/*  Infer the disjunction of two equivalences.  */
	theorem orbi12i (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ch <-> th ) ;
		-----------------
		prop : wff = |- ( ( ph \/ ch ) <-> ( ps \/ th ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of orbi12i {
		step 1 : wff = theorem orbi2i (hyp 2) |- ( ( ph \/ ch ) <-> ( ph \/ th ) ) ;
		step 2 : wff = theorem orbi1i (hyp 1) |- ( ( ph \/ th ) <-> ( ps \/ th ) ) ;
		step 3 : wff = theorem bitr (step 1, step 2) |- ( ( ph \/ ch ) <-> ( ps \/ th ) ) ;
		qed prop = step 3 ;
	}

	/*  A rearrangement of disjuncts.  */
	theorem or12 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph \/ ( ps \/ ch ) ) <-> ( ps \/ ( ph \/ ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of or12 {
		step 1 : wff = theorem bi2_04 () |- ( ( -. ps -> ( -. ph -> ch ) ) <-> ( -. ph -> ( -. ps -> ch ) ) ) ;
		step 2 : wff = definition df-or () |- ( ( ph \/ ch ) <-> ( -. ph -> ch ) ) ;
		step 3 : wff = theorem imbi2i (step 2) |- ( ( -. ps -> ( ph \/ ch ) ) <-> ( -. ps -> ( -. ph -> ch ) ) ) ;
		step 4 : wff = definition df-or () |- ( ( ps \/ ch ) <-> ( -. ps -> ch ) ) ;
		step 5 : wff = theorem imbi2i (step 4) |- ( ( -. ph -> ( ps \/ ch ) ) <-> ( -. ph -> ( -. ps -> ch ) ) ) ;
		step 6 : wff = theorem _3bitr4r (step 1, step 3, step 5) |- ( ( -. ph -> ( ps \/ ch ) ) <-> ( -. ps -> ( ph \/ ch ) ) ) ;
		step 7 : wff = definition df-or () |- ( ( ph \/ ( ps \/ ch ) ) <-> ( -. ph -> ( ps \/ ch ) ) ) ;
		step 8 : wff = definition df-or () |- ( ( ps \/ ( ph \/ ch ) ) <-> ( -. ps -> ( ph \/ ch ) ) ) ;
		step 9 : wff = theorem _3bitr4 (step 6, step 7, step 8) |- ( ( ph \/ ( ps \/ ch ) ) <-> ( ps \/ ( ph \/ ch ) ) ) ;
		qed prop = step 9 ;
	}

	/*  Axiom *1.5 (Assoc) of [WhiteheadRussell] p. 96.  */
	theorem pm1_5 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph \/ ( ps \/ ch ) ) -> ( ps \/ ( ph \/ ch ) ) ) ;
	}

	/*  [1-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm1_5 {
		step 1 : wff = theorem or12 () |- ( ( ph \/ ( ps \/ ch ) ) <-> ( ps \/ ( ph \/ ch ) ) ) ;
		step 2 : wff = theorem biimp (step 1) |- ( ( ph \/ ( ps \/ ch ) ) -> ( ps \/ ( ph \/ ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Associative law for disjunction.  Theorem *4.33 of [WhiteheadRussell]
	     p. 118.  */
	theorem orass (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ps ) \/ ch ) <-> ( ph \/ ( ps \/ ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of orass {
		step 1 : wff = theorem or12 () |- ( ( ch \/ ( ph \/ ps ) ) <-> ( ph \/ ( ch \/ ps ) ) ) ;
		step 2 : wff = theorem orcom () |- ( ( ( ph \/ ps ) \/ ch ) <-> ( ch \/ ( ph \/ ps ) ) ) ;
		step 3 : wff = theorem orcom () |- ( ( ps \/ ch ) <-> ( ch \/ ps ) ) ;
		step 4 : wff = theorem orbi2i (step 3) |- ( ( ph \/ ( ps \/ ch ) ) <-> ( ph \/ ( ch \/ ps ) ) ) ;
		step 5 : wff = theorem _3bitr4 (step 1, step 2, step 4) |- ( ( ( ph \/ ps ) \/ ch ) <-> ( ph \/ ( ps \/ ch ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Theorem *2.31 of [WhiteheadRussell] p. 104.  */
	theorem pm2_31 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph \/ ( ps \/ ch ) ) -> ( ( ph \/ ps ) \/ ch ) ) ;
	}

	/*  [2-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_31 {
		step 1 : wff = theorem orass () |- ( ( ( ph \/ ps ) \/ ch ) <-> ( ph \/ ( ps \/ ch ) ) ) ;
		step 2 : wff = theorem biimpr (step 1) |- ( ( ph \/ ( ps \/ ch ) ) -> ( ( ph \/ ps ) \/ ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.32 of [WhiteheadRussell] p. 105.  */
	theorem pm2_32 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ps ) \/ ch ) -> ( ph \/ ( ps \/ ch ) ) ) ;
	}

	/*  [6-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_32 {
		step 1 : wff = theorem orass () |- ( ( ( ph \/ ps ) \/ ch ) <-> ( ph \/ ( ps \/ ch ) ) ) ;
		step 2 : wff = theorem biimp (step 1) |- ( ( ( ph \/ ps ) \/ ch ) -> ( ph \/ ( ps \/ ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  A rearrangement of disjuncts.  */
	theorem or23 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ps ) \/ ch ) <-> ( ( ph \/ ch ) \/ ps ) ) ;
	}

	/*  [18-Oct-1995]  */ 
	proof of or23 {
		step 1 : wff = theorem orcom () |- ( ( ps \/ ch ) <-> ( ch \/ ps ) ) ;
		step 2 : wff = theorem orbi2i (step 1) |- ( ( ph \/ ( ps \/ ch ) ) <-> ( ph \/ ( ch \/ ps ) ) ) ;
		step 3 : wff = theorem orass () |- ( ( ( ph \/ ps ) \/ ch ) <-> ( ph \/ ( ps \/ ch ) ) ) ;
		step 4 : wff = theorem orass () |- ( ( ( ph \/ ch ) \/ ps ) <-> ( ph \/ ( ch \/ ps ) ) ) ;
		step 5 : wff = theorem _3bitr4 (step 2, step 3, step 4) |- ( ( ( ph \/ ps ) \/ ch ) <-> ( ( ph \/ ch ) \/ ps ) ) ;
		qed prop = step 5 ;
	}

	/*  Rearrangement of 4 disjuncts.  */
	theorem or4 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ps ) \/ ( ch \/ th ) ) <-> ( ( ph \/ ch ) \/ ( ps \/ th ) ) ) ;
	}

	/*  [12-Aug-1994]  */ 
	proof of or4 {
		step 1 : wff = theorem or12 () |- ( ( ps \/ ( ch \/ th ) ) <-> ( ch \/ ( ps \/ th ) ) ) ;
		step 2 : wff = theorem orbi2i (step 1) |- ( ( ph \/ ( ps \/ ( ch \/ th ) ) ) <-> ( ph \/ ( ch \/ ( ps \/ th ) ) ) ) ;
		step 3 : wff = theorem orass () |- ( ( ( ph \/ ps ) \/ ( ch \/ th ) ) <-> ( ph \/ ( ps \/ ( ch \/ th ) ) ) ) ;
		step 4 : wff = theorem orass () |- ( ( ( ph \/ ch ) \/ ( ps \/ th ) ) <-> ( ph \/ ( ch \/ ( ps \/ th ) ) ) ) ;
		step 5 : wff = theorem _3bitr4 (step 2, step 3, step 4) |- ( ( ( ph \/ ps ) \/ ( ch \/ th ) ) <-> ( ( ph \/ ch ) \/ ( ps \/ th ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Rearrangement of 4 disjuncts.  */
	theorem or42 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ps ) \/ ( ch \/ th ) ) <-> ( ( ph \/ ch ) \/ ( th \/ ps ) ) ) ;
	}

	/*  [11-Jan-2005]  */ /*  [10-Jan-2005]  */ 
	proof of or42 {
		step 1 : wff = theorem or4 () |- ( ( ( ph \/ ps ) \/ ( ch \/ th ) ) <-> ( ( ph \/ ch ) \/ ( ps \/ th ) ) ) ;
		step 2 : wff = theorem orcom () |- ( ( ps \/ th ) <-> ( th \/ ps ) ) ;
		step 3 : wff = theorem orbi2i (step 2) |- ( ( ( ph \/ ch ) \/ ( ps \/ th ) ) <-> ( ( ph \/ ch ) \/ ( th \/ ps ) ) ) ;
		step 4 : wff = theorem bitr (step 1, step 3) |- ( ( ( ph \/ ps ) \/ ( ch \/ th ) ) <-> ( ( ph \/ ch ) \/ ( th \/ ps ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Distribution of disjunction over disjunction.  */
	theorem orordi (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph \/ ( ps \/ ch ) ) <-> ( ( ph \/ ps ) \/ ( ph \/ ch ) ) ) ;
	}

	/*  [25-Feb-1995]  */ 
	proof of orordi {
		step 1 : wff = theorem oridm () |- ( ( ph \/ ph ) <-> ph ) ;
		step 2 : wff = theorem orbi1i (step 1) |- ( ( ( ph \/ ph ) \/ ( ps \/ ch ) ) <-> ( ph \/ ( ps \/ ch ) ) ) ;
		step 3 : wff = theorem or4 () |- ( ( ( ph \/ ph ) \/ ( ps \/ ch ) ) <-> ( ( ph \/ ps ) \/ ( ph \/ ch ) ) ) ;
		step 4 : wff = theorem bitr3 (step 2, step 3) |- ( ( ph \/ ( ps \/ ch ) ) <-> ( ( ph \/ ps ) \/ ( ph \/ ch ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Distribution of disjunction over disjunction.  */
	theorem orordir (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ps ) \/ ch ) <-> ( ( ph \/ ch ) \/ ( ps \/ ch ) ) ) ;
	}

	/*  [25-Feb-1995]  */ 
	proof of orordir {
		step 1 : wff = theorem oridm () |- ( ( ch \/ ch ) <-> ch ) ;
		step 2 : wff = theorem orbi2i (step 1) |- ( ( ( ph \/ ps ) \/ ( ch \/ ch ) ) <-> ( ( ph \/ ps ) \/ ch ) ) ;
		step 3 : wff = theorem or4 () |- ( ( ( ph \/ ps ) \/ ( ch \/ ch ) ) <-> ( ( ph \/ ch ) \/ ( ps \/ ch ) ) ) ;
		step 4 : wff = theorem bitr3 (step 2, step 3) |- ( ( ( ph \/ ps ) \/ ch ) <-> ( ( ph \/ ch ) \/ ( ps \/ ch ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Introduction of a disjunct.  Axiom *1.3 of [WhiteheadRussell] p. 96.  */
	theorem olc (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ps \/ ph ) ) ;
	}

	/*  [30-Aug-1993]  */ 
	proof of olc {
		step 1 : wff = axiom ax-1 () |- ( ph -> ( -. ps -> ph ) ) ;
		step 2 : wff = theorem orrd (step 1) |- ( ph -> ( ps \/ ph ) ) ;
		qed prop = step 2 ;
	}

	/*  Introduction of a disjunct.  Theorem *2.2 of [WhiteheadRussell] p. 104.  */
	theorem orc (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ph \/ ps ) ) ;
	}

	/*  [30-Aug-1993]  */ 
	proof of orc {
		step 1 : wff = theorem pm2_24 () |- ( ph -> ( -. ph -> ps ) ) ;
		step 2 : wff = theorem orrd (step 1) |- ( ph -> ( ph \/ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction introducing a disjunct.  */
	theorem orci (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ph ;
		-----------------
		prop : wff = |- ( ph \/ ps ) ;
	}

	/*  [20-Jan-2008]  */ /*  [19-Jan-2008]  */ 
	proof of orci {
		step 1 : wff = theorem orc () |- ( ph -> ( ph \/ ps ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ph \/ ps ) ;
		qed prop = step 2 ;
	}

	/*  Deduction introducing a disjunct.  */
	theorem olci (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ph ;
		-----------------
		prop : wff = |- ( ps \/ ph ) ;
	}

	/*  [20-Jan-2008]  */ /*  [19-Jan-2008]  */ 
	proof of olci {
		step 1 : wff = theorem olc () |- ( ph -> ( ps \/ ph ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ps \/ ph ) ;
		qed prop = step 2 ;
	}

	/*  MAY BE REVISED - use the 2 theorems below to shorten others  */
	/*  Deduction introducing a disjunct.  */
	theorem orcd (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps \/ ch ) ) ;
	}

	/*  [19-Feb-2008]  */ 
	proof of orcd {
		step 1 : wff = theorem orc () |- ( ps -> ( ps \/ ch ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( ps \/ ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction eliminating disjunct.  */
	theorem orcs (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph \/ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [21-Jun-1994]  */ 
	proof of orcs {
		step 1 : wff = theorem orc () |- ( ph -> ( ph \/ ps ) ) ;
		step 2 : wff = theorem syl (step 1, hyp 1) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Deduction eliminating disjunct.  */
	theorem olcs (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph \/ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ps -> ch ) ;
	}

	/*  [21-Jun-1994]  */ 
	proof of olcs {
		step 1 : wff = theorem olc () |- ( ps -> ( ph \/ ps ) ) ;
		step 2 : wff = theorem syl (step 1, hyp 1) |- ( ps -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.07 of [WhiteheadRussell] p. 101.  */
	theorem pm2_07 (var ph : wff ) 
	{
		prop : wff = |- ( ph -> ( ph \/ ph ) ) ;
	}

	/*  [6-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_07 {
		step 1 : wff = theorem olc () |- ( ph -> ( ph \/ ph ) ) ;
		qed prop = step 1 ;
	}

	/*  Theorem *2.45 of [WhiteheadRussell] p. 106.  */
	theorem pm2_45 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph \/ ps ) -> -. ph ) ;
	}

	/*  [8-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_45 {
		step 1 : wff = theorem orc () |- ( ph -> ( ph \/ ps ) ) ;
		step 2 : wff = theorem con3i (step 1) |- ( -. ( ph \/ ps ) -> -. ph ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.46 of [WhiteheadRussell] p. 106.  */
	theorem pm2_46 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph \/ ps ) -> -. ps ) ;
	}

	/*  [8-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_46 {
		step 1 : wff = theorem olc () |- ( ps -> ( ph \/ ps ) ) ;
		step 2 : wff = theorem con3i (step 1) |- ( -. ( ph \/ ps ) -> -. ps ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.47 of [WhiteheadRussell] p. 107.  */
	theorem pm2_47 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph \/ ps ) -> ( -. ph \/ ps ) ) ;
	}

	/*  [6-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_47 {
		step 1 : wff = theorem pm2_45 () |- ( -. ( ph \/ ps ) -> -. ph ) ;
		step 2 : wff = theorem orc () |- ( -. ph -> ( -. ph \/ ps ) ) ;
		step 3 : wff = theorem syl (step 1, step 2) |- ( -. ( ph \/ ps ) -> ( -. ph \/ ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.48 of [WhiteheadRussell] p. 107.  */
	theorem pm2_48 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph \/ ps ) -> ( ph \/ -. ps ) ) ;
	}

	/*  [9-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_48 {
		step 1 : wff = theorem pm2_46 () |- ( -. ( ph \/ ps ) -> -. ps ) ;
		step 2 : wff = theorem a1d (step 1) |- ( -. ( ph \/ ps ) -> ( -. ph -> -. ps ) ) ;
		step 3 : wff = theorem orrd (step 2) |- ( -. ( ph \/ ps ) -> ( ph \/ -. ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.49 of [WhiteheadRussell] p. 107.  */
	theorem pm2_49 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph \/ ps ) -> ( -. ph \/ -. ps ) ) ;
	}

	/*  [7-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_49 {
		step 1 : wff = theorem pm2_46 () |- ( -. ( ph \/ ps ) -> -. ps ) ;
		step 2 : wff = theorem a1d (step 1) |- ( -. ( ph \/ ps ) -> ( -. -. ph -> -. ps ) ) ;
		step 3 : wff = theorem orrd (step 2) |- ( -. ( ph \/ ps ) -> ( -. ph \/ -. ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.67 of [WhiteheadRussell] p. 107.  */
	theorem pm2_67 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ps ) -> ps ) -> ( ph -> ps ) ) ;
	}

	/*  [6-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_67 {
		step 1 : wff = theorem orc () |- ( ph -> ( ph \/ ps ) ) ;
		step 2 : wff = theorem imim1i (step 1) |- ( ( ( ph \/ ps ) -> ps ) -> ( ph -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Join antecedents with conjunction.  Theorem *3.2 of [WhiteheadRussell]
	     p. 111.  */
	theorem pm3_2 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ps -> ( ph /\ ps ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm3_2 {
		step 1 : wff = definition df-an () |- ( ( ph /\ ps ) <-> -. ( ph -> -. ps ) ) ;
		step 2 : wff = theorem biimpr (step 1) |- ( -. ( ph -> -. ps ) -> ( ph /\ ps ) ) ;
		step 3 : wff = theorem expi (step 2) |- ( ph -> ( ps -> ( ph /\ ps ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Join antecedents with conjunction.  Theorem *3.21 of
	     [WhiteheadRussell] p. 111.  */
	theorem pm3_21 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ps -> ( ps /\ ph ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm3_21 {
		step 1 : wff = theorem pm3_2 () |- ( ps -> ( ph -> ( ps /\ ph ) ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( ph -> ( ps -> ( ps /\ ph ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Infer conjunction of premises.  */
	theorem pm3_2i (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- ps ;
		-----------------
		prop : wff = |- ( ph /\ ps ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm3_2i {
		step 1 : wff = theorem pm3_2 () |- ( ph -> ( ps -> ( ph /\ ps ) ) ) ;
		step 2 : wff = theorem mp2 (hyp 1, hyp 2, step 1) |- ( ph /\ ps ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *3.37 (Transp) of [WhiteheadRussell] p. 112.  */
	theorem pm3_37 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) -> ch ) -> ( ( ph /\ -. ch ) -> -. ps ) ) ;
	}

	/*  [7-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm3_37 {
		step 1 : wff = theorem pm3_21 () |- ( ps -> ( ph -> ( ph /\ ps ) ) ) ;
		step 2 : wff = theorem imim1d (step 1) |- ( ps -> ( ( ( ph /\ ps ) -> ch ) -> ( ph -> ch ) ) ) ;
		step 3 : wff = theorem com12 (step 2) |- ( ( ( ph /\ ps ) -> ch ) -> ( ps -> ( ph -> ch ) ) ) ;
		step 4 : wff = theorem iman () |- ( ( ph -> ch ) <-> -. ( ph /\ -. ch ) ) ;
		step 5 : wff = theorem syl6ib (step 3, step 4) |- ( ( ( ph /\ ps ) -> ch ) -> ( ps -> -. ( ph /\ -. ch ) ) ) ;
		step 6 : wff = theorem con2d (step 5) |- ( ( ( ph /\ ps ) -> ch ) -> ( ( ph /\ -. ch ) -> -. ps ) ) ;
		qed prop = step 6 ;
	}

	/*  Nested conjunction of antecedents.  */
	theorem pm3_43i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( ph -> ch ) -> ( ph -> ( ps /\ ch ) ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm3_43i {
		step 1 : wff = theorem pm3_2 () |- ( ps -> ( ch -> ( ps /\ ch ) ) ) ;
		step 2 : wff = theorem imim3i (step 1) |- ( ( ph -> ps ) -> ( ( ph -> ch ) -> ( ph -> ( ps /\ ch ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduce conjunction of the consequents of two implications ("join
	       consequents with 'and'").  */
	theorem jca (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ph -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps /\ ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of jca {
		step 1 : wff = theorem jc (hyp 1, hyp 2) |- ( ph -> -. ( ps -> -. ch ) ) ;
		step 2 : wff = definition df-an () |- ( ( ps /\ ch ) <-> -. ( ps -> -. ch ) ) ;
		step 3 : wff = theorem sylibr (step 1, step 2) |- ( ph -> ( ps /\ ch ) ) ;
		qed prop = step 3 ;
	}

	/*  Deduction replacing implication with conjunction.  */
	theorem jcai (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps /\ ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of jcai {
		step 1 : wff = theorem mpd (hyp 1, hyp 2) |- ( ph -> ch ) ;
		step 2 : wff = theorem jca (hyp 1, step 1) |- ( ph -> ( ps /\ ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Inference conjoining a theorem to the left of a consequent.  */
	theorem jctl (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ps ;
		-----------------
		prop : wff = |- ( ph -> ( ps /\ ph ) ) ;
	}

	/*  [31-Dec-1993]  */ 
	proof of jctl {
		step 1 : wff = theorem a1i (hyp 1) |- ( ph -> ps ) ;
		step 2 : wff = theorem id () |- ( ph -> ph ) ;
		step 3 : wff = theorem jca (step 1, step 2) |- ( ph -> ( ps /\ ph ) ) ;
		qed prop = step 3 ;
	}

	/*  Inference conjoining a theorem to the right of a consequent.  */
	theorem jctr (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ps ;
		-----------------
		prop : wff = |- ( ph -> ( ph /\ ps ) ) ;
	}

	/*  [18-Aug-1993]  */ 
	proof of jctr {
		step 1 : wff = theorem id () |- ( ph -> ph ) ;
		step 2 : wff = theorem a1i (hyp 1) |- ( ph -> ps ) ;
		step 3 : wff = theorem jca (step 1, step 2) |- ( ph -> ( ph /\ ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Inference conjoining a theorem to left of consequent in an
	       implication.  */
	theorem jctil (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ch ;
		-----------------
		prop : wff = |- ( ph -> ( ch /\ ps ) ) ;
	}

	/*  [31-Dec-1993]  */ 
	proof of jctil {
		step 1 : wff = theorem a1i (hyp 2) |- ( ph -> ch ) ;
		step 2 : wff = theorem jca (step 1, hyp 1) |- ( ph -> ( ch /\ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Inference conjoining a theorem to right of consequent in an
	       implication.  */
	theorem jctir (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ch ;
		-----------------
		prop : wff = |- ( ph -> ( ps /\ ch ) ) ;
	}

	/*  [31-Dec-1993]  */ 
	proof of jctir {
		step 1 : wff = theorem a1i (hyp 2) |- ( ph -> ch ) ;
		step 2 : wff = theorem jca (hyp 1, step 1) |- ( ph -> ( ps /\ ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Conjoin antecedent to left of consequent.  */
	theorem ancl (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ph -> ( ph /\ ps ) ) ) ;
	}

	/*  [15-Aug-1994]  */ 
	proof of ancl {
		step 1 : wff = theorem pm3_2 () |- ( ph -> ( ps -> ( ph /\ ps ) ) ) ;
		step 2 : wff = theorem a2i (step 1) |- ( ( ph -> ps ) -> ( ph -> ( ph /\ ps ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Conjoin antecedent to right of consequent.  */
	theorem ancr (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ph -> ( ps /\ ph ) ) ) ;
	}

	/*  [15-Aug-1994]  */ 
	proof of ancr {
		step 1 : wff = theorem pm3_21 () |- ( ph -> ( ps -> ( ps /\ ph ) ) ) ;
		step 2 : wff = theorem a2i (step 1) |- ( ( ph -> ps ) -> ( ph -> ( ps /\ ph ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction conjoining antecedent to left of consequent.  */
	theorem ancli (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( ph /\ ps ) ) ;
	}

	/*  [12-Aug-1993]  */ 
	proof of ancli {
		step 1 : wff = theorem id () |- ( ph -> ph ) ;
		step 2 : wff = theorem jca (step 1, hyp 1) |- ( ph -> ( ph /\ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction conjoining antecedent to right of consequent.  */
	theorem ancri (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps /\ ph ) ) ;
	}

	/*  [15-Aug-1994]  */ 
	proof of ancri {
		step 1 : wff = theorem id () |- ( ph -> ph ) ;
		step 2 : wff = theorem jca (hyp 1, step 1) |- ( ph -> ( ps /\ ph ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction conjoining antecedent to left of consequent in nested
	       implication.  */
	theorem ancld (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ps /\ ch ) ) ) ;
	}

	/*  [15-Aug-1994]  */ 
	proof of ancld {
		step 1 : wff = theorem ancl () |- ( ( ps -> ch ) -> ( ps -> ( ps /\ ch ) ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( ps -> ( ps /\ ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction conjoining antecedent to right of consequent in nested
	       implication.  */
	theorem ancrd (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch /\ ps ) ) ) ;
	}

	/*  [15-Aug-1994]  */ 
	proof of ancrd {
		step 1 : wff = theorem ancr () |- ( ( ps -> ch ) -> ( ps -> ( ch /\ ps ) ) ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ( ps -> ( ch /\ ps ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Conjoin antecedent to left of consequent in nested implication.  */
	theorem anc2l (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ps -> ch ) ) -> ( ph -> ( ps -> ( ph /\ ch ) ) ) ) ;
	}

	/*  [10-Aug-1994]  */ 
	proof of anc2l {
		step 1 : wff = theorem pm3_2 () |- ( ph -> ( ch -> ( ph /\ ch ) ) ) ;
		step 2 : wff = theorem imim2d (step 1) |- ( ph -> ( ( ps -> ch ) -> ( ps -> ( ph /\ ch ) ) ) ) ;
		step 3 : wff = theorem a2i (step 2) |- ( ( ph -> ( ps -> ch ) ) -> ( ph -> ( ps -> ( ph /\ ch ) ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Conjoin antecedent to right of consequent in nested implication.  */
	theorem anc2r (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ps -> ch ) ) -> ( ph -> ( ps -> ( ch /\ ph ) ) ) ) ;
	}

	/*  [15-Aug-1994]  */ 
	proof of anc2r {
		step 1 : wff = theorem pm3_21 () |- ( ph -> ( ch -> ( ch /\ ph ) ) ) ;
		step 2 : wff = theorem imim2d (step 1) |- ( ph -> ( ( ps -> ch ) -> ( ps -> ( ch /\ ph ) ) ) ) ;
		step 3 : wff = theorem a2i (step 2) |- ( ( ph -> ( ps -> ch ) ) -> ( ph -> ( ps -> ( ch /\ ph ) ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Deduction conjoining antecedent to left of consequent in nested
	       implication.  */
	theorem anc2li (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ph /\ ch ) ) ) ;
	}

	/*  [10-Aug-1994]  */ 
	proof of anc2li {
		step 1 : wff = theorem anc2l () |- ( ( ph -> ( ps -> ch ) ) -> ( ph -> ( ps -> ( ph /\ ch ) ) ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ph -> ( ps -> ( ph /\ ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction conjoining antecedent to right of consequent in nested
	       implication.  */
	theorem anc2ri (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch /\ ph ) ) ) ;
	}

	/*  [15-Aug-1994]  */ 
	proof of anc2ri {
		step 1 : wff = theorem anc2r () |- ( ( ph -> ( ps -> ch ) ) -> ( ph -> ( ps -> ( ch /\ ph ) ) ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ph -> ( ps -> ( ch /\ ph ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Conjunction in terms of disjunction (DeMorgan's law).  Theorem *4.5 of
	     [WhiteheadRussell] p. 120.  */
	theorem anor (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps ) <-> -. ( -. ph \/ -. ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of anor {
		step 1 : wff = definition df-an () |- ( ( ph /\ ps ) <-> -. ( ph -> -. ps ) ) ;
		step 2 : wff = theorem pm4_62 () |- ( ( ph -> -. ps ) <-> ( -. ph \/ -. ps ) ) ;
		step 3 : wff = theorem negbii (step 2) |- ( -. ( ph -> -. ps ) <-> -. ( -. ph \/ -. ps ) ) ;
		step 4 : wff = theorem bitr (step 1, step 3) |- ( ( ph /\ ps ) <-> -. ( -. ph \/ -. ps ) ) ;
		qed prop = step 4 ;
	}

	/*  Negated conjunction in terms of disjunction (DeMorgan's law).  Theorem
	     *4.51 of [WhiteheadRussell] p. 120.  */
	theorem ianor (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph /\ ps ) <-> ( -. ph \/ -. ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of ianor {
		step 1 : wff = theorem anor () |- ( ( ph /\ ps ) <-> -. ( -. ph \/ -. ps ) ) ;
		step 2 : wff = theorem negbii (step 1) |- ( -. ( ph /\ ps ) <-> -. -. ( -. ph \/ -. ps ) ) ;
		step 3 : wff = theorem pm4_13 () |- ( ( -. ph \/ -. ps ) <-> -. -. ( -. ph \/ -. ps ) ) ;
		step 4 : wff = theorem bitr4 (step 2, step 3) |- ( -. ( ph /\ ps ) <-> ( -. ph \/ -. ps ) ) ;
		qed prop = step 4 ;
	}

	/*  Negated disjunction in terms of conjunction (DeMorgan's law).  Compare
	     Theorem *4.56 of [WhiteheadRussell] p. 120.  */
	theorem ioran (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph \/ ps ) <-> ( -. ph /\ -. ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of ioran {
		step 1 : wff = theorem pm4_13 () |- ( ph <-> -. -. ph ) ;
		step 2 : wff = theorem pm4_13 () |- ( ps <-> -. -. ps ) ;
		step 3 : wff = theorem orbi12i (step 1, step 2) |- ( ( ph \/ ps ) <-> ( -. -. ph \/ -. -. ps ) ) ;
		step 4 : wff = theorem negbii (step 3) |- ( -. ( ph \/ ps ) <-> -. ( -. -. ph \/ -. -. ps ) ) ;
		step 5 : wff = theorem anor () |- ( ( -. ph /\ -. ps ) <-> -. ( -. -. ph \/ -. -. ps ) ) ;
		step 6 : wff = theorem bitr4 (step 4, step 5) |- ( -. ( ph \/ ps ) <-> ( -. ph /\ -. ps ) ) ;
		qed prop = step 6 ;
	}

	/*  Theorem *4.52 of [WhiteheadRussell] p. 120.  */
	theorem pm4_52 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph /\ -. ps ) <-> -. ( -. ph \/ ps ) ) ;
	}

	/*  [11-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_52 {
		step 1 : wff = theorem anor () |- ( ( ph /\ -. ps ) <-> -. ( -. ph \/ -. -. ps ) ) ;
		step 2 : wff = theorem pm4_13 () |- ( ps <-> -. -. ps ) ;
		step 3 : wff = theorem orbi2i (step 2) |- ( ( -. ph \/ ps ) <-> ( -. ph \/ -. -. ps ) ) ;
		step 4 : wff = theorem negbii (step 3) |- ( -. ( -. ph \/ ps ) <-> -. ( -. ph \/ -. -. ps ) ) ;
		step 5 : wff = theorem bitr4 (step 1, step 4) |- ( ( ph /\ -. ps ) <-> -. ( -. ph \/ ps ) ) ;
		qed prop = step 5 ;
	}

	/*  Theorem *4.53 of [WhiteheadRussell] p. 120.  */
	theorem pm4_53 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph /\ -. ps ) <-> ( -. ph \/ ps ) ) ;
	}

	/*  [11-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_53 {
		step 1 : wff = theorem pm4_52 () |- ( ( ph /\ -. ps ) <-> -. ( -. ph \/ ps ) ) ;
		step 2 : wff = theorem con2bii (step 1) |- ( ( -. ph \/ ps ) <-> -. ( ph /\ -. ps ) ) ;
		step 3 : wff = theorem bicomi (step 2) |- ( -. ( ph /\ -. ps ) <-> ( -. ph \/ ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *4.54 of [WhiteheadRussell] p. 120.  */
	theorem pm4_54 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( -. ph /\ ps ) <-> -. ( ph \/ -. ps ) ) ;
	}

	/*  [11-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_54 {
		step 1 : wff = theorem anor () |- ( ( -. ph /\ ps ) <-> -. ( -. -. ph \/ -. ps ) ) ;
		step 2 : wff = theorem pm4_13 () |- ( ph <-> -. -. ph ) ;
		step 3 : wff = theorem orbi1i (step 2) |- ( ( ph \/ -. ps ) <-> ( -. -. ph \/ -. ps ) ) ;
		step 4 : wff = theorem negbii (step 3) |- ( -. ( ph \/ -. ps ) <-> -. ( -. -. ph \/ -. ps ) ) ;
		step 5 : wff = theorem bitr4 (step 1, step 4) |- ( ( -. ph /\ ps ) <-> -. ( ph \/ -. ps ) ) ;
		qed prop = step 5 ;
	}

	/*  Theorem *4.55 of [WhiteheadRussell] p. 120.  */
	theorem pm4_55 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( -. ph /\ ps ) <-> ( ph \/ -. ps ) ) ;
	}

	/*  [11-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_55 {
		step 1 : wff = theorem pm4_54 () |- ( ( -. ph /\ ps ) <-> -. ( ph \/ -. ps ) ) ;
		step 2 : wff = theorem con2bii (step 1) |- ( ( ph \/ -. ps ) <-> -. ( -. ph /\ ps ) ) ;
		step 3 : wff = theorem bicomi (step 2) |- ( -. ( -. ph /\ ps ) <-> ( ph \/ -. ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *4.56 of [WhiteheadRussell] p. 120.  */
	theorem pm4_56 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( -. ph /\ -. ps ) <-> -. ( ph \/ ps ) ) ;
	}

	/*  [11-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_56 {
		step 1 : wff = theorem ioran () |- ( -. ( ph \/ ps ) <-> ( -. ph /\ -. ps ) ) ;
		step 2 : wff = theorem bicomi (step 1) |- ( ( -. ph /\ -. ps ) <-> -. ( ph \/ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Disjunction in terms of conjunction (DeMorgan's law).  Compare Theorem
	     *4.57 of [WhiteheadRussell] p. 120.  */
	theorem oran (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph \/ ps ) <-> -. ( -. ph /\ -. ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of oran {
		step 1 : wff = theorem pm4_13 () |- ( ( ph \/ ps ) <-> -. -. ( ph \/ ps ) ) ;
		step 2 : wff = theorem ioran () |- ( -. ( ph \/ ps ) <-> ( -. ph /\ -. ps ) ) ;
		step 3 : wff = theorem negbii (step 2) |- ( -. -. ( ph \/ ps ) <-> -. ( -. ph /\ -. ps ) ) ;
		step 4 : wff = theorem bitr (step 1, step 3) |- ( ( ph \/ ps ) <-> -. ( -. ph /\ -. ps ) ) ;
		qed prop = step 4 ;
	}

	/*  Theorem *4.57 of [WhiteheadRussell] p. 120.  */
	theorem pm4_57 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( -. ph /\ -. ps ) <-> ( ph \/ ps ) ) ;
	}

	/*  [11-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_57 {
		step 1 : wff = theorem oran () |- ( ( ph \/ ps ) <-> -. ( -. ph /\ -. ps ) ) ;
		step 2 : wff = theorem bicomi (step 1) |- ( -. ( -. ph /\ -. ps ) <-> ( ph \/ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *3.1 of [WhiteheadRussell] p. 111.  */
	theorem pm3_1 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps ) -> -. ( -. ph \/ -. ps ) ) ;
	}

	/*  [21-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm3_1 {
		step 1 : wff = theorem anor () |- ( ( ph /\ ps ) <-> -. ( -. ph \/ -. ps ) ) ;
		step 2 : wff = theorem biimp (step 1) |- ( ( ph /\ ps ) -> -. ( -. ph \/ -. ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *3.11 of [WhiteheadRussell] p. 111.  */
	theorem pm3_11 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( -. ph \/ -. ps ) -> ( ph /\ ps ) ) ;
	}

	/*  [25-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm3_11 {
		step 1 : wff = theorem anor () |- ( ( ph /\ ps ) <-> -. ( -. ph \/ -. ps ) ) ;
		step 2 : wff = theorem biimpr (step 1) |- ( -. ( -. ph \/ -. ps ) -> ( ph /\ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *3.12 of [WhiteheadRussell] p. 111.  */
	theorem pm3_12 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( -. ph \/ -. ps ) \/ ( ph /\ ps ) ) ;
	}

	/*  [25-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm3_12 {
		step 1 : wff = theorem pm3_11 () |- ( -. ( -. ph \/ -. ps ) -> ( ph /\ ps ) ) ;
		step 2 : wff = theorem orri (step 1) |- ( ( -. ph \/ -. ps ) \/ ( ph /\ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *3.13 of [WhiteheadRussell] p. 111.  */
	theorem pm3_13 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph /\ ps ) -> ( -. ph \/ -. ps ) ) ;
	}

	/*  [25-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm3_13 {
		step 1 : wff = theorem pm3_11 () |- ( -. ( -. ph \/ -. ps ) -> ( ph /\ ps ) ) ;
		step 2 : wff = theorem con1i (step 1) |- ( -. ( ph /\ ps ) -> ( -. ph \/ -. ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *3.14 of [WhiteheadRussell] p. 111.  */
	theorem pm3_14 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( -. ph \/ -. ps ) -> -. ( ph /\ ps ) ) ;
	}

	/*  [25-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm3_14 {
		step 1 : wff = theorem pm3_1 () |- ( ( ph /\ ps ) -> -. ( -. ph \/ -. ps ) ) ;
		step 2 : wff = theorem con2i (step 1) |- ( ( -. ph \/ -. ps ) -> -. ( ph /\ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Elimination of a conjunct.  Theorem *3.26 (Simp) of [WhiteheadRussell]
	     p. 112.  */
	theorem pm3_26 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps ) -> ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm3_26 {
		step 1 : wff = definition df-an () |- ( ( ph /\ ps ) <-> -. ( ph -> -. ps ) ) ;
		step 2 : wff = theorem pm3_26im () |- ( -. ( ph -> -. ps ) -> ph ) ;
		step 3 : wff = theorem sylbi (step 1, step 2) |- ( ( ph /\ ps ) -> ph ) ;
		qed prop = step 3 ;
	}

	/*  Inference eliminating a conjunct.  */
	theorem pm3_26i (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph /\ ps ) ;
		-----------------
		prop : wff = |- ph ;
	}

	/*  [15-Jun-1994]  */ 
	proof of pm3_26i {
		step 1 : wff = theorem pm3_26 () |- ( ( ph /\ ps ) -> ph ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ph ;
		qed prop = step 2 ;
	}

	/*  Deduction eliminating a conjunct.  */
	theorem pm3_26d (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps /\ ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ps ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm3_26d {
		step 1 : wff = theorem pm3_26 () |- ( ( ps /\ ch ) -> ps ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Deduction eliminating a conjunct.  */
	theorem pm3_26bi (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ( ps /\ ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ps ) ;
	}

	/*  [27-May-1998]  */ 
	proof of pm3_26bi {
		step 1 : wff = theorem biimp (hyp 1) |- ( ph -> ( ps /\ ch ) ) ;
		step 2 : wff = theorem pm3_26d (step 1) |- ( ph -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Elimination of a conjunct.  Theorem *3.27 (Simp) of [WhiteheadRussell]
	     p. 112.  */
	theorem pm3_27 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps ) -> ps ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm3_27 {
		step 1 : wff = definition df-an () |- ( ( ph /\ ps ) <-> -. ( ph -> -. ps ) ) ;
		step 2 : wff = theorem pm3_27im () |- ( -. ( ph -> -. ps ) -> ps ) ;
		step 3 : wff = theorem sylbi (step 1, step 2) |- ( ( ph /\ ps ) -> ps ) ;
		qed prop = step 3 ;
	}

	/*  Inference eliminating a conjunct.  */
	theorem pm3_27i (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph /\ ps ) ;
		-----------------
		prop : wff = |- ps ;
	}

	/*  [15-Jun-1994]  */ 
	proof of pm3_27i {
		step 1 : wff = theorem pm3_27 () |- ( ( ph /\ ps ) -> ps ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ps ;
		qed prop = step 2 ;
	}

	/*  Deduction eliminating a conjunct.  */
	theorem pm3_27d (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps /\ ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm3_27d {
		step 1 : wff = theorem pm3_27 () |- ( ( ps /\ ch ) -> ch ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Deduction eliminating a conjunct.  */
	theorem pm3_27bi (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ( ps /\ ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [27-May-1998]  */ 
	proof of pm3_27bi {
		step 1 : wff = theorem biimp (hyp 1) |- ( ph -> ( ps /\ ch ) ) ;
		step 2 : wff = theorem pm3_27d (step 1) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *3.41 of [WhiteheadRussell] p. 113.  */
	theorem pm3_41 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ch ) -> ( ( ph /\ ps ) -> ch ) ) ;
	}

	/*  [21-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm3_41 {
		step 1 : wff = theorem pm3_26 () |- ( ( ph /\ ps ) -> ph ) ;
		step 2 : wff = theorem imim1i (step 1) |- ( ( ph -> ch ) -> ( ( ph /\ ps ) -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *3.42 of [WhiteheadRussell] p. 113.  */
	theorem pm3_42 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ps -> ch ) -> ( ( ph /\ ps ) -> ch ) ) ;
	}

	/*  [27-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm3_42 {
		step 1 : wff = theorem pm3_27 () |- ( ( ph /\ ps ) -> ps ) ;
		step 2 : wff = theorem imim1i (step 1) |- ( ( ps -> ch ) -> ( ( ph /\ ps ) -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Conjoin antecedent to left of consequent.  Theorem *4.7 of
	     [WhiteheadRussell] p. 120.  */
	theorem anclb (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) <-> ( ph -> ( ph /\ ps ) ) ) ;
	}

	/*  [25-Jul-1999]  */ 
	proof of anclb {
		step 1 : wff = theorem ancl () |- ( ( ph -> ps ) -> ( ph -> ( ph /\ ps ) ) ) ;
		step 2 : wff = theorem pm3_27 () |- ( ( ph /\ ps ) -> ps ) ;
		step 3 : wff = theorem imim2i (step 2) |- ( ( ph -> ( ph /\ ps ) ) -> ( ph -> ps ) ) ;
		step 4 : wff = theorem impbi (step 1, step 3) |- ( ( ph -> ps ) <-> ( ph -> ( ph /\ ps ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Conjoin antecedent to right of consequent.  */
	theorem ancrb (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) <-> ( ph -> ( ps /\ ph ) ) ) ;
	}

	/*  [25-Jul-1999]  */ 
	proof of ancrb {
		step 1 : wff = theorem ancr () |- ( ( ph -> ps ) -> ( ph -> ( ps /\ ph ) ) ) ;
		step 2 : wff = theorem pm3_26 () |- ( ( ps /\ ph ) -> ps ) ;
		step 3 : wff = theorem imim2i (step 2) |- ( ( ph -> ( ps /\ ph ) ) -> ( ph -> ps ) ) ;
		step 4 : wff = theorem impbi (step 1, step 3) |- ( ( ph -> ps ) <-> ( ph -> ( ps /\ ph ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Conjunction implies implication.  Theorem *3.4 of [WhiteheadRussell]
	     p. 113.  */
	theorem pm3_4 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps ) -> ( ph -> ps ) ) ;
	}

	/*  [31-Jul-1995]  */ 
	proof of pm3_4 {
		step 1 : wff = theorem pm3_27 () |- ( ( ph /\ ps ) -> ps ) ;
		step 2 : wff = theorem a1d (step 1) |- ( ( ph /\ ps ) -> ( ph -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Conjunction with implication.  Compare Theorem *4.45 of
	     [WhiteheadRussell] p. 119.  */
	theorem pm4_45im (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph <-> ( ph /\ ( ps -> ph ) ) ) ;
	}

	/*  [17-May-1998]  */ 
	proof of pm4_45im {
		step 1 : wff = axiom ax-1 () |- ( ph -> ( ps -> ph ) ) ;
		step 2 : wff = theorem ancli (step 1) |- ( ph -> ( ph /\ ( ps -> ph ) ) ) ;
		step 3 : wff = theorem pm3_26 () |- ( ( ph /\ ( ps -> ph ) ) -> ph ) ;
		step 4 : wff = theorem impbi (step 2, step 3) |- ( ph <-> ( ph /\ ( ps -> ph ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Conjoin antecedents and consequents of two premises.  */
	theorem anim12i (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ch -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ch ) -> ( ps /\ th ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of anim12i {
		step 1 : wff = theorem pm3_26 () |- ( ( ph /\ ch ) -> ph ) ;
		step 2 : wff = theorem syl (step 1, hyp 1) |- ( ( ph /\ ch ) -> ps ) ;
		step 3 : wff = theorem pm3_27 () |- ( ( ph /\ ch ) -> ch ) ;
		step 4 : wff = theorem syl (step 3, hyp 2) |- ( ( ph /\ ch ) -> th ) ;
		step 5 : wff = theorem jca (step 2, step 4) |- ( ( ph /\ ch ) -> ( ps /\ th ) ) ;
		qed prop = step 5 ;
	}

	/*  Introduce conjunct to both sides of an implication.  */
	theorem anim1i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ch ) -> ( ps /\ ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of anim1i {
		step 1 : wff = theorem id () |- ( ch -> ch ) ;
		step 2 : wff = theorem anim12i (hyp 1, step 1) |- ( ( ph /\ ch ) -> ( ps /\ ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Introduce conjunct to both sides of an implication.  */
	theorem anim2i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ( ch /\ ph ) -> ( ch /\ ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of anim2i {
		step 1 : wff = theorem id () |- ( ch -> ch ) ;
		step 2 : wff = theorem anim12i (step 1, hyp 1) |- ( ( ch /\ ph ) -> ( ch /\ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Disjoin antecedents and consequents of two premises.  */
	theorem orim12i (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ch -> th ) ;
		-----------------
		prop : wff = |- ( ( ph \/ ch ) -> ( ps \/ th ) ) ;
	}

	/*  [6-Jun-1994]  */ 
	proof of orim12i {
		step 1 : wff = theorem con3i (hyp 1) |- ( -. ps -> -. ph ) ;
		step 2 : wff = theorem con3i (hyp 2) |- ( -. th -> -. ch ) ;
		step 3 : wff = theorem anim12i (step 1, step 2) |- ( ( -. ps /\ -. th ) -> ( -. ph /\ -. ch ) ) ;
		step 4 : wff = theorem con3i (step 3) |- ( -. ( -. ph /\ -. ch ) -> -. ( -. ps /\ -. th ) ) ;
		step 5 : wff = theorem oran () |- ( ( ph \/ ch ) <-> -. ( -. ph /\ -. ch ) ) ;
		step 6 : wff = theorem oran () |- ( ( ps \/ th ) <-> -. ( -. ps /\ -. th ) ) ;
		step 7 : wff = theorem _3imtr4 (step 4, step 5, step 6) |- ( ( ph \/ ch ) -> ( ps \/ th ) ) ;
		qed prop = step 7 ;
	}

	/*  Introduce disjunct to both sides of an implication.  */
	theorem orim1i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ( ph \/ ch ) -> ( ps \/ ch ) ) ;
	}

	/*  [6-Jun-1994]  */ 
	proof of orim1i {
		step 1 : wff = theorem id () |- ( ch -> ch ) ;
		step 2 : wff = theorem orim12i (hyp 1, step 1) |- ( ( ph \/ ch ) -> ( ps \/ ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Introduce disjunct to both sides of an implication.  */
	theorem orim2i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ( ch \/ ph ) -> ( ch \/ ps ) ) ;
	}

	/*  [6-Jun-1994]  */ 
	proof of orim2i {
		step 1 : wff = theorem id () |- ( ch -> ch ) ;
		step 2 : wff = theorem orim12i (step 1, hyp 1) |- ( ( ch \/ ph ) -> ( ch \/ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.3 of [WhiteheadRussell] p. 104.  */
	theorem pm2_3 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph \/ ( ps \/ ch ) ) -> ( ph \/ ( ch \/ ps ) ) ) ;
	}

	/*  [2-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_3 {
		step 1 : wff = theorem pm1_4 () |- ( ( ps \/ ch ) -> ( ch \/ ps ) ) ;
		step 2 : wff = theorem orim2i (step 1) |- ( ( ph \/ ( ps \/ ch ) ) -> ( ph \/ ( ch \/ ps ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Disjunction of antecedents.  Compare Theorem *3.44 of
	     [WhiteheadRussell] p. 113.  */
	theorem jao (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( ch -> ps ) -> ( ( ph \/ ch ) -> ps ) ) ) ;
	}

	/*  [5-Apr-1994]  */ 
	proof of jao {
		step 1 : wff = theorem con3 () |- ( ( ph -> ps ) -> ( -. ps -> -. ph ) ) ;
		step 2 : wff = theorem pm3_43i () |- ( ( -. ps -> -. ph ) -> ( ( -. ps -> -. ch ) -> ( -. ps -> ( -. ph /\ -. ch ) ) ) ) ;
		step 3 : wff = theorem con1 () |- ( ( -. ps -> ( -. ph /\ -. ch ) ) -> ( -. ( -. ph /\ -. ch ) -> ps ) ) ;
		step 4 : wff = theorem syl6 (step 2, step 3) |- ( ( -. ps -> -. ph ) -> ( ( -. ps -> -. ch ) -> ( -. ( -. ph /\ -. ch ) -> ps ) ) ) ;
		step 5 : wff = theorem oran () |- ( ( ph \/ ch ) <-> -. ( -. ph /\ -. ch ) ) ;
		step 6 : wff = theorem syl7ib (step 4, step 5) |- ( ( -. ps -> -. ph ) -> ( ( -. ps -> -. ch ) -> ( ( ph \/ ch ) -> ps ) ) ) ;
		step 7 : wff = theorem con3 () |- ( ( ch -> ps ) -> ( -. ps -> -. ch ) ) ;
		step 8 : wff = theorem syl5 (step 6, step 7) |- ( ( -. ps -> -. ph ) -> ( ( ch -> ps ) -> ( ( ph \/ ch ) -> ps ) ) ) ;
		step 9 : wff = theorem syl (step 1, step 8) |- ( ( ph -> ps ) -> ( ( ch -> ps ) -> ( ( ph \/ ch ) -> ps ) ) ) ;
		qed prop = step 9 ;
	}

	/*  Inference disjoining the antecedents of two implications.  */
	theorem jaoi (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ch -> ps ) ;
		-----------------
		prop : wff = |- ( ( ph \/ ch ) -> ps ) ;
	}

	/*  [5-Apr-1994]  */ 
	proof of jaoi {
		step 1 : wff = theorem jao () |- ( ( ph -> ps ) -> ( ( ch -> ps ) -> ( ( ph \/ ch ) -> ps ) ) ) ;
		step 2 : wff = theorem mp2 (hyp 1, hyp 2, step 1) |- ( ( ph \/ ch ) -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.41 of [WhiteheadRussell] p. 106.  */
	theorem pm2_41 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ps \/ ( ph \/ ps ) ) -> ( ph \/ ps ) ) ;
	}

	/*  [2-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_41 {
		step 1 : wff = theorem olc () |- ( ps -> ( ph \/ ps ) ) ;
		step 2 : wff = theorem id () |- ( ( ph \/ ps ) -> ( ph \/ ps ) ) ;
		step 3 : wff = theorem jaoi (step 1, step 2) |- ( ( ps \/ ( ph \/ ps ) ) -> ( ph \/ ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.42 of [WhiteheadRussell] p. 106.  */
	theorem pm2_42 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( -. ph \/ ( ph -> ps ) ) -> ( ph -> ps ) ) ;
	}

	/*  [2-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_42 {
		step 1 : wff = theorem pm2_21 () |- ( -. ph -> ( ph -> ps ) ) ;
		step 2 : wff = theorem id () |- ( ( ph -> ps ) -> ( ph -> ps ) ) ;
		step 3 : wff = theorem jaoi (step 1, step 2) |- ( ( -. ph \/ ( ph -> ps ) ) -> ( ph -> ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.4 of [WhiteheadRussell] p. 106.  */
	theorem pm2_4 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph \/ ( ph \/ ps ) ) -> ( ph \/ ps ) ) ;
	}

	/*  [2-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_4 {
		step 1 : wff = theorem orc () |- ( ph -> ( ph \/ ps ) ) ;
		step 2 : wff = theorem id () |- ( ( ph \/ ps ) -> ( ph \/ ps ) ) ;
		step 3 : wff = theorem jaoi (step 1, step 2) |- ( ( ph \/ ( ph \/ ps ) ) -> ( ph \/ ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *4.44 of [WhiteheadRussell] p. 119.  */
	theorem pm4_44 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph <-> ( ph \/ ( ph /\ ps ) ) ) ;
	}

	/*  [2-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_44 {
		step 1 : wff = theorem orc () |- ( ph -> ( ph \/ ( ph /\ ps ) ) ) ;
		step 2 : wff = theorem id () |- ( ph -> ph ) ;
		step 3 : wff = theorem pm3_26 () |- ( ( ph /\ ps ) -> ph ) ;
		step 4 : wff = theorem jaoi (step 2, step 3) |- ( ( ph \/ ( ph /\ ps ) ) -> ph ) ;
		step 5 : wff = theorem impbi (step 1, step 4) |- ( ph <-> ( ph \/ ( ph /\ ps ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Theorem *5.63 of [WhiteheadRussell] p. 125.  */
	theorem pm5_63 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph \/ ps ) <-> ( ph \/ ( -. ph /\ ps ) ) ) ;
	}

	/*  [2-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_63 {
		step 1 : wff = theorem pm2_53 () |- ( ( ph \/ ps ) -> ( -. ph -> ps ) ) ;
		step 2 : wff = theorem ancld (step 1) |- ( ( ph \/ ps ) -> ( -. ph -> ( -. ph /\ ps ) ) ) ;
		step 3 : wff = theorem orrd (step 2) |- ( ( ph \/ ps ) -> ( ph \/ ( -. ph /\ ps ) ) ) ;
		step 4 : wff = theorem pm2_24 () |- ( ph -> ( -. ph -> ps ) ) ;
		step 5 : wff = theorem pm3_4 () |- ( ( -. ph /\ ps ) -> ( -. ph -> ps ) ) ;
		step 6 : wff = theorem jaoi (step 4, step 5) |- ( ( ph \/ ( -. ph /\ ps ) ) -> ( -. ph -> ps ) ) ;
		step 7 : wff = theorem orrd (step 6) |- ( ( ph \/ ( -. ph /\ ps ) ) -> ( ph \/ ps ) ) ;
		step 8 : wff = theorem impbi (step 3, step 7) |- ( ( ph \/ ps ) <-> ( ph \/ ( -. ph /\ ps ) ) ) ;
		qed prop = step 8 ;
	}

	/*  Import-export theorem.  Part of Theorem *4.87 of [WhiteheadRussell]
	     p. 122.  */
	theorem impexp (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) -> ch ) <-> ( ph -> ( ps -> ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of impexp {
		step 1 : wff = definition df-an () |- ( ( ph /\ ps ) <-> -. ( ph -> -. ps ) ) ;
		step 2 : wff = theorem imbi1i (step 1) |- ( ( ( ph /\ ps ) -> ch ) <-> ( -. ( ph -> -. ps ) -> ch ) ) ;
		step 3 : wff = theorem expt () |- ( ( -. ( ph -> -. ps ) -> ch ) -> ( ph -> ( ps -> ch ) ) ) ;
		step 4 : wff = theorem impt () |- ( ( ph -> ( ps -> ch ) ) -> ( -. ( ph -> -. ps ) -> ch ) ) ;
		step 5 : wff = theorem impbi (step 3, step 4) |- ( ( -. ( ph -> -. ps ) -> ch ) <-> ( ph -> ( ps -> ch ) ) ) ;
		step 6 : wff = theorem bitr (step 2, step 5) |- ( ( ( ph /\ ps ) -> ch ) <-> ( ph -> ( ps -> ch ) ) ) ;
		qed prop = step 6 ;
	}

	/*  Theorem *3.3 (Exp) of [WhiteheadRussell] p. 112.  */
	theorem pm3_3 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) -> ch ) -> ( ph -> ( ps -> ch ) ) ) ;
	}

	/*  [10-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm3_3 {
		step 1 : wff = theorem impexp () |- ( ( ( ph /\ ps ) -> ch ) <-> ( ph -> ( ps -> ch ) ) ) ;
		step 2 : wff = theorem biimp (step 1) |- ( ( ( ph /\ ps ) -> ch ) -> ( ph -> ( ps -> ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *3.31 (Imp) of [WhiteheadRussell] p. 112.  */
	theorem pm3_31 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ps -> ch ) ) -> ( ( ph /\ ps ) -> ch ) ) ;
	}

	/*  [14-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm3_31 {
		step 1 : wff = theorem impexp () |- ( ( ( ph /\ ps ) -> ch ) <-> ( ph -> ( ps -> ch ) ) ) ;
		step 2 : wff = theorem biimpr (step 1) |- ( ( ph -> ( ps -> ch ) ) -> ( ( ph /\ ps ) -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Importation inference.  (The proof was shortened by Eric Schmidt,
	       22-Dec-2006.)  */
	theorem imp (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [22-Dec-2006]  */ /*  [5-Aug-1993]  */ 
	proof of imp {
		step 1 : wff = theorem impexp () |- ( ( ( ph /\ ps ) -> ch ) <-> ( ph -> ( ps -> ch ) ) ) ;
		step 2 : wff = theorem mpbir (hyp 1, step 1) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Importation inference with commuted antecedents.  */
	theorem impcom (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ps /\ ph ) -> ch ) ;
	}

	/*  [26-May-2005]  */ /*  [25-May-2005]  */ 
	proof of impcom {
		step 1 : wff = theorem com12 (hyp 1) |- ( ps -> ( ph -> ch ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ps /\ ph ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *4.14 of [WhiteheadRussell] p. 117.  */
	theorem pm4_14 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) -> ch ) <-> ( ( ph /\ -. ch ) -> -. ps ) ) ;
	}

	/*  [11-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_14 {
		step 1 : wff = theorem impexp () |- ( ( ( ph /\ ps ) -> ch ) <-> ( ph -> ( ps -> ch ) ) ) ;
		step 2 : wff = theorem bi2_04 () |- ( ( ph -> ( ps -> ch ) ) <-> ( ps -> ( ph -> ch ) ) ) ;
		step 3 : wff = theorem bitr (step 1, step 2) |- ( ( ( ph /\ ps ) -> ch ) <-> ( ps -> ( ph -> ch ) ) ) ;
		step 4 : wff = theorem iman () |- ( ( ph -> ch ) <-> -. ( ph /\ -. ch ) ) ;
		step 5 : wff = theorem imbi2i (step 4) |- ( ( ps -> ( ph -> ch ) ) <-> ( ps -> -. ( ph /\ -. ch ) ) ) ;
		step 6 : wff = theorem bi2_03 () |- ( ( ps -> -. ( ph /\ -. ch ) ) <-> ( ( ph /\ -. ch ) -> -. ps ) ) ;
		step 7 : wff = theorem _3bitr (step 3, step 5, step 6) |- ( ( ( ph /\ ps ) -> ch ) <-> ( ( ph /\ -. ch ) -> -. ps ) ) ;
		qed prop = step 7 ;
	}

	/*  Theorem *4.15 of [WhiteheadRussell] p. 117.  */
	theorem pm4_15 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) -> -. ch ) <-> ( ( ps /\ ch ) -> -. ph ) ) ;
	}

	/*  [11-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_15 {
		step 1 : wff = theorem impexp () |- ( ( ( ph /\ ps ) -> -. ch ) <-> ( ph -> ( ps -> -. ch ) ) ) ;
		step 2 : wff = theorem imnan () |- ( ( ps -> -. ch ) <-> -. ( ps /\ ch ) ) ;
		step 3 : wff = theorem imbi2i (step 2) |- ( ( ph -> ( ps -> -. ch ) ) <-> ( ph -> -. ( ps /\ ch ) ) ) ;
		step 4 : wff = theorem bi2_03 () |- ( ( ph -> -. ( ps /\ ch ) ) <-> ( ( ps /\ ch ) -> -. ph ) ) ;
		step 5 : wff = theorem _3bitr (step 1, step 3, step 4) |- ( ( ( ph /\ ps ) -> -. ch ) <-> ( ( ps /\ ch ) -> -. ph ) ) ;
		qed prop = step 5 ;
	}

	/*  Theorem *4.78 of [WhiteheadRussell] p. 121.  */
	theorem pm4_78 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) \/ ( ph -> ch ) ) <-> ( ph -> ( ps \/ ch ) ) ) ;
	}

	/*  [10-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_78 {
		step 1 : wff = theorem impexp () |- ( ( ( ph /\ -. ps ) -> ( ph -> ch ) ) <-> ( ph -> ( -. ps -> ( ph -> ch ) ) ) ) ;
		step 2 : wff = theorem annim () |- ( ( ph /\ -. ps ) <-> -. ( ph -> ps ) ) ;
		step 3 : wff = theorem imbi1i (step 2) |- ( ( ( ph /\ -. ps ) -> ( ph -> ch ) ) <-> ( -. ( ph -> ps ) -> ( ph -> ch ) ) ) ;
		step 4 : wff = theorem bi2_04 () |- ( ( -. ps -> ( ph -> ch ) ) <-> ( ph -> ( -. ps -> ch ) ) ) ;
		step 5 : wff = theorem imbi2i (step 4) |- ( ( ph -> ( -. ps -> ( ph -> ch ) ) ) <-> ( ph -> ( ph -> ( -. ps -> ch ) ) ) ) ;
		step 6 : wff = theorem pm5_4 () |- ( ( ph -> ( ph -> ( -. ps -> ch ) ) ) <-> ( ph -> ( -. ps -> ch ) ) ) ;
		step 7 : wff = theorem bitr (step 5, step 6) |- ( ( ph -> ( -. ps -> ( ph -> ch ) ) ) <-> ( ph -> ( -. ps -> ch ) ) ) ;
		step 8 : wff = theorem _3bitr3 (step 1, step 3, step 7) |- ( ( -. ( ph -> ps ) -> ( ph -> ch ) ) <-> ( ph -> ( -. ps -> ch ) ) ) ;
		step 9 : wff = definition df-or () |- ( ( ( ph -> ps ) \/ ( ph -> ch ) ) <-> ( -. ( ph -> ps ) -> ( ph -> ch ) ) ) ;
		step 10 : wff = definition df-or () |- ( ( ps \/ ch ) <-> ( -. ps -> ch ) ) ;
		step 11 : wff = theorem imbi2i (step 10) |- ( ( ph -> ( ps \/ ch ) ) <-> ( ph -> ( -. ps -> ch ) ) ) ;
		step 12 : wff = theorem _3bitr4 (step 8, step 9, step 11) |- ( ( ( ph -> ps ) \/ ( ph -> ch ) ) <-> ( ph -> ( ps \/ ch ) ) ) ;
		qed prop = step 12 ;
	}

	/*  Theorem *4.79 of [WhiteheadRussell] p. 121.  */
	theorem pm4_79 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ps -> ph ) \/ ( ch -> ph ) ) <-> ( ( ps /\ ch ) -> ph ) ) ;
	}

	/*  [14-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_79 {
		step 1 : wff = theorem pm4_78 () |- ( ( ( -. ph -> -. ps ) \/ ( -. ph -> -. ch ) ) <-> ( -. ph -> ( -. ps \/ -. ch ) ) ) ;
		step 2 : wff = theorem ianor () |- ( -. ( ps /\ ch ) <-> ( -. ps \/ -. ch ) ) ;
		step 3 : wff = theorem imbi2i (step 2) |- ( ( -. ph -> -. ( ps /\ ch ) ) <-> ( -. ph -> ( -. ps \/ -. ch ) ) ) ;
		step 4 : wff = theorem bitr4 (step 1, step 3) |- ( ( ( -. ph -> -. ps ) \/ ( -. ph -> -. ch ) ) <-> ( -. ph -> -. ( ps /\ ch ) ) ) ;
		step 5 : wff = theorem pm4_1 () |- ( ( ps -> ph ) <-> ( -. ph -> -. ps ) ) ;
		step 6 : wff = theorem pm4_1 () |- ( ( ch -> ph ) <-> ( -. ph -> -. ch ) ) ;
		step 7 : wff = theorem orbi12i (step 5, step 6) |- ( ( ( ps -> ph ) \/ ( ch -> ph ) ) <-> ( ( -. ph -> -. ps ) \/ ( -. ph -> -. ch ) ) ) ;
		step 8 : wff = theorem pm4_1 () |- ( ( ( ps /\ ch ) -> ph ) <-> ( -. ph -> -. ( ps /\ ch ) ) ) ;
		step 9 : wff = theorem _3bitr4 (step 4, step 7, step 8) |- ( ( ( ps -> ph ) \/ ( ch -> ph ) ) <-> ( ( ps /\ ch ) -> ph ) ) ;
		qed prop = step 9 ;
	}

	/*  Theorem *4.87 of [WhiteheadRussell] p. 122.  (The proof was shortened by
	     Eric Schmidt, 26-Oct-2006.)  */
	theorem pm4_87 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ( ( ph /\ ps ) -> ch ) <-> ( ph -> ( ps -> ch ) ) ) /\ ( ( ph -> ( ps -> ch ) ) <-> ( ps -> ( ph -> ch ) ) ) ) /\ ( ( ps -> ( ph -> ch ) ) <-> ( ( ps /\ ph ) -> ch ) ) ) ;
	}

	/*  [27-Oct-2006]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_87 {
		step 1 : wff = theorem impexp () |- ( ( ( ph /\ ps ) -> ch ) <-> ( ph -> ( ps -> ch ) ) ) ;
		step 2 : wff = theorem bi2_04 () |- ( ( ph -> ( ps -> ch ) ) <-> ( ps -> ( ph -> ch ) ) ) ;
		step 3 : wff = theorem pm3_2i (step 1, step 2) |- ( ( ( ( ph /\ ps ) -> ch ) <-> ( ph -> ( ps -> ch ) ) ) /\ ( ( ph -> ( ps -> ch ) ) <-> ( ps -> ( ph -> ch ) ) ) ) ;
		step 4 : wff = theorem impexp () |- ( ( ( ps /\ ph ) -> ch ) <-> ( ps -> ( ph -> ch ) ) ) ;
		step 5 : wff = theorem bicomi (step 4) |- ( ( ps -> ( ph -> ch ) ) <-> ( ( ps /\ ph ) -> ch ) ) ;
		step 6 : wff = theorem pm3_2i (step 3, step 5) |- ( ( ( ( ( ph /\ ps ) -> ch ) <-> ( ph -> ( ps -> ch ) ) ) /\ ( ( ph -> ( ps -> ch ) ) <-> ( ps -> ( ph -> ch ) ) ) ) /\ ( ( ps -> ( ph -> ch ) ) <-> ( ( ps /\ ph ) -> ch ) ) ) ;
		qed prop = step 6 ;
	}

	/*  Theorem *3.33 (Syll) of [WhiteheadRussell] p. 112.  */
	theorem pm3_33 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) /\ ( ps -> ch ) ) -> ( ph -> ch ) ) ;
	}

	/*  [16-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm3_33 {
		step 1 : wff = theorem imim1 () |- ( ( ph -> ps ) -> ( ( ps -> ch ) -> ( ph -> ch ) ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ( ph -> ps ) /\ ( ps -> ch ) ) -> ( ph -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *3.34 (Syll) of [WhiteheadRussell] p. 112.  */
	theorem pm3_34 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ps -> ch ) /\ ( ph -> ps ) ) -> ( ph -> ch ) ) ;
	}

	/*  [16-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm3_34 {
		step 1 : wff = theorem imim2 () |- ( ( ps -> ch ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ( ps -> ch ) /\ ( ph -> ps ) ) -> ( ph -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Conjunctive detachment.  Theorem *3.35 of [WhiteheadRussell] p. 112.  */
	theorem pm3_35 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph /\ ( ph -> ps ) ) -> ps ) ;
	}

	/*  [14-Dec-2002]  */ 
	proof of pm3_35 {
		step 1 : wff = theorem pm2_27 () |- ( ph -> ( ( ph -> ps ) -> ps ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ph /\ ( ph -> ps ) ) -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *5.31 of [WhiteheadRussell] p. 125.  */
	theorem pm5_31 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ch /\ ( ph -> ps ) ) -> ( ph -> ( ps /\ ch ) ) ) ;
	}

	/*  [19-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_31 {
		step 1 : wff = theorem pm3_21 () |- ( ch -> ( ps -> ( ps /\ ch ) ) ) ;
		step 2 : wff = theorem imim2d (step 1) |- ( ch -> ( ( ph -> ps ) -> ( ph -> ( ps /\ ch ) ) ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ch /\ ( ph -> ps ) ) -> ( ph -> ( ps /\ ch ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Importation deduction.  */
	theorem imp3a (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
	}

	/*  [31-Mar-1994]  */ 
	proof of imp3a {
		step 1 : wff = theorem impexp () |- ( ( ( ps /\ ch ) -> th ) <-> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem sylibr (hyp 1, step 1) |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  An importation inference.  */
	theorem imp31 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of imp31 {
		step 1 : wff = theorem imp (hyp 1) |- ( ( ph /\ ps ) -> ( ch -> th ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  An importation inference.  */
	theorem imp32 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of imp32 {
		step 1 : wff = theorem imp3a (hyp 1) |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  An importation inference.  */
	theorem imp4a (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ( ch /\ th ) -> ta ) ) ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of imp4a {
		step 1 : wff = theorem impexp () |- ( ( ( ch /\ th ) -> ta ) <-> ( ch -> ( th -> ta ) ) ) ;
		step 2 : wff = theorem syl6ibr (hyp 1, step 1) |- ( ph -> ( ps -> ( ( ch /\ th ) -> ta ) ) ) ;
		qed prop = step 2 ;
	}

	/*  An importation inference.  */
	theorem imp4b (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ( ( ch /\ th ) -> ta ) ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of imp4b {
		step 1 : wff = theorem imp4a (hyp 1) |- ( ph -> ( ps -> ( ( ch /\ th ) -> ta ) ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ph /\ ps ) -> ( ( ch /\ th ) -> ta ) ) ;
		qed prop = step 2 ;
	}

	/*  An importation inference.  */
	theorem imp4c (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ( ps /\ ch ) /\ th ) -> ta ) ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of imp4c {
		step 1 : wff = theorem imp3a (hyp 1) |- ( ph -> ( ( ps /\ ch ) -> ( th -> ta ) ) ) ;
		step 2 : wff = theorem imp3a (step 1) |- ( ph -> ( ( ( ps /\ ch ) /\ th ) -> ta ) ) ;
		qed prop = step 2 ;
	}

	/*  An importation inference.  */
	theorem imp4d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ ( ch /\ th ) ) -> ta ) ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of imp4d {
		step 1 : wff = theorem imp4a (hyp 1) |- ( ph -> ( ps -> ( ( ch /\ th ) -> ta ) ) ) ;
		step 2 : wff = theorem imp3a (step 1) |- ( ph -> ( ( ps /\ ( ch /\ th ) ) -> ta ) ) ;
		qed prop = step 2 ;
	}

	/*  An importation inference.  */
	theorem imp41 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( ( ( ( ph /\ ps ) /\ ch ) /\ th ) -> ta ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of imp41 {
		step 1 : wff = theorem imp (hyp 1) |- ( ( ph /\ ps ) -> ( ch -> ( th -> ta ) ) ) ;
		step 2 : wff = theorem imp31 (step 1) |- ( ( ( ( ph /\ ps ) /\ ch ) /\ th ) -> ta ) ;
		qed prop = step 2 ;
	}

	/*  An importation inference.  */
	theorem imp42 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ( ps /\ ch ) ) /\ th ) -> ta ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of imp42 {
		step 1 : wff = theorem imp32 (hyp 1) |- ( ( ph /\ ( ps /\ ch ) ) -> ( th -> ta ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ( ph /\ ( ps /\ ch ) ) /\ th ) -> ta ) ;
		qed prop = step 2 ;
	}

	/*  An importation inference.  */
	theorem imp43 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ps ) /\ ( ch /\ th ) ) -> ta ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of imp43 {
		step 1 : wff = theorem imp4b (hyp 1) |- ( ( ph /\ ps ) -> ( ( ch /\ th ) -> ta ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ( ph /\ ps ) /\ ( ch /\ th ) ) -> ta ) ;
		qed prop = step 2 ;
	}

	/*  An importation inference.  */
	theorem imp44 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ( ps /\ ch ) /\ th ) ) -> ta ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of imp44 {
		step 1 : wff = theorem imp4c (hyp 1) |- ( ph -> ( ( ( ps /\ ch ) /\ th ) -> ta ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ph /\ ( ( ps /\ ch ) /\ th ) ) -> ta ) ;
		qed prop = step 2 ;
	}

	/*  An importation inference.  */
	theorem imp45 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ( ch /\ th ) ) ) -> ta ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of imp45 {
		step 1 : wff = theorem imp4d (hyp 1) |- ( ph -> ( ( ps /\ ( ch /\ th ) ) -> ta ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ph /\ ( ps /\ ( ch /\ th ) ) ) -> ta ) ;
		qed prop = step 2 ;
	}

	/*  Exportation inference.  (This theorem used to be labeled "exp" but was
	       changed to "ex" so as not to conflict with the math token "exp", per
	       the June 2006 Metamath spec change.)  (The proof was shortened by Eric
	       Schmidt, 22-Dec-2006.)  */
	theorem ex (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ch ) ) ;
	}

	/*  [22-Dec-2006]  */ /*  [5-Aug-1993]  */ 
	proof of ex {
		step 1 : wff = theorem impexp () |- ( ( ( ph /\ ps ) -> ch ) <-> ( ph -> ( ps -> ch ) ) ) ;
		step 2 : wff = theorem mpbi (hyp 1, step 1) |- ( ph -> ( ps -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Exportation inference with commuted antecedents.  */
	theorem expcom (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ps -> ( ph -> ch ) ) ;
	}

	/*  [26-May-2005]  */ /*  [25-May-2005]  */ 
	proof of expcom {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( ps -> ( ph -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Exportation deduction.  */
	theorem exp3a (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
	}

	/*  [20-Aug-1993]  */ 
	proof of exp3a {
		step 1 : wff = theorem impexp () |- ( ( ( ps /\ ch ) -> th ) <-> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem sylib (hyp 1, step 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  An exportation inference.  */
	theorem exp31 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of exp31 {
		step 1 : wff = theorem ex (hyp 1) |- ( ( ph /\ ps ) -> ( ch -> th ) ) ;
		step 2 : wff = theorem ex (step 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  An exportation inference.  */
	theorem exp32 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of exp32 {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		step 2 : wff = theorem exp3a (step 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  An exportation inference.  */
	theorem exp4a (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ( ch /\ th ) -> ta ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of exp4a {
		step 1 : wff = theorem impexp () |- ( ( ( ch /\ th ) -> ta ) <-> ( ch -> ( th -> ta ) ) ) ;
		step 2 : wff = theorem syl6ib (hyp 1, step 1) |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  An exportation inference.  */
	theorem exp4b (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ( ( ch /\ th ) -> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of exp4b {
		step 1 : wff = theorem exp3a (hyp 1) |- ( ( ph /\ ps ) -> ( ch -> ( th -> ta ) ) ) ;
		step 2 : wff = theorem ex (step 1) |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  An exportation inference.  */
	theorem exp4c (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ( ps /\ ch ) /\ th ) -> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of exp4c {
		step 1 : wff = theorem exp3a (hyp 1) |- ( ph -> ( ( ps /\ ch ) -> ( th -> ta ) ) ) ;
		step 2 : wff = theorem exp3a (step 1) |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  An exportation inference.  */
	theorem exp4d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ps /\ ( ch /\ th ) ) -> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of exp4d {
		step 1 : wff = theorem exp3a (hyp 1) |- ( ph -> ( ps -> ( ( ch /\ th ) -> ta ) ) ) ;
		step 2 : wff = theorem exp4a (step 1) |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  An exportation inference.  */
	theorem exp41 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ( ph /\ ps ) /\ ch ) /\ th ) -> ta ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of exp41 {
		step 1 : wff = theorem ex (hyp 1) |- ( ( ( ph /\ ps ) /\ ch ) -> ( th -> ta ) ) ;
		step 2 : wff = theorem exp31 (step 1) |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  An exportation inference.  */
	theorem exp42 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ( ps /\ ch ) ) /\ th ) -> ta ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of exp42 {
		step 1 : wff = theorem exp31 (hyp 1) |- ( ph -> ( ( ps /\ ch ) -> ( th -> ta ) ) ) ;
		step 2 : wff = theorem exp3a (step 1) |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  An exportation inference.  */
	theorem exp43 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ( ch /\ th ) ) -> ta ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of exp43 {
		step 1 : wff = theorem ex (hyp 1) |- ( ( ph /\ ps ) -> ( ( ch /\ th ) -> ta ) ) ;
		step 2 : wff = theorem exp4b (step 1) |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  An exportation inference.  */
	theorem exp44 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ( ps /\ ch ) /\ th ) ) -> ta ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of exp44 {
		step 1 : wff = theorem exp32 (hyp 1) |- ( ph -> ( ( ps /\ ch ) -> ( th -> ta ) ) ) ;
		step 2 : wff = theorem exp3a (step 1) |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  An exportation inference.  */
	theorem exp45 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ( ch /\ th ) ) ) -> ta ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
	}

	/*  [26-Apr-1994]  */ 
	proof of exp45 {
		step 1 : wff = theorem exp32 (hyp 1) |- ( ph -> ( ps -> ( ( ch /\ th ) -> ta ) ) ) ;
		step 2 : wff = theorem exp4a (step 1) |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Importation with conjunction in consequent.  */
	theorem impac (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ( ch /\ ps ) ) ;
	}

	/*  [9-Aug-1994]  */ 
	proof of impac {
		step 1 : wff = theorem ancrd (hyp 1) |- ( ph -> ( ps -> ( ch /\ ps ) ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ph /\ ps ) -> ( ch /\ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Inference adding a conjunct to the left of an antecedent.  */
	theorem adantl (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ( ch /\ ph ) -> ps ) ;
	}

	/*  [30-Aug-1993]  */ 
	proof of adantl {
		step 1 : wff = theorem a1i (hyp 1) |- ( ch -> ( ph -> ps ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ch /\ ph ) -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Inference adding a conjunct to the right of an antecedent.  */
	theorem adantr (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ch ) -> ps ) ;
	}

	/*  [30-Aug-1993]  */ 
	proof of adantr {
		step 1 : wff = theorem a1d (hyp 1) |- ( ph -> ( ch -> ps ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ph /\ ch ) -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding a conjunct to the left of an antecedent.  */
	theorem adantld (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( th /\ ps ) -> ch ) ) ;
	}

	/*  [4-May-1994]  */ 
	proof of adantld {
		step 1 : wff = theorem a1d (hyp 1) |- ( ph -> ( th -> ( ps -> ch ) ) ) ;
		step 2 : wff = theorem imp3a (step 1) |- ( ph -> ( ( th /\ ps ) -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding a conjunct to the right of an antecedent.  */
	theorem adantrd (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ th ) -> ch ) ) ;
	}

	/*  [4-May-1994]  */ 
	proof of adantrd {
		step 1 : wff = theorem pm3_26 () |- ( ( ps /\ th ) -> ps ) ;
		step 2 : wff = theorem syl5 (hyp 1, step 1) |- ( ph -> ( ( ps /\ th ) -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem adantll (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ( th /\ ph ) /\ ps ) -> ch ) ;
	}

	/*  [4-May-1994]  */ 
	proof of adantll {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem adantl (step 1) |- ( ( th /\ ph ) -> ( ps -> ch ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ( th /\ ph ) /\ ps ) -> ch ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem adantlr (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ th ) /\ ps ) -> ch ) ;
	}

	/*  [4-May-1994]  */ 
	proof of adantlr {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem adantr (step 1) |- ( ( ph /\ th ) -> ( ps -> ch ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ( ph /\ th ) /\ ps ) -> ch ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem adantrl (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( th /\ ps ) ) -> ch ) ;
	}

	/*  [4-May-1994]  */ 
	proof of adantrl {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem adantld (step 1) |- ( ph -> ( ( th /\ ps ) -> ch ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ph /\ ( th /\ ps ) ) -> ch ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem adantrr (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ th ) ) -> ch ) ;
	}

	/*  [4-May-1994]  */ 
	proof of adantrr {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem adantrd (step 1) |- ( ph -> ( ( ps /\ th ) -> ch ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ph /\ ( ps /\ th ) ) -> ch ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem adantlll (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ( ta /\ ph ) /\ ps ) /\ ch ) -> th ) ;
	}

	/*  [31-Dec-2004]  */ /*  [26-Dec-2004]  */ 
	proof of adantlll {
		step 1 : wff = theorem exp31 (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem a1i (step 1) |- ( ta -> ( ph -> ( ps -> ( ch -> th ) ) ) ) ;
		step 3 : wff = theorem imp41 (step 2) |- ( ( ( ( ta /\ ph ) /\ ps ) /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem adantllr (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ( ph /\ ta ) /\ ps ) /\ ch ) -> th ) ;
	}

	/*  [23-Apr-2005]  */ /*  [26-Dec-2004]  */ 
	proof of adantllr {
		step 1 : wff = theorem exp31 (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem a1d (step 1) |- ( ph -> ( ta -> ( ps -> ( ch -> th ) ) ) ) ;
		step 3 : wff = theorem imp41 (step 2) |- ( ( ( ( ph /\ ta ) /\ ps ) /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem adantlrl (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ( ta /\ ps ) ) /\ ch ) -> th ) ;
	}

	/*  [31-Dec-2004]  */ /*  [26-Dec-2004]  */ 
	proof of adantlrl {
		step 1 : wff = theorem exp31 (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem a1d (step 1) |- ( ph -> ( ta -> ( ps -> ( ch -> th ) ) ) ) ;
		step 3 : wff = theorem imp42 (step 2) |- ( ( ( ph /\ ( ta /\ ps ) ) /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem adantlrr (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ( ps /\ ta ) ) /\ ch ) -> th ) ;
	}

	/*  [5-Jan-2005]  */ /*  [26-Dec-2004]  */ 
	proof of adantlrr {
		step 1 : wff = theorem exp31 (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem a1dd (step 1) |- ( ph -> ( ps -> ( ta -> ( ch -> th ) ) ) ) ;
		step 3 : wff = theorem imp42 (step 2) |- ( ( ( ph /\ ( ps /\ ta ) ) /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem adantrll (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ( ta /\ ps ) /\ ch ) ) -> th ) ;
	}

	/*  [31-Dec-2004]  */ /*  [26-Dec-2004]  */ 
	proof of adantrll {
		step 1 : wff = theorem exp32 (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem a1d (step 1) |- ( ph -> ( ta -> ( ps -> ( ch -> th ) ) ) ) ;
		step 3 : wff = theorem imp44 (step 2) |- ( ( ph /\ ( ( ta /\ ps ) /\ ch ) ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem adantrlr (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ( ps /\ ta ) /\ ch ) ) -> th ) ;
	}

	/*  [31-Dec-2004]  */ /*  [26-Dec-2004]  */ 
	proof of adantrlr {
		step 1 : wff = theorem exp32 (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem a1dd (step 1) |- ( ph -> ( ps -> ( ta -> ( ch -> th ) ) ) ) ;
		step 3 : wff = theorem imp44 (step 2) |- ( ( ph /\ ( ( ps /\ ta ) /\ ch ) ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem adantrrl (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ( ta /\ ch ) ) ) -> th ) ;
	}

	/*  [31-Dec-2004]  */ /*  [26-Dec-2004]  */ 
	proof of adantrrl {
		step 1 : wff = theorem exp32 (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem a1dd (step 1) |- ( ph -> ( ps -> ( ta -> ( ch -> th ) ) ) ) ;
		step 3 : wff = theorem imp45 (step 2) |- ( ( ph /\ ( ps /\ ( ta /\ ch ) ) ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem adantrrr (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ( ch /\ ta ) ) ) -> th ) ;
	}

	/*  [31-Dec-2004]  */ /*  [26-Dec-2004]  */ 
	proof of adantrrr {
		step 1 : wff = theorem a1d (hyp 1) |- ( ( ph /\ ( ps /\ ch ) ) -> ( ta -> th ) ) ;
		step 2 : wff = theorem exp32 (step 1) |- ( ph -> ( ps -> ( ch -> ( ta -> th ) ) ) ) ;
		step 3 : wff = theorem imp45 (step 2) |- ( ( ph /\ ( ps /\ ( ch /\ ta ) ) ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding conjuncts to antecedent.  */
	theorem ad2antrr (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ch ) /\ th ) -> ps ) ;
	}

	/*  [19-Oct-1999]  */ 
	proof of ad2antrr {
		step 1 : wff = theorem adantr (hyp 1) |- ( ( ph /\ ch ) -> ps ) ;
		step 2 : wff = theorem adantr (step 1) |- ( ( ( ph /\ ch ) /\ th ) -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding conjuncts to antecedent.  */
	theorem ad2antlr (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ( ( ch /\ ph ) /\ th ) -> ps ) ;
	}

	/*  [19-Oct-1999]  */ 
	proof of ad2antlr {
		step 1 : wff = theorem adantl (hyp 1) |- ( ( ch /\ ph ) -> ps ) ;
		step 2 : wff = theorem adantr (step 1) |- ( ( ( ch /\ ph ) /\ th ) -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding conjuncts to antecedent.  */
	theorem ad2antrl (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ( ch /\ ( ph /\ th ) ) -> ps ) ;
	}

	/*  [19-Oct-1999]  */ 
	proof of ad2antrl {
		step 1 : wff = theorem adantr (hyp 1) |- ( ( ph /\ th ) -> ps ) ;
		step 2 : wff = theorem adantl (step 1) |- ( ( ch /\ ( ph /\ th ) ) -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding conjuncts to antecedent.  */
	theorem ad2antll (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ( ch /\ ( th /\ ph ) ) -> ps ) ;
	}

	/*  [19-Oct-1999]  */ 
	proof of ad2antll {
		step 1 : wff = theorem adantl (hyp 1) |- ( ( th /\ ph ) -> ps ) ;
		step 2 : wff = theorem adantl (step 1) |- ( ( ch /\ ( th /\ ph ) ) -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding two conjuncts to antecedent.  */
	theorem ad2ant2l (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ( th /\ ph ) /\ ( ta /\ ps ) ) -> ch ) ;
	}

	/*  [9-Jan-2006]  */ /*  [8-Jan-2006]  */ 
	proof of ad2ant2l {
		step 1 : wff = theorem adantrl (hyp 1) |- ( ( ph /\ ( ta /\ ps ) ) -> ch ) ;
		step 2 : wff = theorem adantll (step 1) |- ( ( ( th /\ ph ) /\ ( ta /\ ps ) ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding two conjuncts to antecedent.  */
	theorem ad2ant2r (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ th ) /\ ( ps /\ ta ) ) -> ch ) ;
	}

	/*  [9-Jan-2006]  */ /*  [8-Jan-2006]  */ 
	proof of ad2ant2r {
		step 1 : wff = theorem adantrr (hyp 1) |- ( ( ph /\ ( ps /\ ta ) ) -> ch ) ;
		step 2 : wff = theorem adantlr (step 1) |- ( ( ( ph /\ th ) /\ ( ps /\ ta ) ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding two conjuncts to antecedent.  */
	theorem ad2ant2lr (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ( th /\ ph ) /\ ( ps /\ ta ) ) -> ch ) ;
	}

	/*  [23-Nov-2007]  */ /*  [23-Nov-2007]  */ 
	proof of ad2ant2lr {
		step 1 : wff = theorem adantrr (hyp 1) |- ( ( ph /\ ( ps /\ ta ) ) -> ch ) ;
		step 2 : wff = theorem adantll (step 1) |- ( ( ( th /\ ph ) /\ ( ps /\ ta ) ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding two conjuncts to antecedent.  */
	theorem ad2ant2rl (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ th ) /\ ( ta /\ ps ) ) -> ch ) ;
	}

	/*  [24-Nov-2007]  */ /*  [24-Nov-2007]  */ 
	proof of ad2ant2rl {
		step 1 : wff = theorem adantrl (hyp 1) |- ( ( ph /\ ( ta /\ ps ) ) -> ch ) ;
		step 2 : wff = theorem adantlr (step 1) |- ( ( ( ph /\ th ) /\ ( ta /\ ps ) ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Simplification of a conjunction.  */
	theorem simpll (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> ph ) ;
	}

	/*  [19-Mar-2007]  */ /*  [18-Mar-2007]  */ 
	proof of simpll {
		step 1 : wff = theorem id () |- ( ph -> ph ) ;
		step 2 : wff = theorem ad2antrr (step 1) |- ( ( ( ph /\ ps ) /\ ch ) -> ph ) ;
		qed prop = step 2 ;
	}

	/*  Simplification of a conjunction.  */
	theorem simplr (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> ps ) ;
	}

	/*  [20-Mar-2007]  */ /*  [20-Mar-2007]  */ 
	proof of simplr {
		step 1 : wff = theorem id () |- ( ps -> ps ) ;
		step 2 : wff = theorem ad2antlr (step 1) |- ( ( ( ph /\ ps ) /\ ch ) -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Simplification of a conjunction.  */
	theorem simprl (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> ps ) ;
	}

	/*  [21-Mar-2007]  */ /*  [21-Mar-2007]  */ 
	proof of simprl {
		step 1 : wff = theorem id () |- ( ps -> ps ) ;
		step 2 : wff = theorem ad2antrl (step 1) |- ( ( ph /\ ( ps /\ ch ) ) -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Simplification of a conjunction.  */
	theorem simprr (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> ch ) ;
	}

	/*  [21-Mar-2007]  */ /*  [21-Mar-2007]  */ 
	proof of simprr {
		step 1 : wff = theorem id () |- ( ch -> ch ) ;
		step 2 : wff = theorem ad2antll (step 1) |- ( ( ph /\ ( ps /\ ch ) ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Inference from a logical equivalence.  */
	theorem biimpa (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [3-May-1994]  */ 
	proof of biimpa {
		step 1 : wff = theorem biimpd (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Inference from a logical equivalence.  */
	theorem biimpar (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ch ) -> ps ) ;
	}

	/*  [3-May-1994]  */ 
	proof of biimpar {
		step 1 : wff = theorem biimprd (hyp 1) |- ( ph -> ( ch -> ps ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ph /\ ch ) -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Inference from a logical equivalence.  */
	theorem biimpac (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ps /\ ph ) -> ch ) ;
	}

	/*  [3-May-1994]  */ 
	proof of biimpac {
		step 1 : wff = theorem biimpcd (hyp 1) |- ( ps -> ( ph -> ch ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ps /\ ph ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Inference from a logical equivalence.  */
	theorem biimparc (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ch /\ ph ) -> ps ) ;
	}

	/*  [3-May-1994]  */ 
	proof of biimparc {
		step 1 : wff = theorem biimprcd (hyp 1) |- ( ch -> ( ph -> ps ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ch /\ ph ) -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Deduction eliminating a conjunct.  */
	theorem pm3_26bda (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ( ch /\ th ) ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [23-Oct-2007]  */ /*  [22-Oct-2007]  */ 
	proof of pm3_26bda {
		step 1 : wff = theorem biimpa (hyp 1) |- ( ( ph /\ ps ) -> ( ch /\ th ) ) ;
		step 2 : wff = theorem pm3_26d (step 1) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Deduction eliminating a conjunct.  */
	theorem pm3_27bda (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ( ch /\ th ) ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> th ) ;
	}

	/*  [25-Oct-2007]  */ /*  [22-Oct-2007]  */ 
	proof of pm3_27bda {
		step 1 : wff = theorem biimpa (hyp 1) |- ( ( ph /\ ps ) -> ( ch /\ th ) ) ;
		step 2 : wff = theorem pm3_27d (step 1) |- ( ( ph /\ ps ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Disjunction of antecedents.  Compare Theorem *4.77 of
	     [WhiteheadRussell] p. 121.  */
	theorem jaob (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ch ) -> ps ) <-> ( ( ph -> ps ) /\ ( ch -> ps ) ) ) ;
	}

	/*  [30-May-1994]  */ 
	proof of jaob {
		step 1 : wff = theorem orc () |- ( ph -> ( ph \/ ch ) ) ;
		step 2 : wff = theorem imim1i (step 1) |- ( ( ( ph \/ ch ) -> ps ) -> ( ph -> ps ) ) ;
		step 3 : wff = theorem olc () |- ( ch -> ( ph \/ ch ) ) ;
		step 4 : wff = theorem imim1i (step 3) |- ( ( ( ph \/ ch ) -> ps ) -> ( ch -> ps ) ) ;
		step 5 : wff = theorem jca (step 2, step 4) |- ( ( ( ph \/ ch ) -> ps ) -> ( ( ph -> ps ) /\ ( ch -> ps ) ) ) ;
		step 6 : wff = theorem jao () |- ( ( ph -> ps ) -> ( ( ch -> ps ) -> ( ( ph \/ ch ) -> ps ) ) ) ;
		step 7 : wff = theorem imp (step 6) |- ( ( ( ph -> ps ) /\ ( ch -> ps ) ) -> ( ( ph \/ ch ) -> ps ) ) ;
		step 8 : wff = theorem impbi (step 5, step 7) |- ( ( ( ph \/ ch ) -> ps ) <-> ( ( ph -> ps ) /\ ( ch -> ps ) ) ) ;
		qed prop = step 8 ;
	}

	/*  Theorem *4.77 of [WhiteheadRussell] p. 121.  */
	theorem pm4_77 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ps -> ph ) /\ ( ch -> ph ) ) <-> ( ( ps \/ ch ) -> ph ) ) ;
	}

	/*  [10-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_77 {
		step 1 : wff = theorem jaob () |- ( ( ( ps \/ ch ) -> ph ) <-> ( ( ps -> ph ) /\ ( ch -> ph ) ) ) ;
		step 2 : wff = theorem bicomi (step 1) |- ( ( ( ps -> ph ) /\ ( ch -> ph ) ) <-> ( ( ps \/ ch ) -> ph ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction disjoining the antecedents of two implications.  */
	theorem jaod (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps \/ th ) -> ch ) ) ;
	}

	/*  [18-Aug-1994]  */ 
	proof of jaod {
		step 1 : wff = theorem jao () |- ( ( ps -> ch ) -> ( ( th -> ch ) -> ( ( ps \/ th ) -> ch ) ) ) ;
		step 2 : wff = theorem sylc (step 1, hyp 1, hyp 2) |- ( ph -> ( ( ps \/ th ) -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Inference disjoining the antecedents of two implications.  */
	theorem jaoian (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( ( th /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ( ph \/ th ) /\ ps ) -> ch ) ;
	}

	/*  [26-Oct-2005]  */ /*  [23-Oct-2005]  */ 
	proof of jaoian {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem ex (hyp 2) |- ( th -> ( ps -> ch ) ) ;
		step 3 : wff = theorem jaoi (step 1, step 2) |- ( ( ph \/ th ) -> ( ps -> ch ) ) ;
		step 4 : wff = theorem imp (step 3) |- ( ( ( ph \/ th ) /\ ps ) -> ch ) ;
		qed prop = step 4 ;
	}

	/*  Deduction disjoining the antecedents of two implications.  */
	theorem jaodan (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( ( ph /\ th ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps \/ th ) ) -> ch ) ;
	}

	/*  [24-Oct-2005]  */ /*  [14-Oct-2005]  */ 
	proof of jaodan {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem ex (hyp 2) |- ( ph -> ( th -> ch ) ) ;
		step 3 : wff = theorem jaod (step 1, step 2) |- ( ph -> ( ( ps \/ th ) -> ch ) ) ;
		step 4 : wff = theorem imp (step 3) |- ( ( ph /\ ( ps \/ th ) ) -> ch ) ;
		qed prop = step 4 ;
	}

	/*  Inference conjoining and disjoining the antecedents of two
	       implications.  */
	theorem jaao (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( th -> ( ta -> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ th ) -> ( ( ps \/ ta ) -> ch ) ) ;
	}

	/*  [30-Sep-1999]  */ 
	proof of jaao {
		step 1 : wff = theorem adantr (hyp 1) |- ( ( ph /\ th ) -> ( ps -> ch ) ) ;
		step 2 : wff = theorem adantl (hyp 2) |- ( ( ph /\ th ) -> ( ta -> ch ) ) ;
		step 3 : wff = theorem jaod (step 1, step 2) |- ( ( ph /\ th ) -> ( ( ps \/ ta ) -> ch ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.63 of [WhiteheadRussell] p. 107.  */
	theorem pm2_63 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph \/ ps ) -> ( ( -. ph \/ ps ) -> ps ) ) ;
	}

	/*  [19-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_63 {
		step 1 : wff = theorem pm2_53 () |- ( ( ph \/ ps ) -> ( -. ph -> ps ) ) ;
		step 2 : wff = theorem idd () |- ( ( ph \/ ps ) -> ( ps -> ps ) ) ;
		step 3 : wff = theorem jaod (step 1, step 2) |- ( ( ph \/ ps ) -> ( ( -. ph \/ ps ) -> ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.64 of [WhiteheadRussell] p. 107.  */
	theorem pm2_64 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph \/ ps ) -> ( ( ph \/ -. ps ) -> ph ) ) ;
	}

	/*  [19-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_64 {
		step 1 : wff = axiom ax-1 () |- ( ph -> ( ( ph \/ ps ) -> ph ) ) ;
		step 2 : wff = theorem orel2 () |- ( -. ps -> ( ( ph \/ ps ) -> ph ) ) ;
		step 3 : wff = theorem jaoi (step 1, step 2) |- ( ( ph \/ -. ps ) -> ( ( ph \/ ps ) -> ph ) ) ;
		step 4 : wff = theorem com12 (step 3) |- ( ( ph \/ ps ) -> ( ( ph \/ -. ps ) -> ph ) ) ;
		qed prop = step 4 ;
	}

	/*  Theorem *3.44 of [WhiteheadRussell] p. 113.  */
	theorem pm3_44 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ps -> ph ) /\ ( ch -> ph ) ) -> ( ( ps \/ ch ) -> ph ) ) ;
	}

	/*  [24-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm3_44 {
		step 1 : wff = theorem jaob () |- ( ( ( ps \/ ch ) -> ph ) <-> ( ( ps -> ph ) /\ ( ch -> ph ) ) ) ;
		step 2 : wff = theorem biimpr (step 1) |- ( ( ( ps -> ph ) /\ ( ch -> ph ) ) -> ( ( ps \/ ch ) -> ph ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *4.43 of [WhiteheadRussell] p. 119.  */
	theorem pm4_43 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph <-> ( ( ph \/ ps ) /\ ( ph \/ -. ps ) ) ) ;
	}

	/*  [25-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_43 {
		step 1 : wff = theorem orc () |- ( ph -> ( ph \/ ps ) ) ;
		step 2 : wff = theorem orc () |- ( ph -> ( ph \/ -. ps ) ) ;
		step 3 : wff = theorem jca (step 1, step 2) |- ( ph -> ( ( ph \/ ps ) /\ ( ph \/ -. ps ) ) ) ;
		step 4 : wff = theorem pm2_64 () |- ( ( ph \/ ps ) -> ( ( ph \/ -. ps ) -> ph ) ) ;
		step 5 : wff = theorem imp (step 4) |- ( ( ( ph \/ ps ) /\ ( ph \/ -. ps ) ) -> ph ) ;
		step 6 : wff = theorem impbi (step 3, step 5) |- ( ph <-> ( ( ph \/ ps ) /\ ( ph \/ -. ps ) ) ) ;
		qed prop = step 6 ;
	}

	/*  Idempotent law for conjunction.  */
	theorem anidm (var ph : wff ) 
	{
		prop : wff = |- ( ( ph /\ ph ) <-> ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of anidm {
		step 1 : wff = theorem pm3_26 () |- ( ( ph /\ ph ) -> ph ) ;
		step 2 : wff = theorem pm3_2 () |- ( ph -> ( ph -> ( ph /\ ph ) ) ) ;
		step 3 : wff = theorem pm2_43i (step 2) |- ( ph -> ( ph /\ ph ) ) ;
		step 4 : wff = theorem impbi (step 1, step 3) |- ( ( ph /\ ph ) <-> ph ) ;
		qed prop = step 4 ;
	}

	/*  Theorem *4.24 of [WhiteheadRussell] p. 117.  */
	theorem pm4_24 (var ph : wff ) 
	{
		prop : wff = |- ( ph <-> ( ph /\ ph ) ) ;
	}

	/*  [17-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_24 {
		step 1 : wff = theorem anidm () |- ( ( ph /\ ph ) <-> ph ) ;
		step 2 : wff = theorem bicomi (step 1) |- ( ph <-> ( ph /\ ph ) ) ;
		qed prop = step 2 ;
	}

	/*  Inference from idempotent law for conjunction.  */
	theorem anidms (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ph ) -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ps ) ;
	}

	/*  [15-Jun-1994]  */ 
	proof of anidms {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ph -> ps ) ) ;
		step 2 : wff = theorem pm2_43i (step 1) |- ( ph -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Commutative law for conjunction.  Theorem *4.3 of [WhiteheadRussell]
	     p. 118.  */
	theorem ancom (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps ) <-> ( ps /\ ph ) ) ;
	}

	/*  [25-Jun-1998]  */ 
	proof of ancom {
		step 1 : wff = theorem pm3_27 () |- ( ( ph /\ ps ) -> ps ) ;
		step 2 : wff = theorem pm3_26 () |- ( ( ph /\ ps ) -> ph ) ;
		step 3 : wff = theorem jca (step 1, step 2) |- ( ( ph /\ ps ) -> ( ps /\ ph ) ) ;
		step 4 : wff = theorem pm3_27 () |- ( ( ps /\ ph ) -> ph ) ;
		step 5 : wff = theorem pm3_26 () |- ( ( ps /\ ph ) -> ps ) ;
		step 6 : wff = theorem jca (step 4, step 5) |- ( ( ps /\ ph ) -> ( ph /\ ps ) ) ;
		step 7 : wff = theorem impbi (step 3, step 6) |- ( ( ph /\ ps ) <-> ( ps /\ ph ) ) ;
		qed prop = step 7 ;
	}

	/*  Inference commuting conjunction in antecedent.  _Notational convention_:
	       We sometimes suffix with "s" the label of an inference that manipulates
	       an antecedent, leaving the consequent unchanged.  The "s" means that the
	       inference eliminates the need for a syllogism ( ~ syl ) -type inference
	       in a proof.  */
	theorem ancoms (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ps /\ ph ) -> ch ) ;
	}

	/*  [21-Apr-1994]  */ 
	proof of ancoms {
		step 1 : wff = theorem ancom () |- ( ( ps /\ ph ) <-> ( ph /\ ps ) ) ;
		step 2 : wff = theorem sylbi (step 1, hyp 1) |- ( ( ps /\ ph ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Deduction commuting conjunction in antecedent.  */
	theorem ancomsd (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ch /\ ps ) -> th ) ) ;
	}

	/*  [13-Dec-2004]  */ /*  [12-Dec-2004]  */ 
	proof of ancomsd {
		step 1 : wff = theorem ancom () |- ( ( ch /\ ps ) <-> ( ps /\ ch ) ) ;
		step 2 : wff = theorem syl5ib (hyp 1, step 1) |- ( ph -> ( ( ch /\ ps ) -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *3.22 of [WhiteheadRussell] p. 111.  */
	theorem pm3_22 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps ) -> ( ps /\ ph ) ) ;
	}

	/*  [17-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm3_22 {
		step 1 : wff = theorem ancom () |- ( ( ph /\ ps ) <-> ( ps /\ ph ) ) ;
		step 2 : wff = theorem biimp (step 1) |- ( ( ph /\ ps ) -> ( ps /\ ph ) ) ;
		qed prop = step 2 ;
	}

	/*  Associative law for conjunction.  Theorem *4.32 of [WhiteheadRussell]
	     p. 118.  */
	theorem anass (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) /\ ch ) <-> ( ph /\ ( ps /\ ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of anass {
		step 1 : wff = theorem impexp () |- ( ( ( ph /\ ps ) -> -. ch ) <-> ( ph -> ( ps -> -. ch ) ) ) ;
		step 2 : wff = theorem imnan () |- ( ( ps -> -. ch ) <-> -. ( ps /\ ch ) ) ;
		step 3 : wff = theorem imbi2i (step 2) |- ( ( ph -> ( ps -> -. ch ) ) <-> ( ph -> -. ( ps /\ ch ) ) ) ;
		step 4 : wff = theorem bitr (step 1, step 3) |- ( ( ( ph /\ ps ) -> -. ch ) <-> ( ph -> -. ( ps /\ ch ) ) ) ;
		step 5 : wff = theorem negbii (step 4) |- ( -. ( ( ph /\ ps ) -> -. ch ) <-> -. ( ph -> -. ( ps /\ ch ) ) ) ;
		step 6 : wff = definition df-an () |- ( ( ( ph /\ ps ) /\ ch ) <-> -. ( ( ph /\ ps ) -> -. ch ) ) ;
		step 7 : wff = definition df-an () |- ( ( ph /\ ( ps /\ ch ) ) <-> -. ( ph -> -. ( ps /\ ch ) ) ) ;
		step 8 : wff = theorem _3bitr4 (step 5, step 6, step 7) |- ( ( ( ph /\ ps ) /\ ch ) <-> ( ph /\ ( ps /\ ch ) ) ) ;
		qed prop = step 8 ;
	}

	/*  Associative law for conjunction applied to antecedent (eliminates
	       syllogism).  */
	theorem anasss (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
	}

	/*  [15-Nov-2002]  */ 
	proof of anasss {
		step 1 : wff = theorem exp31 (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem imp32 (step 1) |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Associative law for conjunction applied to antecedent (eliminates
	       syllogism).  */
	theorem anassrs (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
	}

	/*  [15-Nov-2002]  */ 
	proof of anassrs {
		step 1 : wff = theorem exp32 (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem imp31 (step 1) |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Distribution of implication with conjunction.  */
	theorem imdistan (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ps -> ch ) ) <-> ( ( ph /\ ps ) -> ( ph /\ ch ) ) ) ;
	}

	/*  [31-May-1999]  */ 
	proof of imdistan {
		step 1 : wff = theorem anc2l () |- ( ( ph -> ( ps -> ch ) ) -> ( ph -> ( ps -> ( ph /\ ch ) ) ) ) ;
		step 2 : wff = theorem imp3a (step 1) |- ( ( ph -> ( ps -> ch ) ) -> ( ( ph /\ ps ) -> ( ph /\ ch ) ) ) ;
		step 3 : wff = theorem pm3_27 () |- ( ( ph /\ ch ) -> ch ) ;
		step 4 : wff = theorem imim2i (step 3) |- ( ( ( ph /\ ps ) -> ( ph /\ ch ) ) -> ( ( ph /\ ps ) -> ch ) ) ;
		step 5 : wff = theorem exp3a (step 4) |- ( ( ( ph /\ ps ) -> ( ph /\ ch ) ) -> ( ph -> ( ps -> ch ) ) ) ;
		step 6 : wff = theorem impbi (step 2, step 5) |- ( ( ph -> ( ps -> ch ) ) <-> ( ( ph /\ ps ) -> ( ph /\ ch ) ) ) ;
		qed prop = step 6 ;
	}

	/*  Distribution of implication with conjunction.  */
	theorem imdistani (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ( ph /\ ch ) ) ;
	}

	/*  [1-Aug-1994]  */ 
	proof of imdistani {
		step 1 : wff = theorem anc2li (hyp 1) |- ( ph -> ( ps -> ( ph /\ ch ) ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ph /\ ps ) -> ( ph /\ ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Distribution of implication with conjunction.  */
	theorem imdistanri (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ps /\ ph ) -> ( ch /\ ph ) ) ;
	}

	/*  [8-Jan-2002]  */ 
	proof of imdistanri {
		step 1 : wff = theorem com12 (hyp 1) |- ( ps -> ( ph -> ch ) ) ;
		step 2 : wff = theorem impac (step 1) |- ( ( ps /\ ph ) -> ( ch /\ ph ) ) ;
		qed prop = step 2 ;
	}

	/*  Distribution of implication with conjunction (deduction rule).  */
	theorem imdistand (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ ch ) -> ( ps /\ th ) ) ) ;
	}

	/*  [28-Aug-2004]  */ /*  [27-Aug-2004]  */ 
	proof of imdistand {
		step 1 : wff = theorem imdistan () |- ( ( ps -> ( ch -> th ) ) <-> ( ( ps /\ ch ) -> ( ps /\ th ) ) ) ;
		step 2 : wff = theorem sylib (hyp 1, step 1) |- ( ph -> ( ( ps /\ ch ) -> ( ps /\ th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *5.3 of [WhiteheadRussell] p. 125.  */
	theorem pm5_3 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) -> ch ) <-> ( ( ph /\ ps ) -> ( ph /\ ch ) ) ) ;
	}

	/*  [27-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_3 {
		step 1 : wff = theorem pm3_3 () |- ( ( ( ph /\ ps ) -> ch ) -> ( ph -> ( ps -> ch ) ) ) ;
		step 2 : wff = theorem imdistand (step 1) |- ( ( ( ph /\ ps ) -> ch ) -> ( ( ph /\ ps ) -> ( ph /\ ch ) ) ) ;
		step 3 : wff = theorem pm3_27 () |- ( ( ph /\ ch ) -> ch ) ;
		step 4 : wff = theorem imim2i (step 3) |- ( ( ( ph /\ ps ) -> ( ph /\ ch ) ) -> ( ( ph /\ ps ) -> ch ) ) ;
		step 5 : wff = theorem impbi (step 2, step 4) |- ( ( ( ph /\ ps ) -> ch ) <-> ( ( ph /\ ps ) -> ( ph /\ ch ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Theorem *5.61 of [WhiteheadRussell] p. 125.  */
	theorem pm5_61 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ps ) /\ -. ps ) <-> ( ph /\ -. ps ) ) ;
	}

	/*  [10-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_61 {
		step 1 : wff = theorem orel2 () |- ( -. ps -> ( ( ph \/ ps ) -> ph ) ) ;
		step 2 : wff = theorem imdistanri (step 1) |- ( ( ( ph \/ ps ) /\ -. ps ) -> ( ph /\ -. ps ) ) ;
		step 3 : wff = theorem orc () |- ( ph -> ( ph \/ ps ) ) ;
		step 4 : wff = theorem anim1i (step 3) |- ( ( ph /\ -. ps ) -> ( ( ph \/ ps ) /\ -. ps ) ) ;
		step 5 : wff = theorem impbi (step 2, step 4) |- ( ( ( ph \/ ps ) /\ -. ps ) <-> ( ph /\ -. ps ) ) ;
		qed prop = step 5 ;
	}

	/*  A syllogism inference.  */
	theorem sylan (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( th -> ph ) ;
		-----------------
		prop : wff = |- ( ( th /\ ps ) -> ch ) ;
	}

	/*  [21-Apr-1994]  */ 
	proof of sylan {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem syl (hyp 2, step 1) |- ( th -> ( ps -> ch ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( th /\ ps ) -> ch ) ;
		qed prop = step 3 ;
	}

	/*  A syllogism inference.  */
	theorem sylanb (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( th <-> ph ) ;
		-----------------
		prop : wff = |- ( ( th /\ ps ) -> ch ) ;
	}

	/*  [18-May-1994]  */ 
	proof of sylanb {
		step 1 : wff = theorem biimp (hyp 2) |- ( th -> ph ) ;
		step 2 : wff = theorem sylan (hyp 1, step 1) |- ( ( th /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem sylanbr (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( ph <-> th ) ;
		-----------------
		prop : wff = |- ( ( th /\ ps ) -> ch ) ;
	}

	/*  [18-May-1994]  */ 
	proof of sylanbr {
		step 1 : wff = theorem biimpr (hyp 2) |- ( th -> ph ) ;
		step 2 : wff = theorem sylan (hyp 1, step 1) |- ( ( th /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem sylan2 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( th -> ps ) ;
		-----------------
		prop : wff = |- ( ( ph /\ th ) -> ch ) ;
	}

	/*  [21-Apr-1994]  */ 
	proof of sylan2 {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem syl5 (step 1, hyp 2) |- ( ph -> ( th -> ch ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ph /\ th ) -> ch ) ;
		qed prop = step 3 ;
	}

	/*  A syllogism inference.  */
	theorem sylan2b (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( th <-> ps ) ;
		-----------------
		prop : wff = |- ( ( ph /\ th ) -> ch ) ;
	}

	/*  [21-Apr-1994]  */ 
	proof of sylan2b {
		step 1 : wff = theorem biimp (hyp 2) |- ( th -> ps ) ;
		step 2 : wff = theorem sylan2 (hyp 1, step 1) |- ( ( ph /\ th ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem sylan2br (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( ps <-> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ th ) -> ch ) ;
	}

	/*  [21-Apr-1994]  */ 
	proof of sylan2br {
		step 1 : wff = theorem biimpr (hyp 2) |- ( th -> ps ) ;
		step 2 : wff = theorem sylan2 (hyp 1, step 1) |- ( ( ph /\ th ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A double syllogism inference.  */
	theorem syl2an (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( th -> ph ) ;
		hyp 3 : wff = |- ( ta -> ps ) ;
		-----------------
		prop : wff = |- ( ( th /\ ta ) -> ch ) ;
	}

	/*  [31-Jan-1997]  */ 
	proof of syl2an {
		step 1 : wff = theorem sylan (hyp 1, hyp 2) |- ( ( th /\ ps ) -> ch ) ;
		step 2 : wff = theorem sylan2 (step 1, hyp 3) |- ( ( th /\ ta ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A double syllogism inference.  */
	theorem syl2anb (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( th <-> ph ) ;
		hyp 3 : wff = |- ( ta <-> ps ) ;
		-----------------
		prop : wff = |- ( ( th /\ ta ) -> ch ) ;
	}

	/*  [29-Jul-1999]  */ 
	proof of syl2anb {
		step 1 : wff = theorem sylanb (hyp 1, hyp 2) |- ( ( th /\ ps ) -> ch ) ;
		step 2 : wff = theorem sylan2b (step 1, hyp 3) |- ( ( th /\ ta ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A double syllogism inference.  */
	theorem syl2anbr (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( ph <-> th ) ;
		hyp 3 : wff = |- ( ps <-> ta ) ;
		-----------------
		prop : wff = |- ( ( th /\ ta ) -> ch ) ;
	}

	/*  [29-Jul-1999]  */ 
	proof of syl2anbr {
		step 1 : wff = theorem sylanbr (hyp 1, hyp 2) |- ( ( th /\ ps ) -> ch ) ;
		step 2 : wff = theorem sylan2br (step 1, hyp 3) |- ( ( th /\ ta ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism deduction.  */
	theorem syland (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		hyp 2 : wff = |- ( ph -> ( ta -> ps ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ta /\ ch ) -> th ) ) ;
	}

	/*  [17-Dec-2004]  */ /*  [15-Dec-2004]  */ 
	proof of syland {
		step 1 : wff = theorem exp3a (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem syld (hyp 2, step 1) |- ( ph -> ( ta -> ( ch -> th ) ) ) ;
		step 3 : wff = theorem imp3a (step 2) |- ( ph -> ( ( ta /\ ch ) -> th ) ) ;
		qed prop = step 3 ;
	}

	/*  A syllogism deduction.  */
	theorem sylan2d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		hyp 2 : wff = |- ( ph -> ( ta -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ ta ) -> th ) ) ;
	}

	/*  [17-Dec-2004]  */ /*  [15-Dec-2004]  */ 
	proof of sylan2d {
		step 1 : wff = theorem ancomsd (hyp 1) |- ( ph -> ( ( ch /\ ps ) -> th ) ) ;
		step 2 : wff = theorem syland (step 1, hyp 2) |- ( ph -> ( ( ta /\ ps ) -> th ) ) ;
		step 3 : wff = theorem ancomsd (step 2) |- ( ph -> ( ( ps /\ ta ) -> th ) ) ;
		qed prop = step 3 ;
	}

	/*  A syllogism deduction.  */
	theorem syl2and (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		hyp 2 : wff = |- ( ph -> ( ta -> ps ) ) ;
		hyp 3 : wff = |- ( ph -> ( et -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ta /\ et ) -> th ) ) ;
	}

	/*  [17-Dec-2004]  */ /*  [15-Dec-2004]  */ 
	proof of syl2and {
		step 1 : wff = theorem sylan2d (hyp 1, hyp 3) |- ( ph -> ( ( ps /\ et ) -> th ) ) ;
		step 2 : wff = theorem syland (step 1, hyp 2) |- ( ph -> ( ( ta /\ et ) -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem sylanl1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		hyp 2 : wff = |- ( ta -> ph ) ;
		-----------------
		prop : wff = |- ( ( ( ta /\ ps ) /\ ch ) -> th ) ;
	}

	/*  [30-Apr-2005]  */ /*  [10-Mar-2005]  */ 
	proof of sylanl1 {
		step 1 : wff = theorem anim1i (hyp 2) |- ( ( ta /\ ps ) -> ( ph /\ ps ) ) ;
		step 2 : wff = theorem sylan (hyp 1, step 1) |- ( ( ( ta /\ ps ) /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem sylanl2 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		hyp 2 : wff = |- ( ta -> ps ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ta ) /\ ch ) -> th ) ;
	}

	/*  [2-Jan-2005]  */ /*  [1-Jan-2005]  */ 
	proof of sylanl2 {
		step 1 : wff = theorem anim2i (hyp 2) |- ( ( ph /\ ta ) -> ( ph /\ ps ) ) ;
		step 2 : wff = theorem sylan (hyp 1, step 1) |- ( ( ( ph /\ ta ) /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem sylanr1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		hyp 2 : wff = |- ( ta -> ps ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ta /\ ch ) ) -> th ) ;
	}

	/*  [15-May-2005]  */ /*  [9-Apr-2005]  */ 
	proof of sylanr1 {
		step 1 : wff = theorem anim1i (hyp 2) |- ( ( ta /\ ch ) -> ( ps /\ ch ) ) ;
		step 2 : wff = theorem sylan2 (hyp 1, step 1) |- ( ( ph /\ ( ta /\ ch ) ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem sylanr2 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		hyp 2 : wff = |- ( ta -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ta ) ) -> th ) ;
	}

	/*  [1-May-2005]  */ /*  [9-Apr-2005]  */ 
	proof of sylanr2 {
		step 1 : wff = theorem anim2i (hyp 2) |- ( ( ps /\ ta ) -> ( ps /\ ch ) ) ;
		step 2 : wff = theorem sylan2 (hyp 1, step 1) |- ( ( ph /\ ( ps /\ ta ) ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem sylani (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		hyp 2 : wff = |- ( ta -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ta /\ ch ) -> th ) ) ;
	}

	/*  [2-May-1996]  */ 
	proof of sylani {
		step 1 : wff = theorem a1i (hyp 2) |- ( ph -> ( ta -> ps ) ) ;
		step 2 : wff = theorem syland (hyp 1, step 1) |- ( ph -> ( ( ta /\ ch ) -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem sylan2i (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		hyp 2 : wff = |- ( ta -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ ta ) -> th ) ) ;
	}

	/*  [1-Aug-1994]  */ 
	proof of sylan2i {
		step 1 : wff = theorem a1i (hyp 2) |- ( ph -> ( ta -> ch ) ) ;
		step 2 : wff = theorem sylan2d (hyp 1, step 1) |- ( ph -> ( ( ps /\ ta ) -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem syl2ani (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		hyp 2 : wff = |- ( ta -> ps ) ;
		hyp 3 : wff = |- ( et -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ta /\ et ) -> th ) ) ;
	}

	/*  [3-Aug-1999]  */ 
	proof of syl2ani {
		step 1 : wff = theorem sylan2i (hyp 1, hyp 3) |- ( ph -> ( ( ps /\ et ) -> th ) ) ;
		step 2 : wff = theorem sylani (step 1, hyp 2) |- ( ph -> ( ( ta /\ et ) -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism deduction with conjoined antecents.  */
	theorem syldan (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( ( ph /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> th ) ;
	}

	/*  [26-Feb-2005]  */ /*  [24-Feb-2005]  */ 
	proof of syldan {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem ex (hyp 2) |- ( ph -> ( ch -> th ) ) ;
		step 3 : wff = theorem syld (step 1, step 2) |- ( ph -> ( ps -> th ) ) ;
		step 4 : wff = theorem imp (step 3) |- ( ( ph /\ ps ) -> th ) ;
		qed prop = step 4 ;
	}

	/*  Nested syllogism inference conjoining dissimilar antecedents.  */
	theorem sylan9 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( th -> ( ch -> ta ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ th ) -> ( ps -> ta ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of sylan9 {
		step 1 : wff = theorem adantr (hyp 1) |- ( ( ph /\ th ) -> ( ps -> ch ) ) ;
		step 2 : wff = theorem adantl (hyp 2) |- ( ( ph /\ th ) -> ( ch -> ta ) ) ;
		step 3 : wff = theorem syld (step 1, step 2) |- ( ( ph /\ th ) -> ( ps -> ta ) ) ;
		qed prop = step 3 ;
	}

	/*  Nested syllogism inference conjoining dissimilar antecedents.  */
	theorem sylan9r (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( th -> ( ch -> ta ) ) ;
		-----------------
		prop : wff = |- ( ( th /\ ph ) -> ( ps -> ta ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of sylan9r {
		step 1 : wff = theorem syl9r (hyp 1, hyp 2) |- ( th -> ( ph -> ( ps -> ta ) ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( th /\ ph ) -> ( ps -> ta ) ) ;
		qed prop = step 2 ;
	}

	/*  Modus ponens conjoining dissimilar antecedents.  */
	theorem mpan9 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ch -> ( ps -> th ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ch ) -> th ) ;
	}

	/*  [1-Feb-2008]  */ /*  [1-Feb-2008]  */ 
	proof of mpan9 {
		step 1 : wff = theorem adantr (hyp 1) |- ( ( ph /\ ch ) -> ps ) ;
		step 2 : wff = theorem adantl (hyp 2) |- ( ( ph /\ ch ) -> ( ps -> th ) ) ;
		step 3 : wff = theorem mpd (step 1, step 2) |- ( ( ph /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  A syllogism inference combined with contraction.  */
	theorem sylanc (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( th -> ph ) ;
		hyp 3 : wff = |- ( th -> ps ) ;
		-----------------
		prop : wff = |- ( th -> ch ) ;
	}

	/*  [3-Oct-1999]  */ 
	proof of sylanc {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem sylc (step 1, hyp 2, hyp 3) |- ( th -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference combined with contraction.  */
	theorem syl2anc (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ( ch /\ th ) ) -> ta ) ;
		hyp 2 : wff = |- ( et -> ph ) ;
		hyp 3 : wff = |- ( et -> ps ) ;
		hyp 4 : wff = |- ( et -> ch ) ;
		hyp 5 : wff = |- ( et -> th ) ;
		-----------------
		prop : wff = |- ( et -> ta ) ;
	}

	/*  [18-Jun-2007]  */ /*  [16-Jun-2007]  */ 
	proof of syl2anc {
		step 1 : wff = theorem jca (hyp 2, hyp 3) |- ( et -> ( ph /\ ps ) ) ;
		step 2 : wff = theorem jca (hyp 4, hyp 5) |- ( et -> ( ch /\ th ) ) ;
		step 3 : wff = theorem sylanc (hyp 1, step 1, step 2) |- ( et -> ta ) ;
		qed prop = step 3 ;
	}

	/*  A syllogism inference combined with contraction.  */
	theorem sylancb (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( th <-> ph ) ;
		hyp 3 : wff = |- ( th <-> ps ) ;
		-----------------
		prop : wff = |- ( th -> ch ) ;
	}

	/*  [9-Sep-2004]  */ /*  [3-Sep-2004]  */ 
	proof of sylancb {
		step 1 : wff = theorem syl2anb (hyp 1, hyp 2, hyp 3) |- ( ( th /\ th ) -> ch ) ;
		step 2 : wff = theorem anidms (step 1) |- ( th -> ch ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference combined with contraction.  */
	theorem sylancbr (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( ph <-> th ) ;
		hyp 3 : wff = |- ( ps <-> th ) ;
		-----------------
		prop : wff = |- ( th -> ch ) ;
	}

	/*  [14-Sep-2004]  */ /*  [3-Sep-2004]  */ 
	proof of sylancbr {
		step 1 : wff = theorem syl2anbr (hyp 1, hyp 2, hyp 3) |- ( ( th /\ th ) -> ch ) ;
		step 2 : wff = theorem anidms (step 1) |- ( th -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Elimination of an antecedent.  */
	theorem pm2_61ian (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( ( -. ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ps -> ch ) ;
	}

	/*  [3-Jan-2005]  */ /*  [1-Jan-2005]  */ 
	proof of pm2_61ian {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem ex (hyp 2) |- ( -. ph -> ( ps -> ch ) ) ;
		step 3 : wff = theorem pm2_61i (step 1, step 2) |- ( ps -> ch ) ;
		qed prop = step 3 ;
	}

	/*  Elimination of an antecedent.  */
	theorem pm2_61dan (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( ( ph /\ -. ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [3-Jan-2005]  */ /*  [1-Jan-2005]  */ 
	proof of pm2_61dan {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem ex (hyp 2) |- ( ph -> ( -. ps -> ch ) ) ;
		step 3 : wff = theorem pm2_61d (step 1, step 2) |- ( ph -> ch ) ;
		qed prop = step 3 ;
	}

	/*  Proof by contradiction.  */
	theorem condan (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ -. ps ) -> ch ) ;
		hyp 2 : wff = |- ( ( ph /\ -. ps ) -> -. ch ) ;
		-----------------
		prop : wff = |- ( ph -> ps ) ;
	}

	/*  [21-Feb-2006]  */ /*  [9-Feb-2006]  */ 
	proof of condan {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( -. ps -> ch ) ) ;
		step 2 : wff = theorem ex (hyp 2) |- ( ph -> ( -. ps -> -. ch ) ) ;
		step 3 : wff = theorem pm2_65d (step 1, step 2) |- ( ph -> -. -. ps ) ;
		step 4 : wff = theorem nega () |- ( -. -. ps -> ps ) ;
		step 5 : wff = theorem syl (step 3, step 4) |- ( ph -> ps ) ;
		qed prop = step 5 ;
	}

	/*  Introduce one conjunct as an antecedent to the another.  */
	theorem abai (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps ) <-> ( ph /\ ( ph -> ps ) ) ) ;
	}

	/*  [12-Aug-1993]  */ 
	proof of abai {
		step 1 : wff = theorem pm3_26 () |- ( ( ph /\ ps ) -> ph ) ;
		step 2 : wff = theorem pm3_4 () |- ( ( ph /\ ps ) -> ( ph -> ps ) ) ;
		step 3 : wff = theorem jca (step 1, step 2) |- ( ( ph /\ ps ) -> ( ph /\ ( ph -> ps ) ) ) ;
		step 4 : wff = theorem pm3_26 () |- ( ( ph /\ ( ph -> ps ) ) -> ph ) ;
		step 5 : wff = theorem pm3_35 () |- ( ( ph /\ ( ph -> ps ) ) -> ps ) ;
		step 6 : wff = theorem jca (step 4, step 5) |- ( ( ph /\ ( ph -> ps ) ) -> ( ph /\ ps ) ) ;
		step 7 : wff = theorem impbi (step 3, step 6) |- ( ( ph /\ ps ) <-> ( ph /\ ( ph -> ps ) ) ) ;
		qed prop = step 7 ;
	}

	/*  Introduce a left conjunct to both sides of a logical equivalence.  */
	theorem anbi2i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ( ( ch /\ ph ) <-> ( ch /\ ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of anbi2i {
		step 1 : wff = theorem biimp (hyp 1) |- ( ph -> ps ) ;
		step 2 : wff = theorem anim2i (step 1) |- ( ( ch /\ ph ) -> ( ch /\ ps ) ) ;
		step 3 : wff = theorem biimpr (hyp 1) |- ( ps -> ph ) ;
		step 4 : wff = theorem anim2i (step 3) |- ( ( ch /\ ps ) -> ( ch /\ ph ) ) ;
		step 5 : wff = theorem impbi (step 2, step 4) |- ( ( ch /\ ph ) <-> ( ch /\ ps ) ) ;
		qed prop = step 5 ;
	}

	/*  Introduce a right conjunct to both sides of a logical equivalence.  */
	theorem anbi1i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ch ) <-> ( ps /\ ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of anbi1i {
		step 1 : wff = theorem ancom () |- ( ( ph /\ ch ) <-> ( ch /\ ph ) ) ;
		step 2 : wff = theorem anbi2i (hyp 1) |- ( ( ch /\ ph ) <-> ( ch /\ ps ) ) ;
		step 3 : wff = theorem ancom () |- ( ( ch /\ ps ) <-> ( ps /\ ch ) ) ;
		step 4 : wff = theorem _3bitr (step 1, step 2, step 3) |- ( ( ph /\ ch ) <-> ( ps /\ ch ) ) ;
		qed prop = step 4 ;
	}

	/*  Conjoin both sides of two equivalences.  */
	theorem anbi12i (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ch <-> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ch ) <-> ( ps /\ th ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of anbi12i {
		step 1 : wff = theorem anbi1i (hyp 1) |- ( ( ph /\ ch ) <-> ( ps /\ ch ) ) ;
		step 2 : wff = theorem anbi2i (hyp 2) |- ( ( ps /\ ch ) <-> ( ps /\ th ) ) ;
		step 3 : wff = theorem bitr (step 1, step 2) |- ( ( ph /\ ch ) <-> ( ps /\ th ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *5.53 of [WhiteheadRussell] p. 125.  */
	theorem pm5_53 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ( ph \/ ps ) \/ ch ) -> th ) <-> ( ( ( ph -> th ) /\ ( ps -> th ) ) /\ ( ch -> th ) ) ) ;
	}

	/*  [28-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_53 {
		step 1 : wff = theorem jaob () |- ( ( ( ( ph \/ ps ) \/ ch ) -> th ) <-> ( ( ( ph \/ ps ) -> th ) /\ ( ch -> th ) ) ) ;
		step 2 : wff = theorem jaob () |- ( ( ( ph \/ ps ) -> th ) <-> ( ( ph -> th ) /\ ( ps -> th ) ) ) ;
		step 3 : wff = theorem anbi1i (step 2) |- ( ( ( ( ph \/ ps ) -> th ) /\ ( ch -> th ) ) <-> ( ( ( ph -> th ) /\ ( ps -> th ) ) /\ ( ch -> th ) ) ) ;
		step 4 : wff = theorem bitr (step 1, step 3) |- ( ( ( ( ph \/ ps ) \/ ch ) -> th ) <-> ( ( ( ph -> th ) /\ ( ps -> th ) ) /\ ( ch -> th ) ) ) ;
		qed prop = step 4 ;
	}

	/*  A rearrangement of conjuncts.  */
	theorem an12 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ( ps /\ ch ) ) <-> ( ps /\ ( ph /\ ch ) ) ) ;
	}

	/*  [12-Mar-1995]  */ 
	proof of an12 {
		step 1 : wff = theorem ancom () |- ( ( ph /\ ps ) <-> ( ps /\ ph ) ) ;
		step 2 : wff = theorem anbi1i (step 1) |- ( ( ( ph /\ ps ) /\ ch ) <-> ( ( ps /\ ph ) /\ ch ) ) ;
		step 3 : wff = theorem anass () |- ( ( ( ph /\ ps ) /\ ch ) <-> ( ph /\ ( ps /\ ch ) ) ) ;
		step 4 : wff = theorem anass () |- ( ( ( ps /\ ph ) /\ ch ) <-> ( ps /\ ( ph /\ ch ) ) ) ;
		step 5 : wff = theorem _3bitr3 (step 2, step 3, step 4) |- ( ( ph /\ ( ps /\ ch ) ) <-> ( ps /\ ( ph /\ ch ) ) ) ;
		qed prop = step 5 ;
	}

	/*  A rearrangement of conjuncts.  */
	theorem an23 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) /\ ch ) <-> ( ( ph /\ ch ) /\ ps ) ) ;
	}

	/*  [12-Mar-1995]  */ 
	proof of an23 {
		step 1 : wff = theorem ancom () |- ( ( ps /\ ch ) <-> ( ch /\ ps ) ) ;
		step 2 : wff = theorem anbi2i (step 1) |- ( ( ph /\ ( ps /\ ch ) ) <-> ( ph /\ ( ch /\ ps ) ) ) ;
		step 3 : wff = theorem anass () |- ( ( ( ph /\ ps ) /\ ch ) <-> ( ph /\ ( ps /\ ch ) ) ) ;
		step 4 : wff = theorem anass () |- ( ( ( ph /\ ch ) /\ ps ) <-> ( ph /\ ( ch /\ ps ) ) ) ;
		step 5 : wff = theorem _3bitr4 (step 2, step 3, step 4) |- ( ( ( ph /\ ps ) /\ ch ) <-> ( ( ph /\ ch ) /\ ps ) ) ;
		qed prop = step 5 ;
	}

	/*  Deduction rearranging conjuncts.  */
	theorem an1s (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ps /\ ( ph /\ ch ) ) -> th ) ;
	}

	/*  [13-Mar-1996]  */ 
	proof of an1s {
		step 1 : wff = theorem an12 () |- ( ( ps /\ ( ph /\ ch ) ) <-> ( ph /\ ( ps /\ ch ) ) ) ;
		step 2 : wff = theorem sylbi (step 1, hyp 1) |- ( ( ps /\ ( ph /\ ch ) ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Inference commuting a nested conjunction in antecedent.  */
	theorem ancom2s (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ch /\ ps ) ) -> th ) ;
	}

	/*  [25-May-2006]  */ /*  [24-May-2006]  */ 
	proof of ancom2s {
		step 1 : wff = theorem exp32 (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem com23 (step 1) |- ( ph -> ( ch -> ( ps -> th ) ) ) ;
		step 3 : wff = theorem imp32 (step 2) |- ( ( ph /\ ( ch /\ ps ) ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction rearranging conjuncts.  */
	theorem ancom13s (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ch /\ ( ps /\ ph ) ) -> th ) ;
	}

	/*  [31-May-2006]  */ /*  [31-May-2006]  */ 
	proof of ancom13s {
		step 1 : wff = theorem exp32 (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem com13 (step 1) |- ( ch -> ( ps -> ( ph -> th ) ) ) ;
		step 3 : wff = theorem imp32 (step 2) |- ( ( ch /\ ( ps /\ ph ) ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction rearranging conjuncts.  */
	theorem an1rs (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ch ) /\ ps ) -> th ) ;
	}

	/*  [13-Mar-1996]  */ 
	proof of an1rs {
		step 1 : wff = theorem an23 () |- ( ( ( ph /\ ch ) /\ ps ) <-> ( ( ph /\ ps ) /\ ch ) ) ;
		step 2 : wff = theorem sylbi (step 1, hyp 1) |- ( ( ( ph /\ ch ) /\ ps ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Inference commuting a nested conjunction in antecedent.  */
	theorem ancom1s (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ps /\ ph ) /\ ch ) -> th ) ;
	}

	/*  [25-May-2006]  */ /*  [24-May-2006]  */ 
	proof of ancom1s {
		step 1 : wff = theorem exp31 (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( ps -> ( ph -> ( ch -> th ) ) ) ;
		step 3 : wff = theorem imp31 (step 2) |- ( ( ( ps /\ ph ) /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction rearranging conjuncts.  */
	theorem ancom31s (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ch /\ ps ) /\ ph ) -> th ) ;
	}

	/*  [2-Jun-2006]  */ /*  [31-May-2006]  */ 
	proof of ancom31s {
		step 1 : wff = theorem exp31 (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem com13 (step 1) |- ( ch -> ( ps -> ( ph -> th ) ) ) ;
		step 3 : wff = theorem imp31 (step 2) |- ( ( ( ch /\ ps ) /\ ph ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Absorption into embedded conjunct.  */
	theorem anabs1 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) /\ ph ) <-> ( ph /\ ps ) ) ;
	}

	/*  [4-Sep-1995]  */ 
	proof of anabs1 {
		step 1 : wff = theorem pm3_26 () |- ( ( ( ph /\ ps ) /\ ph ) -> ( ph /\ ps ) ) ;
		step 2 : wff = theorem pm3_26 () |- ( ( ph /\ ps ) -> ph ) ;
		step 3 : wff = theorem ancli (step 2) |- ( ( ph /\ ps ) -> ( ( ph /\ ps ) /\ ph ) ) ;
		step 4 : wff = theorem impbi (step 1, step 3) |- ( ( ( ph /\ ps ) /\ ph ) <-> ( ph /\ ps ) ) ;
		qed prop = step 4 ;
	}

	/*  Absorption into embedded conjunct.  */
	theorem anabs5 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph /\ ( ph /\ ps ) ) <-> ( ph /\ ps ) ) ;
	}

	/*  [20-Jul-1996]  */ 
	proof of anabs5 {
		step 1 : wff = theorem ancom () |- ( ( ( ph /\ ps ) /\ ph ) <-> ( ph /\ ( ph /\ ps ) ) ) ;
		step 2 : wff = theorem anabs1 () |- ( ( ( ph /\ ps ) /\ ph ) <-> ( ph /\ ps ) ) ;
		step 3 : wff = theorem bitr3 (step 1, step 2) |- ( ( ph /\ ( ph /\ ps ) ) <-> ( ph /\ ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Absorption into embedded conjunct.  */
	theorem anabs7 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ps /\ ( ph /\ ps ) ) <-> ( ph /\ ps ) ) ;
	}

	/*  [20-Jul-1996]  */ 
	proof of anabs7 {
		step 1 : wff = theorem pm3_27 () |- ( ( ps /\ ( ph /\ ps ) ) -> ( ph /\ ps ) ) ;
		step 2 : wff = theorem pm3_27 () |- ( ( ph /\ ps ) -> ps ) ;
		step 3 : wff = theorem ancri (step 2) |- ( ( ph /\ ps ) -> ( ps /\ ( ph /\ ps ) ) ) ;
		step 4 : wff = theorem impbi (step 1, step 3) |- ( ( ps /\ ( ph /\ ps ) ) <-> ( ph /\ ps ) ) ;
		qed prop = step 4 ;
	}

	/*  Absorption of antecedent into conjunction.  */
	theorem anabsi5 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ph /\ ps ) -> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [11-Jun-1995]  */ 
	proof of anabsi5 {
		step 1 : wff = theorem adantr (hyp 1) |- ( ( ph /\ ps ) -> ( ( ph /\ ps ) -> ch ) ) ;
		step 2 : wff = theorem pm2_43i (step 1) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Absorption of antecedent into conjunction.  */
	theorem anabsi6 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ps /\ ph ) -> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [14-Aug-2000]  */ 
	proof of anabsi6 {
		step 1 : wff = theorem ancomsd (hyp 1) |- ( ph -> ( ( ph /\ ps ) -> ch ) ) ;
		step 2 : wff = theorem anabsi5 (step 1) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Absorption of antecedent into conjunction.  */
	theorem anabsi7 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ps -> ( ( ph /\ ps ) -> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [20-Jul-1996]  */ 
	proof of anabsi7 {
		step 1 : wff = theorem exp3a (hyp 1) |- ( ps -> ( ph -> ( ps -> ch ) ) ) ;
		step 2 : wff = theorem pm2_43b (step 1) |- ( ph -> ( ps -> ch ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 3 ;
	}

	/*  Absorption of antecedent into conjunction.  */
	theorem anabsi8 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ps -> ( ( ps /\ ph ) -> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [26-Sep-1999]  */ 
	proof of anabsi8 {
		step 1 : wff = theorem anabsi5 (hyp 1) |- ( ( ps /\ ph ) -> ch ) ;
		step 2 : wff = theorem ancoms (step 1) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Absorption of antecedent into conjunction.  */
	theorem anabss1 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ph ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [20-Jul-1996]  */ 
	proof of anabss1 {
		step 1 : wff = theorem adantrr (hyp 1) |- ( ( ( ph /\ ps ) /\ ( ph /\ ps ) ) -> ch ) ;
		step 2 : wff = theorem anidms (step 1) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Absorption of antecedent into conjunction.  */
	theorem anabss3 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [20-Jul-1996]  */ 
	proof of anabss3 {
		step 1 : wff = theorem adantrl (hyp 1) |- ( ( ( ph /\ ps ) /\ ( ph /\ ps ) ) -> ch ) ;
		step 2 : wff = theorem anidms (step 1) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Absorption of antecedent into conjunction.  */
	theorem anabss4 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ps /\ ph ) /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [20-Jul-1996]  */ 
	proof of anabss4 {
		step 1 : wff = theorem anabss1 (hyp 1) |- ( ( ps /\ ph ) -> ch ) ;
		step 2 : wff = theorem ancoms (step 1) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Absorption of antecedent into conjunction.  */
	theorem anabss5 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ph /\ ps ) ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [10-May-1994]  */ 
	proof of anabss5 {
		step 1 : wff = theorem adantlr (hyp 1) |- ( ( ( ph /\ ps ) /\ ( ph /\ ps ) ) -> ch ) ;
		step 2 : wff = theorem anidms (step 1) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Absorption of antecedent into conjunction.  */
	theorem anabss7 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ps /\ ( ph /\ ps ) ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [20-Jul-1996]  */ 
	proof of anabss7 {
		step 1 : wff = theorem ex (hyp 1) |- ( ps -> ( ( ph /\ ps ) -> ch ) ) ;
		step 2 : wff = theorem anabsi7 (step 1) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Absorption of antecedent with conjunction.  */
	theorem anabsan (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ph ) /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [24-Mar-1996]  */ 
	proof of anabsan {
		step 1 : wff = theorem an1rs (hyp 1) |- ( ( ( ph /\ ps ) /\ ph ) -> ch ) ;
		step 2 : wff = theorem anabss1 (step 1) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Absorption of antecedent with conjunction.  */
	theorem anabsan2 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ps ) ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [10-May-2004]  */ /*  [10-May-2004]  */ 
	proof of anabsan2 {
		step 1 : wff = theorem anassrs (hyp 1) |- ( ( ( ph /\ ps ) /\ ps ) -> ch ) ;
		step 2 : wff = theorem anabss3 (step 1) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Rearrangement of 4 conjuncts.  */
	theorem an4 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) /\ ( ch /\ th ) ) <-> ( ( ph /\ ch ) /\ ( ps /\ th ) ) ) ;
	}

	/*  [10-Jul-1994]  */ 
	proof of an4 {
		step 1 : wff = theorem an12 () |- ( ( ps /\ ( ch /\ th ) ) <-> ( ch /\ ( ps /\ th ) ) ) ;
		step 2 : wff = theorem anbi2i (step 1) |- ( ( ph /\ ( ps /\ ( ch /\ th ) ) ) <-> ( ph /\ ( ch /\ ( ps /\ th ) ) ) ) ;
		step 3 : wff = theorem anass () |- ( ( ( ph /\ ps ) /\ ( ch /\ th ) ) <-> ( ph /\ ( ps /\ ( ch /\ th ) ) ) ) ;
		step 4 : wff = theorem anass () |- ( ( ( ph /\ ch ) /\ ( ps /\ th ) ) <-> ( ph /\ ( ch /\ ( ps /\ th ) ) ) ) ;
		step 5 : wff = theorem _3bitr4 (step 2, step 3, step 4) |- ( ( ( ph /\ ps ) /\ ( ch /\ th ) ) <-> ( ( ph /\ ch ) /\ ( ps /\ th ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Rearrangement of 4 conjuncts.  */
	theorem an42 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) /\ ( ch /\ th ) ) <-> ( ( ph /\ ch ) /\ ( th /\ ps ) ) ) ;
	}

	/*  [7-Feb-1996]  */ 
	proof of an42 {
		step 1 : wff = theorem an4 () |- ( ( ( ph /\ ps ) /\ ( ch /\ th ) ) <-> ( ( ph /\ ch ) /\ ( ps /\ th ) ) ) ;
		step 2 : wff = theorem ancom () |- ( ( ps /\ th ) <-> ( th /\ ps ) ) ;
		step 3 : wff = theorem anbi2i (step 2) |- ( ( ( ph /\ ch ) /\ ( ps /\ th ) ) <-> ( ( ph /\ ch ) /\ ( th /\ ps ) ) ) ;
		step 4 : wff = theorem bitr (step 1, step 3) |- ( ( ( ph /\ ps ) /\ ( ch /\ th ) ) <-> ( ( ph /\ ch ) /\ ( th /\ ps ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Inference rearranging 4 conjuncts in antecedent.  */
	theorem an4s (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ( ch /\ th ) ) -> ta ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ch ) /\ ( ps /\ th ) ) -> ta ) ;
	}

	/*  [10-Aug-1995]  */ 
	proof of an4s {
		step 1 : wff = theorem an4 () |- ( ( ( ph /\ ch ) /\ ( ps /\ th ) ) <-> ( ( ph /\ ps ) /\ ( ch /\ th ) ) ) ;
		step 2 : wff = theorem sylbi (step 1, hyp 1) |- ( ( ( ph /\ ch ) /\ ( ps /\ th ) ) -> ta ) ;
		qed prop = step 2 ;
	}

	/*  Inference rearranging 4 conjuncts in antecedent.  */
	theorem an42s (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ( ch /\ th ) ) -> ta ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ch ) /\ ( th /\ ps ) ) -> ta ) ;
	}

	/*  [10-Aug-1995]  */ 
	proof of an42s {
		step 1 : wff = theorem an42 () |- ( ( ( ph /\ ps ) /\ ( ch /\ th ) ) <-> ( ( ph /\ ch ) /\ ( th /\ ps ) ) ) ;
		step 2 : wff = theorem sylbir (step 1, hyp 1) |- ( ( ( ph /\ ch ) /\ ( th /\ ps ) ) -> ta ) ;
		qed prop = step 2 ;
	}

	/*  Distribution of conjunction over conjunction.  */
	theorem anandi (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ( ps /\ ch ) ) <-> ( ( ph /\ ps ) /\ ( ph /\ ch ) ) ) ;
	}

	/*  [14-Aug-1995]  */ 
	proof of anandi {
		step 1 : wff = theorem anidm () |- ( ( ph /\ ph ) <-> ph ) ;
		step 2 : wff = theorem anbi1i (step 1) |- ( ( ( ph /\ ph ) /\ ( ps /\ ch ) ) <-> ( ph /\ ( ps /\ ch ) ) ) ;
		step 3 : wff = theorem an4 () |- ( ( ( ph /\ ph ) /\ ( ps /\ ch ) ) <-> ( ( ph /\ ps ) /\ ( ph /\ ch ) ) ) ;
		step 4 : wff = theorem bitr3 (step 2, step 3) |- ( ( ph /\ ( ps /\ ch ) ) <-> ( ( ph /\ ps ) /\ ( ph /\ ch ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Distribution of conjunction over conjunction.  */
	theorem anandir (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) /\ ch ) <-> ( ( ph /\ ch ) /\ ( ps /\ ch ) ) ) ;
	}

	/*  [24-Aug-1995]  */ 
	proof of anandir {
		step 1 : wff = theorem anidm () |- ( ( ch /\ ch ) <-> ch ) ;
		step 2 : wff = theorem anbi2i (step 1) |- ( ( ( ph /\ ps ) /\ ( ch /\ ch ) ) <-> ( ( ph /\ ps ) /\ ch ) ) ;
		step 3 : wff = theorem an4 () |- ( ( ( ph /\ ps ) /\ ( ch /\ ch ) ) <-> ( ( ph /\ ch ) /\ ( ps /\ ch ) ) ) ;
		step 4 : wff = theorem bitr3 (step 2, step 3) |- ( ( ( ph /\ ps ) /\ ch ) <-> ( ( ph /\ ch ) /\ ( ps /\ ch ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Inference that undistributes conjunction in the antecedent.  */
	theorem anandis (var ph : wff , var ps : wff , var ch : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ( ph /\ ch ) ) -> ta ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> ta ) ;
	}

	/*  [7-Jun-2004]  */ /*  [7-Jun-2004]  */ 
	proof of anandis {
		step 1 : wff = theorem an4s (hyp 1) |- ( ( ( ph /\ ph ) /\ ( ps /\ ch ) ) -> ta ) ;
		step 2 : wff = theorem anabsan (step 1) |- ( ( ph /\ ( ps /\ ch ) ) -> ta ) ;
		qed prop = step 2 ;
	}

	/*  Inference that undistributes conjunction in the antecedent.  */
	theorem anandirs (var ph : wff , var ps : wff , var ch : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ch ) /\ ( ps /\ ch ) ) -> ta ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> ta ) ;
	}

	/*  [8-Jun-2004]  */ /*  [7-Jun-2004]  */ 
	proof of anandirs {
		step 1 : wff = theorem an4s (hyp 1) |- ( ( ( ph /\ ps ) /\ ( ch /\ ch ) ) -> ta ) ;
		step 2 : wff = theorem anabsan2 (step 1) |- ( ( ( ph /\ ps ) /\ ch ) -> ta ) ;
		qed prop = step 2 ;
	}

	/*  A theorem similar to the standard definition of the biconditional.
	     Definition of [Margaris] p. 49.  */
	theorem bi (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph <-> ps ) <-> ( ( ph -> ps ) /\ ( ps -> ph ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bi {
		step 1 : wff = theorem bii () |- ( ( ph <-> ps ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ;
		step 2 : wff = definition df-an () |- ( ( ( ph -> ps ) /\ ( ps -> ph ) ) <-> -. ( ( ph -> ps ) -> -. ( ps -> ph ) ) ) ;
		step 3 : wff = theorem bitr4 (step 1, step 2) |- ( ( ph <-> ps ) <-> ( ( ph -> ps ) /\ ( ps -> ph ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Deduce an equivalence from two implications.  */
	theorem impbid (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ch -> ps ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps <-> ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of impbid {
		step 1 : wff = theorem jca (hyp 1, hyp 2) |- ( ph -> ( ( ps -> ch ) /\ ( ch -> ps ) ) ) ;
		step 2 : wff = theorem bi () |- ( ( ps <-> ch ) <-> ( ( ps -> ch ) /\ ( ch -> ps ) ) ) ;
		step 3 : wff = theorem sylibr (step 1, step 2) |- ( ph -> ( ps <-> ch ) ) ;
		qed prop = step 3 ;
	}

	/*  Infer an equivalence from two implications.  */
	theorem impbid1 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ch -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps <-> ch ) ) ;
	}

	/*  [7-Mar-2007]  */ /*  [6-Mar-2007]  */ 
	proof of impbid1 {
		step 1 : wff = theorem a1i (hyp 2) |- ( ph -> ( ch -> ps ) ) ;
		step 2 : wff = theorem impbid (hyp 1, step 1) |- ( ph -> ( ps <-> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Infer an equivalence from two implications.  */
	theorem impbid2 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ps -> ch ) ;
		hyp 2 : wff = |- ( ph -> ( ch -> ps ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps <-> ch ) ) ;
	}

	/*  [7-Mar-2007]  */ /*  [6-Mar-2007]  */ 
	proof of impbid2 {
		step 1 : wff = theorem a1i (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem impbid (step 1, hyp 2) |- ( ph -> ( ps <-> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduce an equivalence from two implications.  */
	theorem impbida (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( ( ph /\ ch ) -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps <-> ch ) ) ;
	}

	/*  [20-Feb-2007]  */ /*  [17-Feb-2007]  */ 
	proof of impbida {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem ex (hyp 2) |- ( ph -> ( ch -> ps ) ) ;
		step 3 : wff = theorem impbid (step 1, step 2) |- ( ph -> ( ps <-> ch ) ) ;
		qed prop = step 3 ;
	}

	/*  Commutative law for equivalence.  Theorem *4.21 of [WhiteheadRussell]
	     p. 117.  */
	theorem bicom (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph <-> ps ) <-> ( ps <-> ph ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bicom {
		step 1 : wff = theorem ancom () |- ( ( ( ph -> ps ) /\ ( ps -> ph ) ) <-> ( ( ps -> ph ) /\ ( ph -> ps ) ) ) ;
		step 2 : wff = theorem bi () |- ( ( ph <-> ps ) <-> ( ( ph -> ps ) /\ ( ps -> ph ) ) ) ;
		step 3 : wff = theorem bi () |- ( ( ps <-> ph ) <-> ( ( ps -> ph ) /\ ( ph -> ps ) ) ) ;
		step 4 : wff = theorem _3bitr4 (step 1, step 2, step 3) |- ( ( ph <-> ps ) <-> ( ps <-> ph ) ) ;
		qed prop = step 4 ;
	}

	/*  Commute two sides of a biconditional in a deduction.  */
	theorem bicomd (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ch <-> ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bicomd {
		step 1 : wff = theorem bicom () |- ( ( ps <-> ch ) <-> ( ch <-> ps ) ) ;
		step 2 : wff = theorem sylib (hyp 1, step 1) |- ( ph -> ( ch <-> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Contraposition.  Theorem *4.11 of [WhiteheadRussell] p. 117.  */
	theorem pm4_11 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph <-> ps ) <-> ( -. ph <-> -. ps ) ) ;
	}

	/*  [21-May-1994]  */ 
	proof of pm4_11 {
		step 1 : wff = theorem pm4_1 () |- ( ( ph -> ps ) <-> ( -. ps -> -. ph ) ) ;
		step 2 : wff = theorem pm4_1 () |- ( ( ps -> ph ) <-> ( -. ph -> -. ps ) ) ;
		step 3 : wff = theorem anbi12i (step 1, step 2) |- ( ( ( ph -> ps ) /\ ( ps -> ph ) ) <-> ( ( -. ps -> -. ph ) /\ ( -. ph -> -. ps ) ) ) ;
		step 4 : wff = theorem bi () |- ( ( ph <-> ps ) <-> ( ( ph -> ps ) /\ ( ps -> ph ) ) ) ;
		step 5 : wff = theorem bi () |- ( ( -. ps <-> -. ph ) <-> ( ( -. ps -> -. ph ) /\ ( -. ph -> -. ps ) ) ) ;
		step 6 : wff = theorem _3bitr4 (step 3, step 4, step 5) |- ( ( ph <-> ps ) <-> ( -. ps <-> -. ph ) ) ;
		step 7 : wff = theorem bicom () |- ( ( -. ps <-> -. ph ) <-> ( -. ph <-> -. ps ) ) ;
		step 8 : wff = theorem bitr (step 6, step 7) |- ( ( ph <-> ps ) <-> ( -. ph <-> -. ps ) ) ;
		qed prop = step 8 ;
	}

	/*  A contraposition inference.  */
	theorem con4bii (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( -. ph <-> -. ps ) ;
		-----------------
		prop : wff = |- ( ph <-> ps ) ;
	}

	/*  [21-May-1994]  */ 
	proof of con4bii {
		step 1 : wff = theorem pm4_11 () |- ( ( ph <-> ps ) <-> ( -. ph <-> -. ps ) ) ;
		step 2 : wff = theorem mpbir (hyp 1, step 1) |- ( ph <-> ps ) ;
		qed prop = step 2 ;
	}

	/*  A contraposition deduction.  */
	theorem con4bid (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( -. ps <-> -. ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps <-> ch ) ) ;
	}

	/*  [21-May-1994]  */ 
	proof of con4bid {
		step 1 : wff = theorem pm4_11 () |- ( ( ps <-> ch ) <-> ( -. ps <-> -. ch ) ) ;
		step 2 : wff = theorem sylibr (hyp 1, step 1) |- ( ph -> ( ps <-> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Contraposition.  Theorem *4.12 of [WhiteheadRussell] p. 117.  */
	theorem con2bi (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph <-> -. ps ) <-> ( ps <-> -. ph ) ) ;
	}

	/*  [15-Apr-1995]  */ 
	proof of con2bi {
		step 1 : wff = theorem bi2_03 () |- ( ( ph -> -. ps ) <-> ( ps -> -. ph ) ) ;
		step 2 : wff = theorem bi2_15 () |- ( ( -. ps -> ph ) <-> ( -. ph -> ps ) ) ;
		step 3 : wff = theorem anbi12i (step 1, step 2) |- ( ( ( ph -> -. ps ) /\ ( -. ps -> ph ) ) <-> ( ( ps -> -. ph ) /\ ( -. ph -> ps ) ) ) ;
		step 4 : wff = theorem bi () |- ( ( ph <-> -. ps ) <-> ( ( ph -> -. ps ) /\ ( -. ps -> ph ) ) ) ;
		step 5 : wff = theorem bi () |- ( ( ps <-> -. ph ) <-> ( ( ps -> -. ph ) /\ ( -. ph -> ps ) ) ) ;
		step 6 : wff = theorem _3bitr4 (step 3, step 4, step 5) |- ( ( ph <-> -. ps ) <-> ( ps <-> -. ph ) ) ;
		qed prop = step 6 ;
	}

	/*  A contraposition deduction.  */
	theorem con2bid (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> -. ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ch <-> -. ps ) ) ;
	}

	/*  [15-Apr-1995]  */ 
	proof of con2bid {
		step 1 : wff = theorem con2bi () |- ( ( ch <-> -. ps ) <-> ( ps <-> -. ch ) ) ;
		step 2 : wff = theorem sylibr (hyp 1, step 1) |- ( ph -> ( ch <-> -. ps ) ) ;
		qed prop = step 2 ;
	}

	/*  A contraposition deduction.  */
	theorem con1bid (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( -. ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( -. ch <-> ps ) ) ;
	}

	/*  [9-Oct-1999]  */ 
	proof of con1bid {
		step 1 : wff = theorem bicomd (hyp 1) |- ( ph -> ( ch <-> -. ps ) ) ;
		step 2 : wff = theorem con2bid (step 1) |- ( ph -> ( ps <-> -. ch ) ) ;
		step 3 : wff = theorem bicomd (step 2) |- ( ph -> ( -. ch <-> ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Deduction form of ~ bitr .  */
	theorem bitrd (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ch <-> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps <-> th ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bitrd {
		step 1 : wff = theorem biimpd (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem sylibd (step 1, hyp 2) |- ( ph -> ( ps -> th ) ) ;
		step 3 : wff = theorem biimprd (hyp 2) |- ( ph -> ( th -> ch ) ) ;
		step 4 : wff = theorem sylibrd (step 3, hyp 1) |- ( ph -> ( th -> ps ) ) ;
		step 5 : wff = theorem impbid (step 2, step 4) |- ( ph -> ( ps <-> th ) ) ;
		qed prop = step 5 ;
	}

	/*  Deduction form of ~ bitr2 .  */
	theorem bitr2d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ch <-> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( th <-> ps ) ) ;
	}

	/*  [11-Jun-2004]  */ /*  [9-Jun-2004]  */ 
	proof of bitr2d {
		step 1 : wff = theorem bitrd (hyp 1, hyp 2) |- ( ph -> ( ps <-> th ) ) ;
		step 2 : wff = theorem bicomd (step 1) |- ( ph -> ( th <-> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction form of ~ bitr3 .  */
	theorem bitr3d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ps <-> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ch <-> th ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bitr3d {
		step 1 : wff = theorem bicomd (hyp 1) |- ( ph -> ( ch <-> ps ) ) ;
		step 2 : wff = theorem bitrd (step 1, hyp 2) |- ( ph -> ( ch <-> th ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction form of ~ bitr4 .  */
	theorem bitr4d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps <-> th ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bitr4d {
		step 1 : wff = theorem bicomd (hyp 2) |- ( ph -> ( ch <-> th ) ) ;
		step 2 : wff = theorem bitrd (hyp 1, step 1) |- ( ph -> ( ps <-> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference from two biconditionals.  */
	theorem syl5bb (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( th <-> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( th <-> ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl5bb {
		step 1 : wff = theorem a1i (hyp 2) |- ( ph -> ( th <-> ps ) ) ;
		step 2 : wff = theorem bitrd (step 1, hyp 1) |- ( ph -> ( th <-> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference from two biconditionals.  */
	theorem syl5rbb (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( th <-> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( ch <-> th ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl5rbb {
		step 1 : wff = theorem syl5bb (hyp 1, hyp 2) |- ( ph -> ( th <-> ch ) ) ;
		step 2 : wff = theorem bicomd (step 1) |- ( ph -> ( ch <-> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference from two biconditionals.  */
	theorem syl5bbr (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ps <-> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( th <-> ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl5bbr {
		step 1 : wff = theorem bicomi (hyp 2) |- ( th <-> ps ) ;
		step 2 : wff = theorem syl5bb (hyp 1, step 1) |- ( ph -> ( th <-> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference from two biconditionals.  */
	theorem syl5rbbr (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ps <-> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( ch <-> th ) ) ;
	}

	/*  [25-Nov-1994]  */ 
	proof of syl5rbbr {
		step 1 : wff = theorem bicomi (hyp 2) |- ( th <-> ps ) ;
		step 2 : wff = theorem syl5rbb (hyp 1, step 1) |- ( ph -> ( ch <-> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference from two biconditionals.  */
	theorem syl6bb (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ch <-> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps <-> th ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl6bb {
		step 1 : wff = theorem a1i (hyp 2) |- ( ph -> ( ch <-> th ) ) ;
		step 2 : wff = theorem bitrd (hyp 1, step 1) |- ( ph -> ( ps <-> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference from two biconditionals.  */
	theorem syl6rbb (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ch <-> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( th <-> ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl6rbb {
		step 1 : wff = theorem syl6bb (hyp 1, hyp 2) |- ( ph -> ( ps <-> th ) ) ;
		step 2 : wff = theorem bicomd (step 1) |- ( ph -> ( th <-> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference from two biconditionals.  */
	theorem syl6bbr (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( th <-> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps <-> th ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of syl6bbr {
		step 1 : wff = theorem bicomi (hyp 2) |- ( ch <-> th ) ;
		step 2 : wff = theorem syl6bb (hyp 1, step 1) |- ( ph -> ( ps <-> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference from two biconditionals.  */
	theorem syl6rbbr (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( th <-> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ( th <-> ps ) ) ;
	}

	/*  [25-Nov-1994]  */ 
	proof of syl6rbbr {
		step 1 : wff = theorem bicomi (hyp 2) |- ( ch <-> th ) ;
		step 2 : wff = theorem syl6rbb (hyp 1, step 1) |- ( ph -> ( th <-> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Nested syllogism inference conjoining dissimilar antecedents.  */
	theorem sylan9bb (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( th -> ( ch <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ th ) -> ( ps <-> ta ) ) ;
	}

	/*  [4-Mar-1995]  */ 
	proof of sylan9bb {
		step 1 : wff = theorem adantr (hyp 1) |- ( ( ph /\ th ) -> ( ps <-> ch ) ) ;
		step 2 : wff = theorem adantl (hyp 2) |- ( ( ph /\ th ) -> ( ch <-> ta ) ) ;
		step 3 : wff = theorem bitrd (step 1, step 2) |- ( ( ph /\ th ) -> ( ps <-> ta ) ) ;
		qed prop = step 3 ;
	}

	/*  Nested syllogism inference conjoining dissimilar antecedents.  */
	theorem sylan9bbr (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( th -> ( ch <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ( th /\ ph ) -> ( ps <-> ta ) ) ;
	}

	/*  [4-Mar-1995]  */ 
	proof of sylan9bbr {
		step 1 : wff = theorem sylan9bb (hyp 1, hyp 2) |- ( ( ph /\ th ) -> ( ps <-> ta ) ) ;
		step 2 : wff = theorem ancoms (step 1) |- ( ( th /\ ph ) -> ( ps <-> ta ) ) ;
		qed prop = step 2 ;
	}

	/*  More general version of ~ 3imtr3 .  Useful for converting
	       conditional definitions in a formula.  */
	theorem _3imtr3d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ps <-> th ) ) ;
		hyp 3 : wff = |- ( ph -> ( ch <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( th -> ta ) ) ;
	}

	/*  [8-Apr-1996]  */ 
	proof of _3imtr3d {
		step 1 : wff = theorem sylibd (hyp 1, hyp 3) |- ( ph -> ( ps -> ta ) ) ;
		step 2 : wff = theorem sylbird (hyp 2, step 1) |- ( ph -> ( th -> ta ) ) ;
		qed prop = step 2 ;
	}

	/*  More general version of ~ 3imtr4 .  Useful for converting
	       conditional definitions in a formula.  */
	theorem _3imtr4d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th <-> ps ) ) ;
		hyp 3 : wff = |- ( ph -> ( ta <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( th -> ta ) ) ;
	}

	/*  [26-Oct-1995]  */ 
	proof of _3imtr4d {
		step 1 : wff = theorem sylibrd (hyp 1, hyp 3) |- ( ph -> ( ps -> ta ) ) ;
		step 2 : wff = theorem sylbid (hyp 2, step 1) |- ( ph -> ( th -> ta ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction from transitivity of biconditional.  */
	theorem _3bitrd (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ch <-> th ) ) ;
		hyp 3 : wff = |- ( ph -> ( th <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps <-> ta ) ) ;
	}

	/*  [13-Aug-1999]  */ 
	proof of _3bitrd {
		step 1 : wff = theorem bitrd (hyp 1, hyp 2) |- ( ph -> ( ps <-> th ) ) ;
		step 2 : wff = theorem bitrd (step 1, hyp 3) |- ( ph -> ( ps <-> ta ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction from transitivity of biconditional.  */
	theorem _3bitrrd (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ch <-> th ) ) ;
		hyp 3 : wff = |- ( ph -> ( th <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ta <-> ps ) ) ;
	}

	/*  [11-Aug-2006]  */ /*  [4-Aug-2006]  */ 
	proof of _3bitrrd {
		step 1 : wff = theorem bitr2d (hyp 1, hyp 2) |- ( ph -> ( th <-> ps ) ) ;
		step 2 : wff = theorem bitr3d (hyp 3, step 1) |- ( ph -> ( ta <-> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction from transitivity of biconditional.  */
	theorem _3bitr2d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th <-> ch ) ) ;
		hyp 3 : wff = |- ( ph -> ( th <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps <-> ta ) ) ;
	}

	/*  [11-Aug-2006]  */ /*  [4-Aug-2006]  */ 
	proof of _3bitr2d {
		step 1 : wff = theorem bitr4d (hyp 1, hyp 2) |- ( ph -> ( ps <-> th ) ) ;
		step 2 : wff = theorem bitrd (step 1, hyp 3) |- ( ph -> ( ps <-> ta ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction from transitivity of biconditional.  */
	theorem _3bitr2rd (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th <-> ch ) ) ;
		hyp 3 : wff = |- ( ph -> ( th <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ta <-> ps ) ) ;
	}

	/*  [11-Aug-2006]  */ /*  [4-Aug-2006]  */ 
	proof of _3bitr2rd {
		step 1 : wff = theorem bitr4d (hyp 1, hyp 2) |- ( ph -> ( ps <-> th ) ) ;
		step 2 : wff = theorem bitr2d (step 1, hyp 3) |- ( ph -> ( ta <-> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction from transitivity of biconditional.  Useful for converting
	       conditional definitions in a formula.  */
	theorem _3bitr3d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ps <-> th ) ) ;
		hyp 3 : wff = |- ( ph -> ( ch <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( th <-> ta ) ) ;
	}

	/*  [24-Apr-1996]  */ 
	proof of _3bitr3d {
		step 1 : wff = theorem bitr3d (hyp 2, hyp 1) |- ( ph -> ( th <-> ch ) ) ;
		step 2 : wff = theorem bitrd (step 1, hyp 3) |- ( ph -> ( th <-> ta ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction from transitivity of biconditional.  */
	theorem _3bitr3rd (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ps <-> th ) ) ;
		hyp 3 : wff = |- ( ph -> ( ch <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ta <-> th ) ) ;
	}

	/*  [11-Aug-2006]  */ /*  [4-Aug-2006]  */ 
	proof of _3bitr3rd {
		step 1 : wff = theorem bitr3d (hyp 1, hyp 2) |- ( ph -> ( ch <-> th ) ) ;
		step 2 : wff = theorem bitr3d (hyp 3, step 1) |- ( ph -> ( ta <-> th ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction from transitivity of biconditional.  Useful for converting
	       conditional definitions in a formula.  */
	theorem _3bitr4d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th <-> ps ) ) ;
		hyp 3 : wff = |- ( ph -> ( ta <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( th <-> ta ) ) ;
	}

	/*  [18-Oct-1995]  */ 
	proof of _3bitr4d {
		step 1 : wff = theorem bitr4d (hyp 1, hyp 3) |- ( ph -> ( ps <-> ta ) ) ;
		step 2 : wff = theorem bitrd (hyp 2, step 1) |- ( ph -> ( th <-> ta ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction from transitivity of biconditional.  */
	theorem _3bitr4rd (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th <-> ps ) ) ;
		hyp 3 : wff = |- ( ph -> ( ta <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ta <-> th ) ) ;
	}

	/*  [11-Aug-2006]  */ /*  [4-Aug-2006]  */ 
	proof of _3bitr4rd {
		step 1 : wff = theorem bitr4d (hyp 3, hyp 1) |- ( ph -> ( ta <-> ps ) ) ;
		step 2 : wff = theorem bitr4d (step 1, hyp 2) |- ( ph -> ( ta <-> th ) ) ;
		qed prop = step 2 ;
	}

	/*  More general version of ~ 3imtr3 .  Useful for converting
	       definitions in a formula.  */
	theorem _3imtr3g (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ps <-> th ) ;
		hyp 3 : wff = |- ( ch <-> ta ) ;
		-----------------
		prop : wff = |- ( ph -> ( th -> ta ) ) ;
	}

	/*  [20-May-1996]  */ 
	proof of _3imtr3g {
		step 1 : wff = theorem imp (hyp 1) |- ( ( ph /\ ps ) -> ch ) ;
		step 2 : wff = theorem anbi2i (hyp 2) |- ( ( ph /\ ps ) <-> ( ph /\ th ) ) ;
		step 3 : wff = theorem _3imtr3 (step 1, step 2, hyp 3) |- ( ( ph /\ th ) -> ta ) ;
		step 4 : wff = theorem ex (step 3) |- ( ph -> ( th -> ta ) ) ;
		qed prop = step 4 ;
	}

	/*  More general version of ~ 3imtr4 .  Useful for converting
	       definitions in a formula.  */
	theorem _3imtr4g (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( th <-> ps ) ;
		hyp 3 : wff = |- ( ta <-> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ( th -> ta ) ) ;
	}

	/*  [20-May-1996]  */ 
	proof of _3imtr4g {
		step 1 : wff = theorem bicomi (hyp 2) |- ( ps <-> th ) ;
		step 2 : wff = theorem bicomi (hyp 3) |- ( ch <-> ta ) ;
		step 3 : wff = theorem _3imtr3g (hyp 1, step 1, step 2) |- ( ph -> ( th -> ta ) ) ;
		qed prop = step 3 ;
	}

	/*  More general version of ~ 3bitr3 .  Useful for converting
	       definitions in a formula.  */
	theorem _3bitr3g (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ps <-> th ) ;
		hyp 3 : wff = |- ( ch <-> ta ) ;
		-----------------
		prop : wff = |- ( ph -> ( th <-> ta ) ) ;
	}

	/*  [4-Jun-1995]  */ 
	proof of _3bitr3g {
		step 1 : wff = theorem syl5bbr (hyp 1, hyp 2) |- ( ph -> ( th <-> ch ) ) ;
		step 2 : wff = theorem syl6bb (step 1, hyp 3) |- ( ph -> ( th <-> ta ) ) ;
		qed prop = step 2 ;
	}

	/*  More general version of ~ 3bitr4 .  Useful for converting
	       definitions in a formula.  */
	theorem _3bitr4g (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( th <-> ps ) ;
		hyp 3 : wff = |- ( ta <-> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ( th <-> ta ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of _3bitr4g {
		step 1 : wff = theorem syl5bb (hyp 1, hyp 2) |- ( ph -> ( th <-> ch ) ) ;
		step 2 : wff = theorem syl6bbr (step 1, hyp 3) |- ( ph -> ( th <-> ta ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *3.47 of [WhiteheadRussell] p. 113.  It was proved by Leibniz, and
	     it evidently pleased him enough to call it 'praeclarum theorema.'  */
	theorem prth (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) /\ ( ch -> th ) ) -> ( ( ph /\ ch ) -> ( ps /\ th ) ) ) ;
	}

	/*  [12-Aug-1993]  */ 
	proof of prth {
		step 1 : wff = theorem pm3_2 () |- ( ps -> ( th -> ( ps /\ th ) ) ) ;
		step 2 : wff = theorem imim2d (step 1) |- ( ps -> ( ( ch -> th ) -> ( ch -> ( ps /\ th ) ) ) ) ;
		step 3 : wff = theorem imim2i (step 2) |- ( ( ph -> ps ) -> ( ph -> ( ( ch -> th ) -> ( ch -> ( ps /\ th ) ) ) ) ) ;
		step 4 : wff = theorem com23 (step 3) |- ( ( ph -> ps ) -> ( ( ch -> th ) -> ( ph -> ( ch -> ( ps /\ th ) ) ) ) ) ;
		step 5 : wff = theorem imp4b (step 4) |- ( ( ( ph -> ps ) /\ ( ch -> th ) ) -> ( ( ph /\ ch ) -> ( ps /\ th ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Theorem *3.48 of [WhiteheadRussell] p. 114.  */
	theorem pm3_48 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) /\ ( ch -> th ) ) -> ( ( ph \/ ch ) -> ( ps \/ th ) ) ) ;
	}

	/*  [28-Jan-1997]  */ 
	proof of pm3_48 {
		step 1 : wff = theorem pm3_26 () |- ( ( ( ph -> ps ) /\ ( ch -> th ) ) -> ( ph -> ps ) ) ;
		step 2 : wff = theorem con3d (step 1) |- ( ( ( ph -> ps ) /\ ( ch -> th ) ) -> ( -. ps -> -. ph ) ) ;
		step 3 : wff = theorem pm3_27 () |- ( ( ( ph -> ps ) /\ ( ch -> th ) ) -> ( ch -> th ) ) ;
		step 4 : wff = theorem imim12d (step 2, step 3) |- ( ( ( ph -> ps ) /\ ( ch -> th ) ) -> ( ( -. ph -> ch ) -> ( -. ps -> th ) ) ) ;
		step 5 : wff = definition df-or () |- ( ( ph \/ ch ) <-> ( -. ph -> ch ) ) ;
		step 6 : wff = definition df-or () |- ( ( ps \/ th ) <-> ( -. ps -> th ) ) ;
		step 7 : wff = theorem _3imtr4g (step 4, step 5, step 6) |- ( ( ( ph -> ps ) /\ ( ch -> th ) ) -> ( ( ph \/ ch ) -> ( ps \/ th ) ) ) ;
		qed prop = step 7 ;
	}

	/*  Conjoin antecedents and consequents in a deduction.  */
	theorem anim12d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th -> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ th ) -> ( ch /\ ta ) ) ) ;
	}

	/*  [3-Apr-1994]  */ 
	proof of anim12d {
		step 1 : wff = theorem prth () |- ( ( ( ps -> ch ) /\ ( th -> ta ) ) -> ( ( ps /\ th ) -> ( ch /\ ta ) ) ) ;
		step 2 : wff = theorem sylanc (step 1, hyp 1, hyp 2) |- ( ph -> ( ( ps /\ th ) -> ( ch /\ ta ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Conjoin antecedents and consequents in a deduction.  */
	theorem anim12ii (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( th -> ( ps -> ta ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ th ) -> ( ps -> ( ch /\ ta ) ) ) ;
	}

	/*  [12-Nov-2007]  */ /*  [11-Nov-2007]  */ 
	proof of anim12ii {
		step 1 : wff = theorem com12 (hyp 1) |- ( ps -> ( ph -> ch ) ) ;
		step 2 : wff = theorem com12 (hyp 2) |- ( ps -> ( th -> ta ) ) ;
		step 3 : wff = theorem anim12d (step 1, step 2) |- ( ps -> ( ( ph /\ th ) -> ( ch /\ ta ) ) ) ;
		step 4 : wff = theorem com12 (step 3) |- ( ( ph /\ th ) -> ( ps -> ( ch /\ ta ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Add a conjunct to right of antecedent and consequent in a deduction.  */
	theorem anim1d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ th ) -> ( ch /\ th ) ) ) ;
	}

	/*  [3-Apr-1994]  */ 
	proof of anim1d {
		step 1 : wff = theorem idd () |- ( ph -> ( th -> th ) ) ;
		step 2 : wff = theorem anim12d (hyp 1, step 1) |- ( ph -> ( ( ps /\ th ) -> ( ch /\ th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Add a conjunct to left of antecedent and consequent in a deduction.  */
	theorem anim2d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( th /\ ps ) -> ( th /\ ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of anim2d {
		step 1 : wff = theorem idd () |- ( ph -> ( th -> th ) ) ;
		step 2 : wff = theorem anim12d (step 1, hyp 1) |- ( ph -> ( ( th /\ ps ) -> ( th /\ ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *3.45 (Fact) of [WhiteheadRussell] p. 113.  */
	theorem pm3_45 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( ph /\ ch ) -> ( ps /\ ch ) ) ) ;
	}

	/*  [17-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm3_45 {
		step 1 : wff = theorem id () |- ( ( ph -> ps ) -> ( ph -> ps ) ) ;
		step 2 : wff = theorem anim1d (step 1) |- ( ( ph -> ps ) -> ( ( ph /\ ch ) -> ( ps /\ ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction joining nested implications to form implication of
	       conjunctions.  */
	theorem im2anan9 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( th -> ( ta -> et ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ th ) -> ( ( ps /\ ta ) -> ( ch /\ et ) ) ) ;
	}

	/*  [29-Feb-1996]  */ 
	proof of im2anan9 {
		step 1 : wff = theorem adantr (hyp 1) |- ( ( ph /\ th ) -> ( ps -> ch ) ) ;
		step 2 : wff = theorem adantl (hyp 2) |- ( ( ph /\ th ) -> ( ta -> et ) ) ;
		step 3 : wff = theorem anim12d (step 1, step 2) |- ( ( ph /\ th ) -> ( ( ps /\ ta ) -> ( ch /\ et ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Deduction joining nested implications to form implication of
	       conjunctions.  */
	theorem im2anan9r (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( th -> ( ta -> et ) ) ;
		-----------------
		prop : wff = |- ( ( th /\ ph ) -> ( ( ps /\ ta ) -> ( ch /\ et ) ) ) ;
	}

	/*  [29-Feb-1996]  */ 
	proof of im2anan9r {
		step 1 : wff = theorem adantl (hyp 1) |- ( ( th /\ ph ) -> ( ps -> ch ) ) ;
		step 2 : wff = theorem adantr (hyp 2) |- ( ( th /\ ph ) -> ( ta -> et ) ) ;
		step 3 : wff = theorem anim12d (step 1, step 2) |- ( ( th /\ ph ) -> ( ( ps /\ ta ) -> ( ch /\ et ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Disjoin antecedents and consequents in a deduction.  */
	theorem orim12d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th -> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps \/ th ) -> ( ch \/ ta ) ) ) ;
	}

	/*  [10-May-1994]  */ 
	proof of orim12d {
		step 1 : wff = theorem pm3_48 () |- ( ( ( ps -> ch ) /\ ( th -> ta ) ) -> ( ( ps \/ th ) -> ( ch \/ ta ) ) ) ;
		step 2 : wff = theorem sylanc (step 1, hyp 1, hyp 2) |- ( ph -> ( ( ps \/ th ) -> ( ch \/ ta ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Disjoin antecedents and consequents in a deduction.  */
	theorem orim1d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps \/ th ) -> ( ch \/ th ) ) ) ;
	}

	/*  [23-Apr-1995]  */ 
	proof of orim1d {
		step 1 : wff = theorem idd () |- ( ph -> ( th -> th ) ) ;
		step 2 : wff = theorem orim12d (hyp 1, step 1) |- ( ph -> ( ( ps \/ th ) -> ( ch \/ th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Disjoin antecedents and consequents in a deduction.  */
	theorem orim2d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( th \/ ps ) -> ( th \/ ch ) ) ) ;
	}

	/*  [23-Apr-1995]  */ 
	proof of orim2d {
		step 1 : wff = theorem idd () |- ( ph -> ( th -> th ) ) ;
		step 2 : wff = theorem orim12d (step 1, hyp 1) |- ( ph -> ( ( th \/ ps ) -> ( th \/ ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Axiom *1.6 (Sum) of [WhiteheadRussell] p. 97.  */
	theorem orim2 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ps -> ch ) -> ( ( ph \/ ps ) -> ( ph \/ ch ) ) ) ;
	}

	/*  [16-May-2005]  */ /*  [3-Jan-2005]  */ 
	proof of orim2 {
		step 1 : wff = theorem id () |- ( ( ps -> ch ) -> ( ps -> ch ) ) ;
		step 2 : wff = theorem orim2d (step 1) |- ( ( ps -> ch ) -> ( ( ph \/ ps ) -> ( ph \/ ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.38 of [WhiteheadRussell] p. 105.  */
	theorem pm2_38 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ps -> ch ) -> ( ( ps \/ ph ) -> ( ch \/ ph ) ) ) ;
	}

	/*  [6-Mar-2008]  */ /*  [6-Mar-2008]  */ 
	proof of pm2_38 {
		step 1 : wff = theorem id () |- ( ( ps -> ch ) -> ( ps -> ch ) ) ;
		step 2 : wff = theorem orim1d (step 1) |- ( ( ps -> ch ) -> ( ( ps \/ ph ) -> ( ch \/ ph ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.36 of [WhiteheadRussell] p. 105.  */
	theorem pm2_36 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ps -> ch ) -> ( ( ph \/ ps ) -> ( ch \/ ph ) ) ) ;
	}

	/*  [6-Mar-2008]  */ /*  [6-Mar-2008]  */ 
	proof of pm2_36 {
		step 1 : wff = theorem pm2_38 () |- ( ( ps -> ch ) -> ( ( ps \/ ph ) -> ( ch \/ ph ) ) ) ;
		step 2 : wff = theorem pm1_4 () |- ( ( ph \/ ps ) -> ( ps \/ ph ) ) ;
		step 3 : wff = theorem syl5 (step 1, step 2) |- ( ( ps -> ch ) -> ( ( ph \/ ps ) -> ( ch \/ ph ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.37 of [WhiteheadRussell] p. 105.  */
	theorem pm2_37 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ps -> ch ) -> ( ( ps \/ ph ) -> ( ph \/ ch ) ) ) ;
	}

	/*  [6-Mar-2008]  */ /*  [6-Mar-2008]  */ 
	proof of pm2_37 {
		step 1 : wff = theorem pm2_38 () |- ( ( ps -> ch ) -> ( ( ps \/ ph ) -> ( ch \/ ph ) ) ) ;
		step 2 : wff = theorem pm1_4 () |- ( ( ch \/ ph ) -> ( ph \/ ch ) ) ;
		step 3 : wff = theorem syl6 (step 1, step 2) |- ( ( ps -> ch ) -> ( ( ps \/ ph ) -> ( ph \/ ch ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.73 of [WhiteheadRussell] p. 108.  */
	theorem pm2_73 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( ( ph \/ ps ) \/ ch ) -> ( ps \/ ch ) ) ) ;
	}

	/*  [29-Apr-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_73 {
		step 1 : wff = theorem pm2_621 () |- ( ( ph -> ps ) -> ( ( ph \/ ps ) -> ps ) ) ;
		step 2 : wff = theorem orim1d (step 1) |- ( ( ph -> ps ) -> ( ( ( ph \/ ps ) \/ ch ) -> ( ps \/ ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.74 of [WhiteheadRussell] p. 108.  */
	theorem pm2_74 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ps -> ph ) -> ( ( ( ph \/ ps ) \/ ch ) -> ( ph \/ ch ) ) ) ;
	}

	/*  [9-May-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_74 {
		step 1 : wff = theorem orel2 () |- ( -. ps -> ( ( ph \/ ps ) -> ph ) ) ;
		step 2 : wff = theorem orim1d (step 1) |- ( -. ps -> ( ( ( ph \/ ps ) \/ ch ) -> ( ph \/ ch ) ) ) ;
		step 3 : wff = theorem orc () |- ( ph -> ( ph \/ ch ) ) ;
		step 4 : wff = theorem a1d (step 3) |- ( ph -> ( ( ( ph \/ ps ) \/ ch ) -> ( ph \/ ch ) ) ) ;
		step 5 : wff = theorem ja (step 2, step 4) |- ( ( ps -> ph ) -> ( ( ( ph \/ ps ) \/ ch ) -> ( ph \/ ch ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Theorem *2.75 of [WhiteheadRussell] p. 108.  */
	theorem pm2_75 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph \/ ps ) -> ( ( ph \/ ( ps -> ch ) ) -> ( ph \/ ch ) ) ) ;
	}

	/*  [14-May-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_75 {
		step 1 : wff = theorem orc () |- ( ph -> ( ph \/ ch ) ) ;
		step 2 : wff = theorem a1d (step 1) |- ( ph -> ( ( ph \/ ( ps -> ch ) ) -> ( ph \/ ch ) ) ) ;
		step 3 : wff = theorem pm2_27 () |- ( ps -> ( ( ps -> ch ) -> ch ) ) ;
		step 4 : wff = theorem orim2d (step 3) |- ( ps -> ( ( ph \/ ( ps -> ch ) ) -> ( ph \/ ch ) ) ) ;
		step 5 : wff = theorem jaoi (step 2, step 4) |- ( ( ph \/ ps ) -> ( ( ph \/ ( ps -> ch ) ) -> ( ph \/ ch ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Theorem *2.76 of [WhiteheadRussell] p. 108.  */
	theorem pm2_76 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph \/ ( ps -> ch ) ) -> ( ( ph \/ ps ) -> ( ph \/ ch ) ) ) ;
	}

	/*  [16-May-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_76 {
		step 1 : wff = theorem pm2_75 () |- ( ( ph \/ ps ) -> ( ( ph \/ ( ps -> ch ) ) -> ( ph \/ ch ) ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( ( ph \/ ( ps -> ch ) ) -> ( ( ph \/ ps ) -> ( ph \/ ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.8 of [WhiteheadRussell] p. 108.  */
	theorem pm2_8 (var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ps \/ ch ) -> ( ( -. ch \/ th ) -> ( ps \/ th ) ) ) ;
	}

	/*  [16-May-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_8 {
		step 1 : wff = theorem orc () |- ( ps -> ( ps \/ th ) ) ;
		step 2 : wff = theorem a1d (step 1) |- ( ps -> ( ( -. ch \/ th ) -> ( ps \/ th ) ) ) ;
		step 3 : wff = theorem pm2_24 () |- ( ch -> ( -. ch -> ps ) ) ;
		step 4 : wff = theorem orim1d (step 3) |- ( ch -> ( ( -. ch \/ th ) -> ( ps \/ th ) ) ) ;
		step 5 : wff = theorem jaoi (step 2, step 4) |- ( ( ps \/ ch ) -> ( ( -. ch \/ th ) -> ( ps \/ th ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Theorem *2.81 of [WhiteheadRussell] p. 108.  */
	theorem pm2_81 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ps -> ( ch -> th ) ) -> ( ( ph \/ ps ) -> ( ( ph \/ ch ) -> ( ph \/ th ) ) ) ) ;
	}

	/*  [17-May-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_81 {
		step 1 : wff = theorem orim2 () |- ( ( ps -> ( ch -> th ) ) -> ( ( ph \/ ps ) -> ( ph \/ ( ch -> th ) ) ) ) ;
		step 2 : wff = theorem pm2_76 () |- ( ( ph \/ ( ch -> th ) ) -> ( ( ph \/ ch ) -> ( ph \/ th ) ) ) ;
		step 3 : wff = theorem syl6 (step 1, step 2) |- ( ( ps -> ( ch -> th ) ) -> ( ( ph \/ ps ) -> ( ( ph \/ ch ) -> ( ph \/ th ) ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.82 of [WhiteheadRussell] p. 108.  */
	theorem pm2_82 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ps ) \/ ch ) -> ( ( ( ph \/ -. ch ) \/ th ) -> ( ( ph \/ ps ) \/ th ) ) ) ;
	}

	/*  [18-May-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_82 {
		step 1 : wff = axiom ax-1 () |- ( ( ph \/ ps ) -> ( ( ph \/ -. ch ) -> ( ph \/ ps ) ) ) ;
		step 2 : wff = theorem pm2_24 () |- ( ch -> ( -. ch -> ps ) ) ;
		step 3 : wff = theorem orim2d (step 2) |- ( ch -> ( ( ph \/ -. ch ) -> ( ph \/ ps ) ) ) ;
		step 4 : wff = theorem jaoi (step 1, step 3) |- ( ( ( ph \/ ps ) \/ ch ) -> ( ( ph \/ -. ch ) -> ( ph \/ ps ) ) ) ;
		step 5 : wff = theorem orim1d (step 4) |- ( ( ( ph \/ ps ) \/ ch ) -> ( ( ( ph \/ -. ch ) \/ th ) -> ( ( ph \/ ps ) \/ th ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Theorem *2.85 of [WhiteheadRussell] p. 108.  */
	theorem pm2_85 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ps ) -> ( ph \/ ch ) ) -> ( ph \/ ( ps -> ch ) ) ) ;
	}

	/*  [9-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_85 {
		step 1 : wff = theorem imor () |- ( ( ( ph \/ ps ) -> ( ph \/ ch ) ) <-> ( -. ( ph \/ ps ) \/ ( ph \/ ch ) ) ) ;
		step 2 : wff = theorem pm2_48 () |- ( -. ( ph \/ ps ) -> ( ph \/ -. ps ) ) ;
		step 3 : wff = theorem orim1i (step 2) |- ( ( -. ( ph \/ ps ) \/ ( ph \/ ch ) ) -> ( ( ph \/ -. ps ) \/ ( ph \/ ch ) ) ) ;
		step 4 : wff = theorem sylbi (step 1, step 3) |- ( ( ( ph \/ ps ) -> ( ph \/ ch ) ) -> ( ( ph \/ -. ps ) \/ ( ph \/ ch ) ) ) ;
		step 5 : wff = theorem imor () |- ( ( ps -> ch ) <-> ( -. ps \/ ch ) ) ;
		step 6 : wff = theorem orbi2i (step 5) |- ( ( ph \/ ( ps -> ch ) ) <-> ( ph \/ ( -. ps \/ ch ) ) ) ;
		step 7 : wff = theorem orordi () |- ( ( ph \/ ( -. ps \/ ch ) ) <-> ( ( ph \/ -. ps ) \/ ( ph \/ ch ) ) ) ;
		step 8 : wff = theorem bitr2 (step 6, step 7) |- ( ( ( ph \/ -. ps ) \/ ( ph \/ ch ) ) <-> ( ph \/ ( ps -> ch ) ) ) ;
		step 9 : wff = theorem sylib (step 4, step 8) |- ( ( ( ph \/ ps ) -> ( ph \/ ch ) ) -> ( ph \/ ( ps -> ch ) ) ) ;
		qed prop = step 9 ;
	}

	/*  Infer negated disjunction of negated premises.  */
	theorem pm3_2ni (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- -. ph ;
		hyp 2 : wff = |- -. ps ;
		-----------------
		prop : wff = |- -. ( ph \/ ps ) ;
	}

	/*  [4-Apr-1995]  */ 
	proof of pm3_2ni {
		step 1 : wff = theorem pm3_2i (hyp 1, hyp 2) |- ( -. ph /\ -. ps ) ;
		step 2 : wff = theorem ioran () |- ( -. ( ph \/ ps ) <-> ( -. ph /\ -. ps ) ) ;
		step 3 : wff = theorem mpbir (step 1, step 2) |- -. ( ph \/ ps ) ;
		qed prop = step 3 ;
	}

	/*  Absorption of redundant internal disjunct.  Compare Theorem *4.45
	     of [WhiteheadRussell] p. 119.  */
	theorem orabs (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph <-> ( ( ph \/ ps ) /\ ph ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of orabs {
		step 1 : wff = theorem orc () |- ( ph -> ( ph \/ ps ) ) ;
		step 2 : wff = theorem ancri (step 1) |- ( ph -> ( ( ph \/ ps ) /\ ph ) ) ;
		step 3 : wff = theorem pm3_27 () |- ( ( ( ph \/ ps ) /\ ph ) -> ph ) ;
		step 4 : wff = theorem impbi (step 2, step 3) |- ( ph <-> ( ( ph \/ ps ) /\ ph ) ) ;
		qed prop = step 4 ;
	}

	/*  Absorb a disjunct into a conjunct.  (Contributed by Roy F. Longton
	     23-Jun-2005.)  */
	theorem oranabs (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ -. ps ) /\ ps ) <-> ( ph /\ ps ) ) ;
	}

	/*  [24-Jun-2005]  */ /*  [23-Jun-2005]  */ 
	proof of oranabs {
		step 1 : wff = theorem pm3_2 () |- ( ph -> ( ps -> ( ph /\ ps ) ) ) ;
		step 2 : wff = theorem pm2_21 () |- ( -. ps -> ( ps -> ( ph /\ ps ) ) ) ;
		step 3 : wff = theorem jaoi (step 1, step 2) |- ( ( ph \/ -. ps ) -> ( ps -> ( ph /\ ps ) ) ) ;
		step 4 : wff = theorem imp (step 3) |- ( ( ( ph \/ -. ps ) /\ ps ) -> ( ph /\ ps ) ) ;
		step 5 : wff = theorem orc () |- ( ph -> ( ph \/ -. ps ) ) ;
		step 6 : wff = theorem anim1i (step 5) |- ( ( ph /\ ps ) -> ( ( ph \/ -. ps ) /\ ps ) ) ;
		step 7 : wff = theorem impbi (step 4, step 6) |- ( ( ( ph \/ -. ps ) /\ ps ) <-> ( ph /\ ps ) ) ;
		qed prop = step 7 ;
	}

	/*  Distribution of implication over biconditional.  Theorem *5.74 of
	     [WhiteheadRussell] p. 126.  */
	theorem pm5_74 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ps <-> ch ) ) <-> ( ( ph -> ps ) <-> ( ph -> ch ) ) ) ;
	}

	/*  [1-Aug-1994]  */ 
	proof of pm5_74 {
		step 1 : wff = theorem bi1 () |- ( ( ps <-> ch ) -> ( ps -> ch ) ) ;
		step 2 : wff = theorem imim3i (step 1) |- ( ( ph -> ( ps <-> ch ) ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ;
		step 3 : wff = theorem bi2 () |- ( ( ps <-> ch ) -> ( ch -> ps ) ) ;
		step 4 : wff = theorem imim3i (step 3) |- ( ( ph -> ( ps <-> ch ) ) -> ( ( ph -> ch ) -> ( ph -> ps ) ) ) ;
		step 5 : wff = theorem impbid (step 2, step 4) |- ( ( ph -> ( ps <-> ch ) ) -> ( ( ph -> ps ) <-> ( ph -> ch ) ) ) ;
		step 6 : wff = theorem bi1 () |- ( ( ( ph -> ps ) <-> ( ph -> ch ) ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ;
		step 7 : wff = theorem pm2_86d (step 6) |- ( ( ( ph -> ps ) <-> ( ph -> ch ) ) -> ( ph -> ( ps -> ch ) ) ) ;
		step 8 : wff = theorem bi2 () |- ( ( ( ph -> ps ) <-> ( ph -> ch ) ) -> ( ( ph -> ch ) -> ( ph -> ps ) ) ) ;
		step 9 : wff = theorem pm2_86d (step 8) |- ( ( ( ph -> ps ) <-> ( ph -> ch ) ) -> ( ph -> ( ch -> ps ) ) ) ;
		step 10 : wff = theorem anim12d (step 7, step 9) |- ( ( ( ph -> ps ) <-> ( ph -> ch ) ) -> ( ( ph /\ ph ) -> ( ( ps -> ch ) /\ ( ch -> ps ) ) ) ) ;
		step 11 : wff = theorem pm4_24 () |- ( ph <-> ( ph /\ ph ) ) ;
		step 12 : wff = theorem bi () |- ( ( ps <-> ch ) <-> ( ( ps -> ch ) /\ ( ch -> ps ) ) ) ;
		step 13 : wff = theorem _3imtr4g (step 10, step 11, step 12) |- ( ( ( ph -> ps ) <-> ( ph -> ch ) ) -> ( ph -> ( ps <-> ch ) ) ) ;
		step 14 : wff = theorem impbi (step 5, step 13) |- ( ( ph -> ( ps <-> ch ) ) <-> ( ( ph -> ps ) <-> ( ph -> ch ) ) ) ;
		qed prop = step 14 ;
	}

	/*  Distribution of implication over biconditional (inference rule).  */
	theorem pm5_74i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ph -> ps ) <-> ( ph -> ch ) ) ;
	}

	/*  [1-Aug-1994]  */ 
	proof of pm5_74i {
		step 1 : wff = theorem pm5_74 () |- ( ( ph -> ( ps <-> ch ) ) <-> ( ( ph -> ps ) <-> ( ph -> ch ) ) ) ;
		step 2 : wff = theorem mpbi (hyp 1, step 1) |- ( ( ph -> ps ) <-> ( ph -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Distribution of implication over biconditional (deduction rule).  */
	theorem pm5_74d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch <-> th ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps -> ch ) <-> ( ps -> th ) ) ) ;
	}

	/*  [21-Mar-1996]  */ 
	proof of pm5_74d {
		step 1 : wff = theorem pm5_74 () |- ( ( ps -> ( ch <-> th ) ) <-> ( ( ps -> ch ) <-> ( ps -> th ) ) ) ;
		step 2 : wff = theorem sylib (hyp 1, step 1) |- ( ph -> ( ( ps -> ch ) <-> ( ps -> th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Distribution of implication over biconditional (deduction rule).  */
	theorem pm5_74da (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ( ch <-> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps -> ch ) <-> ( ps -> th ) ) ) ;
	}

	/*  [5-May-2007]  */ /*  [4-May-2007]  */ 
	proof of pm5_74da {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ( ch <-> th ) ) ) ;
		step 2 : wff = theorem pm5_74d (step 1) |- ( ph -> ( ( ps -> ch ) <-> ( ps -> th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Distribution of implication over biconditional (reverse inference
	       rule).  */
	theorem pm5_74ri (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph -> ps ) <-> ( ph -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps <-> ch ) ) ;
	}

	/*  [1-Aug-1994]  */ 
	proof of pm5_74ri {
		step 1 : wff = theorem pm5_74 () |- ( ( ph -> ( ps <-> ch ) ) <-> ( ( ph -> ps ) <-> ( ph -> ch ) ) ) ;
		step 2 : wff = theorem mpbir (hyp 1, step 1) |- ( ph -> ( ps <-> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Distribution of implication over biconditional (deduction rule).  */
	theorem pm5_74rd (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ps -> ch ) <-> ( ps -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch <-> th ) ) ) ;
	}

	/*  [19-Mar-1997]  */ 
	proof of pm5_74rd {
		step 1 : wff = theorem pm5_74 () |- ( ( ps -> ( ch <-> th ) ) <-> ( ( ps -> ch ) <-> ( ps -> th ) ) ) ;
		step 2 : wff = theorem sylibr (hyp 1, step 1) |- ( ph -> ( ps -> ( ch <-> th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  A deduction from a biconditional, related to modus ponens.  */
	theorem mpbidi (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( th -> ( ph -> ps ) ) ;
		hyp 2 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( th -> ( ph -> ch ) ) ;
	}

	/*  [9-Aug-1994]  */ 
	proof of mpbidi {
		step 1 : wff = theorem pm5_74i (hyp 2) |- ( ( ph -> ps ) <-> ( ph -> ch ) ) ;
		step 2 : wff = theorem sylib (hyp 1, step 1) |- ( th -> ( ph -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Implication in terms of implication and biconditional.  */
	theorem ibib (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) <-> ( ph -> ( ph <-> ps ) ) ) ;
	}

	/*  [31-Mar-1994]  */ 
	proof of ibib {
		step 1 : wff = theorem pm3_4 () |- ( ( ph /\ ps ) -> ( ph -> ps ) ) ;
		step 2 : wff = theorem pm3_26 () |- ( ( ph /\ ps ) -> ph ) ;
		step 3 : wff = theorem a1d (step 2) |- ( ( ph /\ ps ) -> ( ps -> ph ) ) ;
		step 4 : wff = theorem impbid (step 1, step 3) |- ( ( ph /\ ps ) -> ( ph <-> ps ) ) ;
		step 5 : wff = theorem ex (step 4) |- ( ph -> ( ps -> ( ph <-> ps ) ) ) ;
		step 6 : wff = theorem bi1 () |- ( ( ph <-> ps ) -> ( ph -> ps ) ) ;
		step 7 : wff = theorem com12 (step 6) |- ( ph -> ( ( ph <-> ps ) -> ps ) ) ;
		step 8 : wff = theorem impbid (step 5, step 7) |- ( ph -> ( ps <-> ( ph <-> ps ) ) ) ;
		step 9 : wff = theorem pm5_74i (step 8) |- ( ( ph -> ps ) <-> ( ph -> ( ph <-> ps ) ) ) ;
		qed prop = step 9 ;
	}

	/*  Implication in terms of implication and biconditional.  */
	theorem ibibr (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) <-> ( ph -> ( ps <-> ph ) ) ) ;
	}

	/*  [6-Jun-2005]  */ /*  [29-Apr-2005]  */ 
	proof of ibibr {
		step 1 : wff = theorem ibib () |- ( ( ph -> ps ) <-> ( ph -> ( ph <-> ps ) ) ) ;
		step 2 : wff = theorem bicom () |- ( ( ph <-> ps ) <-> ( ps <-> ph ) ) ;
		step 3 : wff = theorem imbi2i (step 2) |- ( ( ph -> ( ph <-> ps ) ) <-> ( ph -> ( ps <-> ph ) ) ) ;
		step 4 : wff = theorem bitr (step 1, step 3) |- ( ( ph -> ps ) <-> ( ph -> ( ps <-> ph ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Inference that converts a biconditional implied by one of its arguments,
	       into an implication.  */
	theorem ibi (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ph <-> ps ) ) ;
		-----------------
		prop : wff = |- ( ph -> ps ) ;
	}

	/*  [17-Oct-2003]  */ /*  [17-Oct-2003]  */ 
	proof of ibi {
		step 1 : wff = theorem biimpd (hyp 1) |- ( ph -> ( ph -> ps ) ) ;
		step 2 : wff = theorem pm2_43i (step 1) |- ( ph -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Inference that converts a biconditional implied by one of its arguments,
	       into an implication.  */
	theorem ibir (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ph ) ) ;
		-----------------
		prop : wff = |- ( ph -> ps ) ;
	}

	/*  [28-Jul-2004]  */ /*  [22-Jul-2004]  */ 
	proof of ibir {
		step 1 : wff = theorem bicomd (hyp 1) |- ( ph -> ( ph <-> ps ) ) ;
		step 2 : wff = theorem ibi (step 1) |- ( ph -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Deduction that converts a biconditional implied by one of its arguments,
	       into an implication.  */
	theorem ibd (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ps <-> ch ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ch ) ) ;
	}

	/*  [27-Jun-2004]  */ /*  [26-Jun-2004]  */ 
	proof of ibd {
		step 1 : wff = theorem ibib () |- ( ( ps -> ch ) <-> ( ps -> ( ps <-> ch ) ) ) ;
		step 2 : wff = theorem sylibr (hyp 1, step 1) |- ( ph -> ( ps -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *5.501 of [WhiteheadRussell] p. 125.  */
	theorem pm5_501 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ps <-> ( ph <-> ps ) ) ) ;
	}

	/*  [1-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_501 {
		step 1 : wff = theorem ibib () |- ( ( ph -> ps ) <-> ( ph -> ( ph <-> ps ) ) ) ;
		step 2 : wff = theorem pm5_74ri (step 1) |- ( ph -> ( ps <-> ( ph <-> ps ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Distributive law for disjunction.  Theorem *4.41 of [WhiteheadRussell]
	     p. 119.  */
	theorem ordi (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph \/ ( ps /\ ch ) ) <-> ( ( ph \/ ps ) /\ ( ph \/ ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of ordi {
		step 1 : wff = theorem pm3_26 () |- ( ( ps /\ ch ) -> ps ) ;
		step 2 : wff = theorem orim2i (step 1) |- ( ( ph \/ ( ps /\ ch ) ) -> ( ph \/ ps ) ) ;
		step 3 : wff = theorem pm3_27 () |- ( ( ps /\ ch ) -> ch ) ;
		step 4 : wff = theorem orim2i (step 3) |- ( ( ph \/ ( ps /\ ch ) ) -> ( ph \/ ch ) ) ;
		step 5 : wff = theorem jca (step 2, step 4) |- ( ( ph \/ ( ps /\ ch ) ) -> ( ( ph \/ ps ) /\ ( ph \/ ch ) ) ) ;
		step 6 : wff = definition df-or () |- ( ( ph \/ ps ) <-> ( -. ph -> ps ) ) ;
		step 7 : wff = theorem pm3_43i () |- ( ( -. ph -> ps ) -> ( ( -. ph -> ch ) -> ( -. ph -> ( ps /\ ch ) ) ) ) ;
		step 8 : wff = definition df-or () |- ( ( ph \/ ch ) <-> ( -. ph -> ch ) ) ;
		step 9 : wff = definition df-or () |- ( ( ph \/ ( ps /\ ch ) ) <-> ( -. ph -> ( ps /\ ch ) ) ) ;
		step 10 : wff = theorem _3imtr4g (step 7, step 8, step 9) |- ( ( -. ph -> ps ) -> ( ( ph \/ ch ) -> ( ph \/ ( ps /\ ch ) ) ) ) ;
		step 11 : wff = theorem sylbi (step 6, step 10) |- ( ( ph \/ ps ) -> ( ( ph \/ ch ) -> ( ph \/ ( ps /\ ch ) ) ) ) ;
		step 12 : wff = theorem imp (step 11) |- ( ( ( ph \/ ps ) /\ ( ph \/ ch ) ) -> ( ph \/ ( ps /\ ch ) ) ) ;
		step 13 : wff = theorem impbi (step 5, step 12) |- ( ( ph \/ ( ps /\ ch ) ) <-> ( ( ph \/ ps ) /\ ( ph \/ ch ) ) ) ;
		qed prop = step 13 ;
	}

	/*  Distributive law for disjunction.  */
	theorem ordir (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) \/ ch ) <-> ( ( ph \/ ch ) /\ ( ps \/ ch ) ) ) ;
	}

	/*  [12-Aug-1994]  */ 
	proof of ordir {
		step 1 : wff = theorem ordi () |- ( ( ch \/ ( ph /\ ps ) ) <-> ( ( ch \/ ph ) /\ ( ch \/ ps ) ) ) ;
		step 2 : wff = theorem orcom () |- ( ( ( ph /\ ps ) \/ ch ) <-> ( ch \/ ( ph /\ ps ) ) ) ;
		step 3 : wff = theorem orcom () |- ( ( ph \/ ch ) <-> ( ch \/ ph ) ) ;
		step 4 : wff = theorem orcom () |- ( ( ps \/ ch ) <-> ( ch \/ ps ) ) ;
		step 5 : wff = theorem anbi12i (step 3, step 4) |- ( ( ( ph \/ ch ) /\ ( ps \/ ch ) ) <-> ( ( ch \/ ph ) /\ ( ch \/ ps ) ) ) ;
		step 6 : wff = theorem _3bitr4 (step 1, step 2, step 5) |- ( ( ( ph /\ ps ) \/ ch ) <-> ( ( ph \/ ch ) /\ ( ps \/ ch ) ) ) ;
		qed prop = step 6 ;
	}

	/*  Distributive law for implication over conjunction.  Compare Theorem
	     *4.76 of [WhiteheadRussell] p. 121.  */
	theorem jcab (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ps /\ ch ) ) <-> ( ( ph -> ps ) /\ ( ph -> ch ) ) ) ;
	}

	/*  [3-Apr-1994]  */ 
	proof of jcab {
		step 1 : wff = theorem ordi () |- ( ( -. ph \/ ( ps /\ ch ) ) <-> ( ( -. ph \/ ps ) /\ ( -. ph \/ ch ) ) ) ;
		step 2 : wff = theorem imor () |- ( ( ph -> ( ps /\ ch ) ) <-> ( -. ph \/ ( ps /\ ch ) ) ) ;
		step 3 : wff = theorem imor () |- ( ( ph -> ps ) <-> ( -. ph \/ ps ) ) ;
		step 4 : wff = theorem imor () |- ( ( ph -> ch ) <-> ( -. ph \/ ch ) ) ;
		step 5 : wff = theorem anbi12i (step 3, step 4) |- ( ( ( ph -> ps ) /\ ( ph -> ch ) ) <-> ( ( -. ph \/ ps ) /\ ( -. ph \/ ch ) ) ) ;
		step 6 : wff = theorem _3bitr4 (step 1, step 2, step 5) |- ( ( ph -> ( ps /\ ch ) ) <-> ( ( ph -> ps ) /\ ( ph -> ch ) ) ) ;
		qed prop = step 6 ;
	}

	/*  Theorem *4.76 of [WhiteheadRussell] p. 121.  */
	theorem pm4_76 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) /\ ( ph -> ch ) ) <-> ( ph -> ( ps /\ ch ) ) ) ;
	}

	/*  [22-May-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_76 {
		step 1 : wff = theorem jcab () |- ( ( ph -> ( ps /\ ch ) ) <-> ( ( ph -> ps ) /\ ( ph -> ch ) ) ) ;
		step 2 : wff = theorem bicomi (step 1) |- ( ( ( ph -> ps ) /\ ( ph -> ch ) ) <-> ( ph -> ( ps /\ ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction conjoining the consequents of two implications.  */
	theorem jcad (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ps -> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch /\ th ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of jcad {
		step 1 : wff = theorem imp (hyp 1) |- ( ( ph /\ ps ) -> ch ) ;
		step 2 : wff = theorem imp (hyp 2) |- ( ( ph /\ ps ) -> th ) ;
		step 3 : wff = theorem jca (step 1, step 2) |- ( ( ph /\ ps ) -> ( ch /\ th ) ) ;
		step 4 : wff = theorem ex (step 3) |- ( ph -> ( ps -> ( ch /\ th ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Deduction conjoining a theorem to left of consequent in an
	       implication.  */
	theorem jctild (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( th /\ ch ) ) ) ;
	}

	/*  [22-Apr-2005]  */ /*  [21-Apr-2005]  */ 
	proof of jctild {
		step 1 : wff = theorem a1d (hyp 2) |- ( ph -> ( ps -> th ) ) ;
		step 2 : wff = theorem jcad (step 1, hyp 1) |- ( ph -> ( ps -> ( th /\ ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction conjoining a theorem to right of consequent in an
	       implication.  */
	theorem jctird (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch /\ th ) ) ) ;
	}

	/*  [22-Apr-2005]  */ /*  [21-Apr-2005]  */ 
	proof of jctird {
		step 1 : wff = theorem a1d (hyp 2) |- ( ph -> ( ps -> th ) ) ;
		step 2 : wff = theorem jcad (hyp 1, step 1) |- ( ph -> ( ps -> ( ch /\ th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *3.43 (Comp) of [WhiteheadRussell] p. 113.  */
	theorem pm3_43 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) /\ ( ph -> ch ) ) -> ( ph -> ( ps /\ ch ) ) ) ;
	}

	/*  [27-May-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm3_43 {
		step 1 : wff = theorem jcab () |- ( ( ph -> ( ps /\ ch ) ) <-> ( ( ph -> ps ) /\ ( ph -> ch ) ) ) ;
		step 2 : wff = theorem biimpr (step 1) |- ( ( ( ph -> ps ) /\ ( ph -> ch ) ) -> ( ph -> ( ps /\ ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Distributive law for conjunction.  Theorem *4.4 of [WhiteheadRussell]
	     p. 118.  */
	theorem andi (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ( ps \/ ch ) ) <-> ( ( ph /\ ps ) \/ ( ph /\ ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of andi {
		step 1 : wff = theorem ordi () |- ( ( -. ph \/ ( -. ps /\ -. ch ) ) <-> ( ( -. ph \/ -. ps ) /\ ( -. ph \/ -. ch ) ) ) ;
		step 2 : wff = theorem ioran () |- ( -. ( ps \/ ch ) <-> ( -. ps /\ -. ch ) ) ;
		step 3 : wff = theorem orbi2i (step 2) |- ( ( -. ph \/ -. ( ps \/ ch ) ) <-> ( -. ph \/ ( -. ps /\ -. ch ) ) ) ;
		step 4 : wff = theorem ianor () |- ( -. ( ph /\ ps ) <-> ( -. ph \/ -. ps ) ) ;
		step 5 : wff = theorem ianor () |- ( -. ( ph /\ ch ) <-> ( -. ph \/ -. ch ) ) ;
		step 6 : wff = theorem anbi12i (step 4, step 5) |- ( ( -. ( ph /\ ps ) /\ -. ( ph /\ ch ) ) <-> ( ( -. ph \/ -. ps ) /\ ( -. ph \/ -. ch ) ) ) ;
		step 7 : wff = theorem _3bitr4 (step 1, step 3, step 6) |- ( ( -. ph \/ -. ( ps \/ ch ) ) <-> ( -. ( ph /\ ps ) /\ -. ( ph /\ ch ) ) ) ;
		step 8 : wff = theorem negbii (step 7) |- ( -. ( -. ph \/ -. ( ps \/ ch ) ) <-> -. ( -. ( ph /\ ps ) /\ -. ( ph /\ ch ) ) ) ;
		step 9 : wff = theorem anor () |- ( ( ph /\ ( ps \/ ch ) ) <-> -. ( -. ph \/ -. ( ps \/ ch ) ) ) ;
		step 10 : wff = theorem oran () |- ( ( ( ph /\ ps ) \/ ( ph /\ ch ) ) <-> -. ( -. ( ph /\ ps ) /\ -. ( ph /\ ch ) ) ) ;
		step 11 : wff = theorem _3bitr4 (step 8, step 9, step 10) |- ( ( ph /\ ( ps \/ ch ) ) <-> ( ( ph /\ ps ) \/ ( ph /\ ch ) ) ) ;
		qed prop = step 11 ;
	}

	/*  Distributive law for conjunction.  */
	theorem andir (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ps ) /\ ch ) <-> ( ( ph /\ ch ) \/ ( ps /\ ch ) ) ) ;
	}

	/*  [12-Aug-1994]  */ 
	proof of andir {
		step 1 : wff = theorem andi () |- ( ( ch /\ ( ph \/ ps ) ) <-> ( ( ch /\ ph ) \/ ( ch /\ ps ) ) ) ;
		step 2 : wff = theorem ancom () |- ( ( ( ph \/ ps ) /\ ch ) <-> ( ch /\ ( ph \/ ps ) ) ) ;
		step 3 : wff = theorem ancom () |- ( ( ph /\ ch ) <-> ( ch /\ ph ) ) ;
		step 4 : wff = theorem ancom () |- ( ( ps /\ ch ) <-> ( ch /\ ps ) ) ;
		step 5 : wff = theorem orbi12i (step 3, step 4) |- ( ( ( ph /\ ch ) \/ ( ps /\ ch ) ) <-> ( ( ch /\ ph ) \/ ( ch /\ ps ) ) ) ;
		step 6 : wff = theorem _3bitr4 (step 1, step 2, step 5) |- ( ( ( ph \/ ps ) /\ ch ) <-> ( ( ph /\ ch ) \/ ( ps /\ ch ) ) ) ;
		qed prop = step 6 ;
	}

	/*  Double distributive law for disjunction.  */
	theorem orddi (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) \/ ( ch /\ th ) ) <-> ( ( ( ph \/ ch ) /\ ( ph \/ th ) ) /\ ( ( ps \/ ch ) /\ ( ps \/ th ) ) ) ) ;
	}

	/*  [12-Aug-1994]  */ 
	proof of orddi {
		step 1 : wff = theorem ordir () |- ( ( ( ph /\ ps ) \/ ( ch /\ th ) ) <-> ( ( ph \/ ( ch /\ th ) ) /\ ( ps \/ ( ch /\ th ) ) ) ) ;
		step 2 : wff = theorem ordi () |- ( ( ph \/ ( ch /\ th ) ) <-> ( ( ph \/ ch ) /\ ( ph \/ th ) ) ) ;
		step 3 : wff = theorem ordi () |- ( ( ps \/ ( ch /\ th ) ) <-> ( ( ps \/ ch ) /\ ( ps \/ th ) ) ) ;
		step 4 : wff = theorem anbi12i (step 2, step 3) |- ( ( ( ph \/ ( ch /\ th ) ) /\ ( ps \/ ( ch /\ th ) ) ) <-> ( ( ( ph \/ ch ) /\ ( ph \/ th ) ) /\ ( ( ps \/ ch ) /\ ( ps \/ th ) ) ) ) ;
		step 5 : wff = theorem bitr (step 1, step 4) |- ( ( ( ph /\ ps ) \/ ( ch /\ th ) ) <-> ( ( ( ph \/ ch ) /\ ( ph \/ th ) ) /\ ( ( ps \/ ch ) /\ ( ps \/ th ) ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Double distributive law for conjunction.  */
	theorem anddi (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ps ) /\ ( ch \/ th ) ) <-> ( ( ( ph /\ ch ) \/ ( ph /\ th ) ) \/ ( ( ps /\ ch ) \/ ( ps /\ th ) ) ) ) ;
	}

	/*  [12-Aug-1994]  */ 
	proof of anddi {
		step 1 : wff = theorem andir () |- ( ( ( ph \/ ps ) /\ ( ch \/ th ) ) <-> ( ( ph /\ ( ch \/ th ) ) \/ ( ps /\ ( ch \/ th ) ) ) ) ;
		step 2 : wff = theorem andi () |- ( ( ph /\ ( ch \/ th ) ) <-> ( ( ph /\ ch ) \/ ( ph /\ th ) ) ) ;
		step 3 : wff = theorem andi () |- ( ( ps /\ ( ch \/ th ) ) <-> ( ( ps /\ ch ) \/ ( ps /\ th ) ) ) ;
		step 4 : wff = theorem orbi12i (step 2, step 3) |- ( ( ( ph /\ ( ch \/ th ) ) \/ ( ps /\ ( ch \/ th ) ) ) <-> ( ( ( ph /\ ch ) \/ ( ph /\ th ) ) \/ ( ( ps /\ ch ) \/ ( ps /\ th ) ) ) ) ;
		step 5 : wff = theorem bitr (step 1, step 4) |- ( ( ( ph \/ ps ) /\ ( ch \/ th ) ) <-> ( ( ( ph /\ ch ) \/ ( ph /\ th ) ) \/ ( ( ps /\ ch ) \/ ( ps /\ th ) ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Inference adding a biconditional to the left in an equivalence.  */
	theorem bibi2i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ( ( ch <-> ph ) <-> ( ch <-> ps ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bibi2i {
		step 1 : wff = theorem bi () |- ( ( ch <-> ph ) <-> ( ( ch -> ph ) /\ ( ph -> ch ) ) ) ;
		step 2 : wff = theorem imbi1i (hyp 1) |- ( ( ph -> ch ) <-> ( ps -> ch ) ) ;
		step 3 : wff = theorem anbi2i (step 2) |- ( ( ( ch -> ph ) /\ ( ph -> ch ) ) <-> ( ( ch -> ph ) /\ ( ps -> ch ) ) ) ;
		step 4 : wff = theorem imbi2i (hyp 1) |- ( ( ch -> ph ) <-> ( ch -> ps ) ) ;
		step 5 : wff = theorem anbi1i (step 4) |- ( ( ( ch -> ph ) /\ ( ps -> ch ) ) <-> ( ( ch -> ps ) /\ ( ps -> ch ) ) ) ;
		step 6 : wff = theorem bi () |- ( ( ch <-> ps ) <-> ( ( ch -> ps ) /\ ( ps -> ch ) ) ) ;
		step 7 : wff = theorem bitr4 (step 5, step 6) |- ( ( ( ch -> ph ) /\ ( ps -> ch ) ) <-> ( ch <-> ps ) ) ;
		step 8 : wff = theorem _3bitr (step 1, step 3, step 7) |- ( ( ch <-> ph ) <-> ( ch <-> ps ) ) ;
		qed prop = step 8 ;
	}

	/*  Inference adding a biconditional to the right in an equivalence.  */
	theorem bibi1i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ( ( ph <-> ch ) <-> ( ps <-> ch ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bibi1i {
		step 1 : wff = theorem bicom () |- ( ( ph <-> ch ) <-> ( ch <-> ph ) ) ;
		step 2 : wff = theorem bibi2i (hyp 1) |- ( ( ch <-> ph ) <-> ( ch <-> ps ) ) ;
		step 3 : wff = theorem bicom () |- ( ( ch <-> ps ) <-> ( ps <-> ch ) ) ;
		step 4 : wff = theorem _3bitr (step 1, step 2, step 3) |- ( ( ph <-> ch ) <-> ( ps <-> ch ) ) ;
		qed prop = step 4 ;
	}

	/*  The equivalence of two equivalences.  */
	theorem bibi12i (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ch <-> th ) ;
		-----------------
		prop : wff = |- ( ( ph <-> ch ) <-> ( ps <-> th ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bibi12i {
		step 1 : wff = theorem bibi2i (hyp 2) |- ( ( ph <-> ch ) <-> ( ph <-> th ) ) ;
		step 2 : wff = theorem bibi1i (hyp 1) |- ( ( ph <-> th ) <-> ( ps <-> th ) ) ;
		step 3 : wff = theorem bitr (step 1, step 2) |- ( ( ph <-> ch ) <-> ( ps <-> th ) ) ;
		qed prop = step 3 ;
	}

	/*  Deduction negating both sides of a logical equivalence.  */
	theorem negbid (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( -. ps <-> -. ch ) ) ;
	}

	/*  [21-May-1994]  */ 
	proof of negbid {
		step 1 : wff = theorem pm4_11 () |- ( ( ps <-> ch ) <-> ( -. ps <-> -. ch ) ) ;
		step 2 : wff = theorem sylib (hyp 1, step 1) |- ( ph -> ( -. ps <-> -. ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding an antecedent to both sides of a logical
	       equivalence.  */
	theorem imbi2d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( th -> ps ) <-> ( th -> ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of imbi2d {
		step 1 : wff = theorem a1d (hyp 1) |- ( ph -> ( th -> ( ps <-> ch ) ) ) ;
		step 2 : wff = theorem pm5_74d (step 1) |- ( ph -> ( ( th -> ps ) <-> ( th -> ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding a consequent to both sides of a logical equivalence.  */
	theorem imbi1d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps -> th ) <-> ( ch -> th ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of imbi1d {
		step 1 : wff = theorem negbid (hyp 1) |- ( ph -> ( -. ps <-> -. ch ) ) ;
		step 2 : wff = theorem imbi2d (step 1) |- ( ph -> ( ( -. th -> -. ps ) <-> ( -. th -> -. ch ) ) ) ;
		step 3 : wff = theorem pm4_1 () |- ( ( ps -> th ) <-> ( -. th -> -. ps ) ) ;
		step 4 : wff = theorem pm4_1 () |- ( ( ch -> th ) <-> ( -. th -> -. ch ) ) ;
		step 5 : wff = theorem _3bitr4g (step 2, step 3, step 4) |- ( ph -> ( ( ps -> th ) <-> ( ch -> th ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Deduction adding a left disjunct to both sides of a logical
	       equivalence.  */
	theorem orbi2d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( th \/ ps ) <-> ( th \/ ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of orbi2d {
		step 1 : wff = theorem imbi2d (hyp 1) |- ( ph -> ( ( -. th -> ps ) <-> ( -. th -> ch ) ) ) ;
		step 2 : wff = definition df-or () |- ( ( th \/ ps ) <-> ( -. th -> ps ) ) ;
		step 3 : wff = definition df-or () |- ( ( th \/ ch ) <-> ( -. th -> ch ) ) ;
		step 4 : wff = theorem _3bitr4g (step 1, step 2, step 3) |- ( ph -> ( ( th \/ ps ) <-> ( th \/ ch ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Deduction adding a right disjunct to both sides of a logical
	       equivalence.  */
	theorem orbi1d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps \/ th ) <-> ( ch \/ th ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of orbi1d {
		step 1 : wff = theorem orbi2d (hyp 1) |- ( ph -> ( ( th \/ ps ) <-> ( th \/ ch ) ) ) ;
		step 2 : wff = theorem orcom () |- ( ( ps \/ th ) <-> ( th \/ ps ) ) ;
		step 3 : wff = theorem orcom () |- ( ( ch \/ th ) <-> ( th \/ ch ) ) ;
		step 4 : wff = theorem _3bitr4g (step 1, step 2, step 3) |- ( ph -> ( ( ps \/ th ) <-> ( ch \/ th ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Deduction adding a left conjunct to both sides of a logical
	       equivalence.  */
	theorem anbi2d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( th /\ ps ) <-> ( th /\ ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of anbi2d {
		step 1 : wff = theorem biimpd (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem anim2d (step 1) |- ( ph -> ( ( th /\ ps ) -> ( th /\ ch ) ) ) ;
		step 3 : wff = theorem biimprd (hyp 1) |- ( ph -> ( ch -> ps ) ) ;
		step 4 : wff = theorem anim2d (step 3) |- ( ph -> ( ( th /\ ch ) -> ( th /\ ps ) ) ) ;
		step 5 : wff = theorem impbid (step 2, step 4) |- ( ph -> ( ( th /\ ps ) <-> ( th /\ ch ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Deduction adding a right conjunct to both sides of a logical
	       equivalence.  */
	theorem anbi1d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ th ) <-> ( ch /\ th ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of anbi1d {
		step 1 : wff = theorem anbi2d (hyp 1) |- ( ph -> ( ( th /\ ps ) <-> ( th /\ ch ) ) ) ;
		step 2 : wff = theorem ancom () |- ( ( ps /\ th ) <-> ( th /\ ps ) ) ;
		step 3 : wff = theorem ancom () |- ( ( ch /\ th ) <-> ( th /\ ch ) ) ;
		step 4 : wff = theorem _3bitr4g (step 1, step 2, step 3) |- ( ph -> ( ( ps /\ th ) <-> ( ch /\ th ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Deduction adding a biconditional to the left in an equivalence.  */
	theorem bibi2d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( th <-> ps ) <-> ( th <-> ch ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bibi2d {
		step 1 : wff = theorem imbi2d (hyp 1) |- ( ph -> ( ( th -> ps ) <-> ( th -> ch ) ) ) ;
		step 2 : wff = theorem anbi1d (step 1) |- ( ph -> ( ( ( th -> ps ) /\ ( ps -> th ) ) <-> ( ( th -> ch ) /\ ( ps -> th ) ) ) ) ;
		step 3 : wff = theorem imbi1d (hyp 1) |- ( ph -> ( ( ps -> th ) <-> ( ch -> th ) ) ) ;
		step 4 : wff = theorem anbi2d (step 3) |- ( ph -> ( ( ( th -> ch ) /\ ( ps -> th ) ) <-> ( ( th -> ch ) /\ ( ch -> th ) ) ) ) ;
		step 5 : wff = theorem bitrd (step 2, step 4) |- ( ph -> ( ( ( th -> ps ) /\ ( ps -> th ) ) <-> ( ( th -> ch ) /\ ( ch -> th ) ) ) ) ;
		step 6 : wff = theorem bi () |- ( ( th <-> ps ) <-> ( ( th -> ps ) /\ ( ps -> th ) ) ) ;
		step 7 : wff = theorem bi () |- ( ( th <-> ch ) <-> ( ( th -> ch ) /\ ( ch -> th ) ) ) ;
		step 8 : wff = theorem _3bitr4g (step 5, step 6, step 7) |- ( ph -> ( ( th <-> ps ) <-> ( th <-> ch ) ) ) ;
		qed prop = step 8 ;
	}

	/*  Deduction adding a biconditional to the right in an equivalence.  */
	theorem bibi1d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps <-> th ) <-> ( ch <-> th ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bibi1d {
		step 1 : wff = theorem bibi2d (hyp 1) |- ( ph -> ( ( th <-> ps ) <-> ( th <-> ch ) ) ) ;
		step 2 : wff = theorem bicom () |- ( ( ps <-> th ) <-> ( th <-> ps ) ) ;
		step 3 : wff = theorem bicom () |- ( ( ch <-> th ) <-> ( th <-> ch ) ) ;
		step 4 : wff = theorem _3bitr4g (step 1, step 2, step 3) |- ( ph -> ( ( ps <-> th ) <-> ( ch <-> th ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Theorem *4.37 of [WhiteheadRussell] p. 118.  */
	theorem orbi1 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph <-> ps ) -> ( ( ph \/ ch ) <-> ( ps \/ ch ) ) ) ;
	}

	/*  [12-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of orbi1 {
		step 1 : wff = theorem id () |- ( ( ph <-> ps ) -> ( ph <-> ps ) ) ;
		step 2 : wff = theorem orbi1d (step 1) |- ( ( ph <-> ps ) -> ( ( ph \/ ch ) <-> ( ps \/ ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *4.36 of [WhiteheadRussell] p. 118.  */
	theorem anbi1 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph <-> ps ) -> ( ( ph /\ ch ) <-> ( ps /\ ch ) ) ) ;
	}

	/*  [15-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of anbi1 {
		step 1 : wff = theorem id () |- ( ( ph <-> ps ) -> ( ph <-> ps ) ) ;
		step 2 : wff = theorem anbi1d (step 1) |- ( ( ph <-> ps ) -> ( ( ph /\ ch ) <-> ( ps /\ ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *4.22 of [WhiteheadRussell] p. 117.  */
	theorem pm4_22 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph <-> ps ) /\ ( ps <-> ch ) ) -> ( ph <-> ch ) ) ;
	}

	/*  [30-May-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_22 {
		step 1 : wff = theorem id () |- ( ( ph <-> ps ) -> ( ph <-> ps ) ) ;
		step 2 : wff = theorem bibi1d (step 1) |- ( ( ph <-> ps ) -> ( ( ph <-> ch ) <-> ( ps <-> ch ) ) ) ;
		step 3 : wff = theorem biimpar (step 2) |- ( ( ( ph <-> ps ) /\ ( ps <-> ch ) ) -> ( ph <-> ch ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *4.84 of [WhiteheadRussell] p. 122.  */
	theorem imbi1 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph <-> ps ) -> ( ( ph -> ch ) <-> ( ps -> ch ) ) ) ;
	}

	/*  [9-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of imbi1 {
		step 1 : wff = theorem id () |- ( ( ph <-> ps ) -> ( ph <-> ps ) ) ;
		step 2 : wff = theorem imbi1d (step 1) |- ( ( ph <-> ps ) -> ( ( ph -> ch ) <-> ( ps -> ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *4.85 of [WhiteheadRussell] p. 122.  */
	theorem imbi2 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph <-> ps ) -> ( ( ch -> ph ) <-> ( ch -> ps ) ) ) ;
	}

	/*  [9-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of imbi2 {
		step 1 : wff = axiom ax-1 () |- ( ( ph <-> ps ) -> ( ch -> ( ph <-> ps ) ) ) ;
		step 2 : wff = theorem pm5_74d (step 1) |- ( ( ph <-> ps ) -> ( ( ch -> ph ) <-> ( ch -> ps ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *4.86 of [WhiteheadRussell] p. 122.  */
	theorem bibi1 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph <-> ps ) -> ( ( ph <-> ch ) <-> ( ps <-> ch ) ) ) ;
	}

	/*  [15-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of bibi1 {
		step 1 : wff = theorem id () |- ( ( ph <-> ps ) -> ( ph <-> ps ) ) ;
		step 2 : wff = theorem bibi1d (step 1) |- ( ( ph <-> ps ) -> ( ( ph <-> ch ) <-> ( ps <-> ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction joining two equivalences to form equivalence of
	       implications.  */
	theorem imbi12d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps -> th ) <-> ( ch -> ta ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of imbi12d {
		step 1 : wff = theorem imbi1d (hyp 1) |- ( ph -> ( ( ps -> th ) <-> ( ch -> th ) ) ) ;
		step 2 : wff = theorem imbi2d (hyp 2) |- ( ph -> ( ( ch -> th ) <-> ( ch -> ta ) ) ) ;
		step 3 : wff = theorem bitrd (step 1, step 2) |- ( ph -> ( ( ps -> th ) <-> ( ch -> ta ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Deduction joining two equivalences to form equivalence of
	       disjunctions.  */
	theorem orbi12d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps \/ th ) <-> ( ch \/ ta ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of orbi12d {
		step 1 : wff = theorem orbi1d (hyp 1) |- ( ph -> ( ( ps \/ th ) <-> ( ch \/ th ) ) ) ;
		step 2 : wff = theorem orbi2d (hyp 2) |- ( ph -> ( ( ch \/ th ) <-> ( ch \/ ta ) ) ) ;
		step 3 : wff = theorem bitrd (step 1, step 2) |- ( ph -> ( ( ps \/ th ) <-> ( ch \/ ta ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Deduction joining two equivalences to form equivalence of
	       conjunctions.  */
	theorem anbi12d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ th ) <-> ( ch /\ ta ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of anbi12d {
		step 1 : wff = theorem anbi1d (hyp 1) |- ( ph -> ( ( ps /\ th ) <-> ( ch /\ th ) ) ) ;
		step 2 : wff = theorem anbi2d (hyp 2) |- ( ph -> ( ( ch /\ th ) <-> ( ch /\ ta ) ) ) ;
		step 3 : wff = theorem bitrd (step 1, step 2) |- ( ph -> ( ( ps /\ th ) <-> ( ch /\ ta ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Deduction joining two equivalences to form equivalence of
	       biconditionals.  */
	theorem bibi12d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps <-> th ) <-> ( ch <-> ta ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bibi12d {
		step 1 : wff = theorem bibi1d (hyp 1) |- ( ph -> ( ( ps <-> th ) <-> ( ch <-> th ) ) ) ;
		step 2 : wff = theorem bibi2d (hyp 2) |- ( ph -> ( ( ch <-> th ) <-> ( ch <-> ta ) ) ) ;
		step 3 : wff = theorem bitrd (step 1, step 2) |- ( ph -> ( ( ps <-> th ) <-> ( ch <-> ta ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *4.39 of [WhiteheadRussell] p. 118.  */
	theorem pm4_39 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ph <-> ch ) /\ ( ps <-> th ) ) -> ( ( ph \/ ps ) <-> ( ch \/ th ) ) ) ;
	}

	/*  [30-May-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_39 {
		step 1 : wff = theorem pm3_26 () |- ( ( ( ph <-> ch ) /\ ( ps <-> th ) ) -> ( ph <-> ch ) ) ;
		step 2 : wff = theorem pm3_27 () |- ( ( ( ph <-> ch ) /\ ( ps <-> th ) ) -> ( ps <-> th ) ) ;
		step 3 : wff = theorem orbi12d (step 1, step 2) |- ( ( ( ph <-> ch ) /\ ( ps <-> th ) ) -> ( ( ph \/ ps ) <-> ( ch \/ th ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *4.38 of [WhiteheadRussell] p. 118.  */
	theorem pm4_38 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ph <-> ch ) /\ ( ps <-> th ) ) -> ( ( ph /\ ps ) <-> ( ch /\ th ) ) ) ;
	}

	/*  [30-May-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_38 {
		step 1 : wff = theorem pm3_26 () |- ( ( ( ph <-> ch ) /\ ( ps <-> th ) ) -> ( ph <-> ch ) ) ;
		step 2 : wff = theorem pm3_27 () |- ( ( ( ph <-> ch ) /\ ( ps <-> th ) ) -> ( ps <-> th ) ) ;
		step 3 : wff = theorem anbi12d (step 1, step 2) |- ( ( ( ph <-> ch ) /\ ( ps <-> th ) ) -> ( ( ph /\ ps ) <-> ( ch /\ th ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Deduction joining two equivalences to form equivalence of
	       conjunctions.  */
	theorem bi2anan9 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( th -> ( ta <-> et ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ th ) -> ( ( ps /\ ta ) <-> ( ch /\ et ) ) ) ;
	}

	/*  [31-Jul-1995]  */ 
	proof of bi2anan9 {
		step 1 : wff = theorem anbi1d (hyp 1) |- ( ph -> ( ( ps /\ ta ) <-> ( ch /\ ta ) ) ) ;
		step 2 : wff = theorem anbi2d (hyp 2) |- ( th -> ( ( ch /\ ta ) <-> ( ch /\ et ) ) ) ;
		step 3 : wff = theorem sylan9bb (step 1, step 2) |- ( ( ph /\ th ) -> ( ( ps /\ ta ) <-> ( ch /\ et ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Deduction joining two equivalences to form equivalence of
	       conjunctions.  */
	theorem bi2anan9r (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( th -> ( ta <-> et ) ) ;
		-----------------
		prop : wff = |- ( ( th /\ ph ) -> ( ( ps /\ ta ) <-> ( ch /\ et ) ) ) ;
	}

	/*  [19-Feb-1996]  */ 
	proof of bi2anan9r {
		step 1 : wff = theorem bi2anan9 (hyp 1, hyp 2) |- ( ( ph /\ th ) -> ( ( ps /\ ta ) <-> ( ch /\ et ) ) ) ;
		step 2 : wff = theorem ancoms (step 1) |- ( ( th /\ ph ) -> ( ( ps /\ ta ) <-> ( ch /\ et ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction joining two biconditionals with different antecedents.  */
	theorem bi2bian9 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( th -> ( ta <-> et ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ th ) -> ( ( ps <-> ta ) <-> ( ch <-> et ) ) ) ;
	}

	/*  [14-May-2004]  */ /*  [12-May-2004]  */ 
	proof of bi2bian9 {
		step 1 : wff = theorem adantr (hyp 1) |- ( ( ph /\ th ) -> ( ps <-> ch ) ) ;
		step 2 : wff = theorem adantl (hyp 2) |- ( ( ph /\ th ) -> ( ta <-> et ) ) ;
		step 3 : wff = theorem bibi12d (step 1, step 2) |- ( ( ph /\ th ) -> ( ( ps <-> ta ) <-> ( ch <-> et ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Implication in terms of biconditional and conjunction.  Theorem *4.71 of
	     [WhiteheadRussell] p. 120.  */
	theorem pm4_71 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) <-> ( ph <-> ( ph /\ ps ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of pm4_71 {
		step 1 : wff = theorem ancl () |- ( ( ph -> ps ) -> ( ph -> ( ph /\ ps ) ) ) ;
		step 2 : wff = theorem pm3_26 () |- ( ( ph /\ ps ) -> ph ) ;
		step 3 : wff = theorem impbid1 (step 1, step 2) |- ( ( ph -> ps ) -> ( ph <-> ( ph /\ ps ) ) ) ;
		step 4 : wff = theorem bi1 () |- ( ( ph <-> ( ph /\ ps ) ) -> ( ph -> ( ph /\ ps ) ) ) ;
		step 5 : wff = theorem pm3_27 () |- ( ( ph /\ ps ) -> ps ) ;
		step 6 : wff = theorem syl6 (step 4, step 5) |- ( ( ph <-> ( ph /\ ps ) ) -> ( ph -> ps ) ) ;
		step 7 : wff = theorem impbi (step 3, step 6) |- ( ( ph -> ps ) <-> ( ph <-> ( ph /\ ps ) ) ) ;
		qed prop = step 7 ;
	}

	/*  Implication in terms of biconditional and conjunction.  Theorem *4.71 of
	     [WhiteheadRussell] p. 120 (with conjunct reversed).  */
	theorem pm4_71r (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) <-> ( ph <-> ( ps /\ ph ) ) ) ;
	}

	/*  [25-Jul-1999]  */ 
	proof of pm4_71r {
		step 1 : wff = theorem pm4_71 () |- ( ( ph -> ps ) <-> ( ph <-> ( ph /\ ps ) ) ) ;
		step 2 : wff = theorem ancom () |- ( ( ph /\ ps ) <-> ( ps /\ ph ) ) ;
		step 3 : wff = theorem bibi2i (step 2) |- ( ( ph <-> ( ph /\ ps ) ) <-> ( ph <-> ( ps /\ ph ) ) ) ;
		step 4 : wff = theorem bitr (step 1, step 3) |- ( ( ph -> ps ) <-> ( ph <-> ( ps /\ ph ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Inference converting an implication to a biconditional with conjunction.
	       Inference from Theorem *4.71 of [WhiteheadRussell] p. 120.  */
	theorem pm4_71i (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ph <-> ( ph /\ ps ) ) ;
	}

	/*  [6-Jan-2004]  */ /*  [4-Jan-2004]  */ 
	proof of pm4_71i {
		step 1 : wff = theorem pm4_71 () |- ( ( ph -> ps ) <-> ( ph <-> ( ph /\ ps ) ) ) ;
		step 2 : wff = theorem mpbi (hyp 1, step 1) |- ( ph <-> ( ph /\ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Inference converting an implication to a biconditional with conjunction.
	       Inference from Theorem *4.71 of [WhiteheadRussell] p. 120 (with
	       conjunct reversed).  */
	theorem pm4_71ri (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ph <-> ( ps /\ ph ) ) ;
	}

	/*  [1-Dec-2003]  */ /*  [1-Dec-2003]  */ 
	proof of pm4_71ri {
		step 1 : wff = theorem pm4_71r () |- ( ( ph -> ps ) <-> ( ph <-> ( ps /\ ph ) ) ) ;
		step 2 : wff = theorem mpbi (hyp 1, step 1) |- ( ph <-> ( ps /\ ph ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction converting an implication to a biconditional with conjunction.
	       Deduction from Theorem *4.71 of [WhiteheadRussell] p. 120.  */
	theorem pm4_71rd (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps <-> ( ch /\ ps ) ) ) ;
	}

	/*  [12-Feb-2005]  */ /*  [10-Feb-2005]  */ 
	proof of pm4_71rd {
		step 1 : wff = theorem pm4_71r () |- ( ( ps -> ch ) <-> ( ps <-> ( ch /\ ps ) ) ) ;
		step 2 : wff = theorem sylib (hyp 1, step 1) |- ( ph -> ( ps <-> ( ch /\ ps ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *4.45 of [WhiteheadRussell] p. 119.  */
	theorem pm4_45 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph <-> ( ph /\ ( ph \/ ps ) ) ) ;
	}

	/*  [30-May-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_45 {
		step 1 : wff = theorem orc () |- ( ph -> ( ph \/ ps ) ) ;
		step 2 : wff = theorem pm4_71i (step 1) |- ( ph <-> ( ph /\ ( ph \/ ps ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Implication in terms of biconditional and disjunction.  Theorem *4.72 of
	     [WhiteheadRussell] p. 121.  */
	theorem pm4_72 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) <-> ( ps <-> ( ph \/ ps ) ) ) ;
	}

	/*  [30-Aug-1993]  */ 
	proof of pm4_72 {
		step 1 : wff = theorem olc () |- ( ps -> ( ph \/ ps ) ) ;
		step 2 : wff = theorem pm2_621 () |- ( ( ph -> ps ) -> ( ( ph \/ ps ) -> ps ) ) ;
		step 3 : wff = theorem impbid2 (step 1, step 2) |- ( ( ph -> ps ) -> ( ps <-> ( ph \/ ps ) ) ) ;
		step 4 : wff = theorem bi2 () |- ( ( ps <-> ( ph \/ ps ) ) -> ( ( ph \/ ps ) -> ps ) ) ;
		step 5 : wff = theorem pm2_67 () |- ( ( ( ph \/ ps ) -> ps ) -> ( ph -> ps ) ) ;
		step 6 : wff = theorem syl (step 4, step 5) |- ( ( ps <-> ( ph \/ ps ) ) -> ( ph -> ps ) ) ;
		step 7 : wff = theorem impbi (step 3, step 6) |- ( ( ph -> ps ) <-> ( ps <-> ( ph \/ ps ) ) ) ;
		qed prop = step 7 ;
	}

	/*  Introduction of antecedent as conjunct.  Theorem *4.73 of
	     [WhiteheadRussell] p. 121.  */
	theorem iba (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ps <-> ( ps /\ ph ) ) ) ;
	}

	/*  [30-Mar-1994]  */ 
	proof of iba {
		step 1 : wff = theorem ancrb () |- ( ( ph -> ps ) <-> ( ph -> ( ps /\ ph ) ) ) ;
		step 2 : wff = theorem pm5_74ri (step 1) |- ( ph -> ( ps <-> ( ps /\ ph ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Introduction of antecedent as conjunct.  */
	theorem ibar (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ps <-> ( ph /\ ps ) ) ) ;
	}

	/*  [5-Dec-1995]  */ 
	proof of ibar {
		step 1 : wff = theorem anclb () |- ( ( ph -> ps ) <-> ( ph -> ( ph /\ ps ) ) ) ;
		step 2 : wff = theorem pm5_74ri (step 1) |- ( ph -> ( ps <-> ( ph /\ ps ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Distribution of implication over biconditional.  Theorem *5.32 of
	     [WhiteheadRussell] p. 125.  */
	theorem pm5_32 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ps <-> ch ) ) <-> ( ( ph /\ ps ) <-> ( ph /\ ch ) ) ) ;
	}

	/*  [1-Aug-1994]  */ 
	proof of pm5_32 {
		step 1 : wff = theorem pm4_11 () |- ( ( ps <-> ch ) <-> ( -. ps <-> -. ch ) ) ;
		step 2 : wff = theorem imbi2i (step 1) |- ( ( ph -> ( ps <-> ch ) ) <-> ( ph -> ( -. ps <-> -. ch ) ) ) ;
		step 3 : wff = theorem pm5_74 () |- ( ( ph -> ( -. ps <-> -. ch ) ) <-> ( ( ph -> -. ps ) <-> ( ph -> -. ch ) ) ) ;
		step 4 : wff = theorem pm4_11 () |- ( ( ( ph -> -. ps ) <-> ( ph -> -. ch ) ) <-> ( -. ( ph -> -. ps ) <-> -. ( ph -> -. ch ) ) ) ;
		step 5 : wff = theorem _3bitr (step 2, step 3, step 4) |- ( ( ph -> ( ps <-> ch ) ) <-> ( -. ( ph -> -. ps ) <-> -. ( ph -> -. ch ) ) ) ;
		step 6 : wff = definition df-an () |- ( ( ph /\ ps ) <-> -. ( ph -> -. ps ) ) ;
		step 7 : wff = definition df-an () |- ( ( ph /\ ch ) <-> -. ( ph -> -. ch ) ) ;
		step 8 : wff = theorem bibi12i (step 6, step 7) |- ( ( ( ph /\ ps ) <-> ( ph /\ ch ) ) <-> ( -. ( ph -> -. ps ) <-> -. ( ph -> -. ch ) ) ) ;
		step 9 : wff = theorem bitr4 (step 5, step 8) |- ( ( ph -> ( ps <-> ch ) ) <-> ( ( ph /\ ps ) <-> ( ph /\ ch ) ) ) ;
		qed prop = step 9 ;
	}

	/*  Distribution of implication over biconditional (inference rule).  */
	theorem pm5_32i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) <-> ( ph /\ ch ) ) ;
	}

	/*  [1-Aug-1994]  */ 
	proof of pm5_32i {
		step 1 : wff = theorem pm5_32 () |- ( ( ph -> ( ps <-> ch ) ) <-> ( ( ph /\ ps ) <-> ( ph /\ ch ) ) ) ;
		step 2 : wff = theorem mpbi (hyp 1, step 1) |- ( ( ph /\ ps ) <-> ( ph /\ ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Distribution of implication over biconditional (inference rule).  */
	theorem pm5_32ri (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ps /\ ph ) <-> ( ch /\ ph ) ) ;
	}

	/*  [12-Mar-1995]  */ 
	proof of pm5_32ri {
		step 1 : wff = theorem pm5_32i (hyp 1) |- ( ( ph /\ ps ) <-> ( ph /\ ch ) ) ;
		step 2 : wff = theorem ancom () |- ( ( ps /\ ph ) <-> ( ph /\ ps ) ) ;
		step 3 : wff = theorem ancom () |- ( ( ch /\ ph ) <-> ( ph /\ ch ) ) ;
		step 4 : wff = theorem _3bitr4 (step 1, step 2, step 3) |- ( ( ps /\ ph ) <-> ( ch /\ ph ) ) ;
		qed prop = step 4 ;
	}

	/*  Distribution of implication over biconditional (deduction rule).  */
	theorem pm5_32d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch <-> th ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ ch ) <-> ( ps /\ th ) ) ) ;
	}

	/*  [29-Oct-1996]  */ 
	proof of pm5_32d {
		step 1 : wff = theorem pm5_32 () |- ( ( ps -> ( ch <-> th ) ) <-> ( ( ps /\ ch ) <-> ( ps /\ th ) ) ) ;
		step 2 : wff = theorem sylib (hyp 1, step 1) |- ( ph -> ( ( ps /\ ch ) <-> ( ps /\ th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Distribution of implication over biconditional (deduction rule).  */
	theorem pm5_32rd (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch <-> th ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ch /\ ps ) <-> ( th /\ ps ) ) ) ;
	}

	/*  [1-Jan-2005]  */ /*  [25-Dec-2004]  */ 
	proof of pm5_32rd {
		step 1 : wff = theorem pm5_32d (hyp 1) |- ( ph -> ( ( ps /\ ch ) <-> ( ps /\ th ) ) ) ;
		step 2 : wff = theorem ancom () |- ( ( ch /\ ps ) <-> ( ps /\ ch ) ) ;
		step 3 : wff = theorem ancom () |- ( ( th /\ ps ) <-> ( ps /\ th ) ) ;
		step 4 : wff = theorem _3bitr4g (step 1, step 2, step 3) |- ( ph -> ( ( ch /\ ps ) <-> ( th /\ ps ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Distribution of implication over biconditional (deduction rule).  */
	theorem pm5_32da (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ( ch <-> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ ch ) <-> ( ps /\ th ) ) ) ;
	}

	/*  [10-Dec-2006]  */ /*  [9-Dec-2006]  */ 
	proof of pm5_32da {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ( ch <-> th ) ) ) ;
		step 2 : wff = theorem pm5_32d (step 1) |- ( ph -> ( ( ps /\ ch ) <-> ( ps /\ th ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *5.33 of [WhiteheadRussell] p. 125.  */
	theorem pm5_33 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ( ps -> ch ) ) <-> ( ph /\ ( ( ph /\ ps ) -> ch ) ) ) ;
	}

	/*  [31-May-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_33 {
		step 1 : wff = theorem ibar () |- ( ph -> ( ps <-> ( ph /\ ps ) ) ) ;
		step 2 : wff = theorem imbi1d (step 1) |- ( ph -> ( ( ps -> ch ) <-> ( ( ph /\ ps ) -> ch ) ) ) ;
		step 3 : wff = theorem pm5_32i (step 2) |- ( ( ph /\ ( ps -> ch ) ) <-> ( ph /\ ( ( ph /\ ps ) -> ch ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *5.36 of [WhiteheadRussell] p. 125.  */
	theorem pm5_36 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph /\ ( ph <-> ps ) ) <-> ( ps /\ ( ph <-> ps ) ) ) ;
	}

	/*  [31-May-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_36 {
		step 1 : wff = theorem id () |- ( ( ph <-> ps ) -> ( ph <-> ps ) ) ;
		step 2 : wff = theorem pm5_32ri (step 1) |- ( ( ph /\ ( ph <-> ps ) ) <-> ( ps /\ ( ph <-> ps ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *5.42 of [WhiteheadRussell] p. 125.  */
	theorem pm5_42 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ps -> ch ) ) <-> ( ph -> ( ps -> ( ph /\ ch ) ) ) ) ;
	}

	/*  [3-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_42 {
		step 1 : wff = theorem ibar () |- ( ph -> ( ch <-> ( ph /\ ch ) ) ) ;
		step 2 : wff = theorem imbi2d (step 1) |- ( ph -> ( ( ps -> ch ) <-> ( ps -> ( ph /\ ch ) ) ) ) ;
		step 3 : wff = theorem pm5_74i (step 2) |- ( ( ph -> ( ps -> ch ) ) <-> ( ph -> ( ps -> ( ph /\ ch ) ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Absorption of disjunction into equivalence.  */
	theorem oibabs (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ps ) -> ( ph <-> ps ) ) <-> ( ph <-> ps ) ) ;
	}

	/*  [29-Jan-2008]  */ /*  [6-Aug-1995]  */ 
	proof of oibabs {
		step 1 : wff = theorem orc () |- ( ph -> ( ph \/ ps ) ) ;
		step 2 : wff = theorem imim1i (step 1) |- ( ( ( ph \/ ps ) -> ( ph <-> ps ) ) -> ( ph -> ( ph <-> ps ) ) ) ;
		step 3 : wff = theorem ibd (step 2) |- ( ( ( ph \/ ps ) -> ( ph <-> ps ) ) -> ( ph -> ps ) ) ;
		step 4 : wff = theorem olc () |- ( ps -> ( ph \/ ps ) ) ;
		step 5 : wff = theorem imim1i (step 4) |- ( ( ( ph \/ ps ) -> ( ph <-> ps ) ) -> ( ps -> ( ph <-> ps ) ) ) ;
		step 6 : wff = theorem ibibr () |- ( ( ps -> ph ) <-> ( ps -> ( ph <-> ps ) ) ) ;
		step 7 : wff = theorem sylibr (step 5, step 6) |- ( ( ( ph \/ ps ) -> ( ph <-> ps ) ) -> ( ps -> ph ) ) ;
		step 8 : wff = theorem impbid (step 3, step 7) |- ( ( ( ph \/ ps ) -> ( ph <-> ps ) ) -> ( ph <-> ps ) ) ;
		step 9 : wff = axiom ax-1 () |- ( ( ph <-> ps ) -> ( ( ph \/ ps ) -> ( ph <-> ps ) ) ) ;
		step 10 : wff = theorem impbi (step 8, step 9) |- ( ( ( ph \/ ps ) -> ( ph <-> ps ) ) <-> ( ph <-> ps ) ) ;
		qed prop = step 10 ;
	}

	/*  Law of excluded middle, also called the principle of _tertium non datur_.
	     Theorem *2.11 of [WhiteheadRussell] p. 101.  It says that something is
	     either true or not true; there are no in-between values of truth.  This is
	     an essential distinction of our classical logic and is not a theorem of
	     intuitionistic logic.  */
	theorem exmid (var ph : wff ) 
	{
		prop : wff = |- ( ph \/ -. ph ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of exmid {
		step 1 : wff = theorem id () |- ( -. ph -> -. ph ) ;
		step 2 : wff = theorem orri (step 1) |- ( ph \/ -. ph ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.1 of [WhiteheadRussell] p. 101.  */
	theorem pm2_1 (var ph : wff ) 
	{
		prop : wff = |- ( -. ph \/ ph ) ;
	}

	/*  [7-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_1 {
		step 1 : wff = theorem nega () |- ( -. -. ph -> ph ) ;
		step 2 : wff = theorem orri (step 1) |- ( -. ph \/ ph ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *2.13 of [WhiteheadRussell] p. 101.  */
	theorem pm2_13 (var ph : wff ) 
	{
		prop : wff = |- ( ph \/ -. -. -. ph ) ;
	}

	/*  [4-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_13 {
		step 1 : wff = theorem negb () |- ( -. ph -> -. -. -. ph ) ;
		step 2 : wff = theorem orri (step 1) |- ( ph \/ -. -. -. ph ) ;
		qed prop = step 2 ;
	}

	/*  Law of noncontradiction.  Theorem *3.24 of [WhiteheadRussell] p. 111
	     (who call it the "law of contradiction").  */
	theorem pm3_24 (var ph : wff ) 
	{
		prop : wff = |- -. ( ph /\ -. ph ) ;
	}

	/*  [16-Sep-1993]  */ 
	proof of pm3_24 {
		step 1 : wff = theorem exmid () |- ( -. ph \/ -. -. ph ) ;
		step 2 : wff = theorem ianor () |- ( -. ( ph /\ -. ph ) <-> ( -. ph \/ -. -. ph ) ) ;
		step 3 : wff = theorem mpbir (step 1, step 2) |- -. ( ph /\ -. ph ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *2.26 of [WhiteheadRussell] p. 104.  */
	theorem pm2_26 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ph \/ ( ( ph -> ps ) -> ps ) ) ;
	}

	/*  [5-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm2_26 {
		step 1 : wff = theorem nega () |- ( -. -. ph -> ph ) ;
		step 2 : wff = theorem imim1i (step 1) |- ( ( ph -> ps ) -> ( -. -. ph -> ps ) ) ;
		step 3 : wff = theorem com12 (step 2) |- ( -. -. ph -> ( ( ph -> ps ) -> ps ) ) ;
		step 4 : wff = theorem orri (step 3) |- ( -. ph \/ ( ( ph -> ps ) -> ps ) ) ;
		qed prop = step 4 ;
	}

	/*  Theorem *5.18 of [WhiteheadRussell] p. 124.  This theorem says that
	     logical equivalence is the same as negated "exclusive-or."  */
	theorem pm5_18 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph <-> ps ) <-> -. ( ph <-> -. ps ) ) ;
	}

	/*  [28-Jun-2002]  */ 
	proof of pm5_18 {
		step 1 : wff = theorem bicom () |- ( ( ph <-> ps ) <-> ( ps <-> ph ) ) ;
		step 2 : wff = theorem bicom () |- ( ( ph <-> -. ps ) <-> ( -. ps <-> ph ) ) ;
		step 3 : wff = theorem pm2_61 () |- ( ( ps -> ph ) -> ( ( -. ps -> ph ) -> ph ) ) ;
		step 4 : wff = theorem pm2_65 () |- ( ( ps -> ph ) -> ( ( ps -> -. ph ) -> -. ps ) ) ;
		step 5 : wff = theorem con2 () |- ( ( ph -> -. ps ) -> ( ps -> -. ph ) ) ;
		step 6 : wff = theorem syl5 (step 4, step 5) |- ( ( ps -> ph ) -> ( ( ph -> -. ps ) -> -. ps ) ) ;
		step 7 : wff = theorem anim12d (step 3, step 6) |- ( ( ps -> ph ) -> ( ( ( -. ps -> ph ) /\ ( ph -> -. ps ) ) -> ( ph /\ -. ps ) ) ) ;
		step 8 : wff = theorem bi () |- ( ( -. ps <-> ph ) <-> ( ( -. ps -> ph ) /\ ( ph -> -. ps ) ) ) ;
		step 9 : wff = theorem syl5ib (step 7, step 8) |- ( ( ps -> ph ) -> ( ( -. ps <-> ph ) -> ( ph /\ -. ps ) ) ) ;
		step 10 : wff = theorem annim () |- ( ( ph /\ -. ps ) <-> -. ( ph -> ps ) ) ;
		step 11 : wff = theorem syl6ib (step 9, step 10) |- ( ( ps -> ph ) -> ( ( -. ps <-> ph ) -> -. ( ph -> ps ) ) ) ;
		step 12 : wff = theorem com12 (step 11) |- ( ( -. ps <-> ph ) -> ( ( ps -> ph ) -> -. ( ph -> ps ) ) ) ;
		step 13 : wff = theorem imnan () |- ( ( ( ps -> ph ) -> -. ( ph -> ps ) ) <-> -. ( ( ps -> ph ) /\ ( ph -> ps ) ) ) ;
		step 14 : wff = theorem sylib (step 12, step 13) |- ( ( -. ps <-> ph ) -> -. ( ( ps -> ph ) /\ ( ph -> ps ) ) ) ;
		step 15 : wff = theorem bi () |- ( ( ps <-> ph ) <-> ( ( ps -> ph ) /\ ( ph -> ps ) ) ) ;
		step 16 : wff = theorem negbii (step 15) |- ( -. ( ps <-> ph ) <-> -. ( ( ps -> ph ) /\ ( ph -> ps ) ) ) ;
		step 17 : wff = theorem sylibr (step 14, step 16) |- ( ( -. ps <-> ph ) -> -. ( ps <-> ph ) ) ;
		step 18 : wff = theorem bi () |- ( ( ps <-> ph ) <-> ( ( ps -> ph ) /\ ( ph -> ps ) ) ) ;
		step 19 : wff = theorem negbii (step 18) |- ( -. ( ps <-> ph ) <-> -. ( ( ps -> ph ) /\ ( ph -> ps ) ) ) ;
		step 20 : wff = theorem pm2_5 () |- ( -. ( ps -> ph ) -> ( -. ps -> ph ) ) ;
		step 21 : wff = theorem annim () |- ( ( ps /\ -. ph ) <-> -. ( ps -> ph ) ) ;
		step 22 : wff = theorem pm2_21 () |- ( -. ph -> ( ph -> -. ps ) ) ;
		step 23 : wff = theorem adantl (step 22) |- ( ( ps /\ -. ph ) -> ( ph -> -. ps ) ) ;
		step 24 : wff = theorem sylbir (step 21, step 23) |- ( -. ( ps -> ph ) -> ( ph -> -. ps ) ) ;
		step 25 : wff = theorem jca (step 20, step 24) |- ( -. ( ps -> ph ) -> ( ( -. ps -> ph ) /\ ( ph -> -. ps ) ) ) ;
		step 26 : wff = theorem annim () |- ( ( ph /\ -. ps ) <-> -. ( ph -> ps ) ) ;
		step 27 : wff = axiom ax-1 () |- ( ph -> ( -. ps -> ph ) ) ;
		step 28 : wff = theorem adantr (step 27) |- ( ( ph /\ -. ps ) -> ( -. ps -> ph ) ) ;
		step 29 : wff = theorem sylbir (step 26, step 28) |- ( -. ( ph -> ps ) -> ( -. ps -> ph ) ) ;
		step 30 : wff = theorem pm2_51 () |- ( -. ( ph -> ps ) -> ( ph -> -. ps ) ) ;
		step 31 : wff = theorem jca (step 29, step 30) |- ( -. ( ph -> ps ) -> ( ( -. ps -> ph ) /\ ( ph -> -. ps ) ) ) ;
		step 32 : wff = theorem jaoi (step 25, step 31) |- ( ( -. ( ps -> ph ) \/ -. ( ph -> ps ) ) -> ( ( -. ps -> ph ) /\ ( ph -> -. ps ) ) ) ;
		step 33 : wff = theorem ianor () |- ( -. ( ( ps -> ph ) /\ ( ph -> ps ) ) <-> ( -. ( ps -> ph ) \/ -. ( ph -> ps ) ) ) ;
		step 34 : wff = theorem bi () |- ( ( -. ps <-> ph ) <-> ( ( -. ps -> ph ) /\ ( ph -> -. ps ) ) ) ;
		step 35 : wff = theorem _3imtr4 (step 32, step 33, step 34) |- ( -. ( ( ps -> ph ) /\ ( ph -> ps ) ) -> ( -. ps <-> ph ) ) ;
		step 36 : wff = theorem sylbi (step 19, step 35) |- ( -. ( ps <-> ph ) -> ( -. ps <-> ph ) ) ;
		step 37 : wff = theorem impbi (step 17, step 36) |- ( ( -. ps <-> ph ) <-> -. ( ps <-> ph ) ) ;
		step 38 : wff = theorem bitr (step 2, step 37) |- ( ( ph <-> -. ps ) <-> -. ( ps <-> ph ) ) ;
		step 39 : wff = theorem con2bii (step 38) |- ( ( ps <-> ph ) <-> -. ( ph <-> -. ps ) ) ;
		step 40 : wff = theorem bitr (step 1, step 39) |- ( ( ph <-> ps ) <-> -. ( ph <-> -. ps ) ) ;
		qed prop = step 40 ;
	}

	/*  Move negation outside of biconditional.  Compare Theorem *5.18 of
	     [WhiteheadRussell] p. 124.  */
	theorem nbbn (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( -. ph <-> ps ) <-> -. ( ph <-> ps ) ) ;
	}

	/*  [27-Jun-2002]  */ 
	proof of nbbn {
		step 1 : wff = theorem bicom () |- ( ( -. ph <-> ps ) <-> ( ps <-> -. ph ) ) ;
		step 2 : wff = theorem bicom () |- ( ( ph <-> ps ) <-> ( ps <-> ph ) ) ;
		step 3 : wff = theorem pm5_18 () |- ( ( ps <-> ph ) <-> -. ( ps <-> -. ph ) ) ;
		step 4 : wff = theorem bitr (step 2, step 3) |- ( ( ph <-> ps ) <-> -. ( ps <-> -. ph ) ) ;
		step 5 : wff = theorem con2bii (step 4) |- ( ( ps <-> -. ph ) <-> -. ( ph <-> ps ) ) ;
		step 6 : wff = theorem bitr (step 1, step 5) |- ( ( -. ph <-> ps ) <-> -. ( ph <-> ps ) ) ;
		qed prop = step 6 ;
	}

	/*  Theorem *5.11 of [WhiteheadRussell] p. 123.  */
	theorem pm5_11 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) \/ ( -. ph -> ps ) ) ;
	}

	/*  [17-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_11 {
		step 1 : wff = theorem pm2_5 () |- ( -. ( ph -> ps ) -> ( -. ph -> ps ) ) ;
		step 2 : wff = theorem orri (step 1) |- ( ( ph -> ps ) \/ ( -. ph -> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *5.12 of [WhiteheadRussell] p. 123.  */
	theorem pm5_12 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) \/ ( ph -> -. ps ) ) ;
	}

	/*  [17-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_12 {
		step 1 : wff = theorem pm2_51 () |- ( -. ( ph -> ps ) -> ( ph -> -. ps ) ) ;
		step 2 : wff = theorem orri (step 1) |- ( ( ph -> ps ) \/ ( ph -> -. ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *5.13 of [WhiteheadRussell] p. 123.  */
	theorem pm5_13 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) \/ ( ps -> ph ) ) ;
	}

	/*  [7-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_13 {
		step 1 : wff = theorem pm2_521 () |- ( -. ( ph -> ps ) -> ( ps -> ph ) ) ;
		step 2 : wff = theorem orri (step 1) |- ( ( ph -> ps ) \/ ( ps -> ph ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *5.14 of [WhiteheadRussell] p. 123.  */
	theorem pm5_14 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) \/ ( ps -> ch ) ) ;
	}

	/*  [17-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_14 {
		step 1 : wff = axiom ax-1 () |- ( ps -> ( ph -> ps ) ) ;
		step 2 : wff = theorem con3i (step 1) |- ( -. ( ph -> ps ) -> -. ps ) ;
		step 3 : wff = theorem pm2_21d (step 2) |- ( -. ( ph -> ps ) -> ( ps -> ch ) ) ;
		step 4 : wff = theorem orri (step 3) |- ( ( ph -> ps ) \/ ( ps -> ch ) ) ;
		qed prop = step 4 ;
	}

	/*  Theorem *5.15 of [WhiteheadRussell] p. 124.  */
	theorem pm5_15 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph <-> ps ) \/ ( ph <-> -. ps ) ) ;
	}

	/*  [1-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_15 {
		step 1 : wff = theorem pm5_18 () |- ( ( ph <-> ps ) <-> -. ( ph <-> -. ps ) ) ;
		step 2 : wff = theorem biimpr (step 1) |- ( -. ( ph <-> -. ps ) -> ( ph <-> ps ) ) ;
		step 3 : wff = theorem con1i (step 2) |- ( -. ( ph <-> ps ) -> ( ph <-> -. ps ) ) ;
		step 4 : wff = theorem orri (step 3) |- ( ( ph <-> ps ) \/ ( ph <-> -. ps ) ) ;
		qed prop = step 4 ;
	}

	/*  Theorem *5.16 of [WhiteheadRussell] p. 124.  */
	theorem pm5_16 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- -. ( ( ph <-> ps ) /\ ( ph <-> -. ps ) ) ;
	}

	/*  [17-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_16 {
		step 1 : wff = theorem pm5_18 () |- ( ( ph <-> ps ) <-> -. ( ph <-> -. ps ) ) ;
		step 2 : wff = theorem biimp (step 1) |- ( ( ph <-> ps ) -> -. ( ph <-> -. ps ) ) ;
		step 3 : wff = theorem pm4_62 () |- ( ( ( ph <-> ps ) -> -. ( ph <-> -. ps ) ) <-> ( -. ( ph <-> ps ) \/ -. ( ph <-> -. ps ) ) ) ;
		step 4 : wff = theorem mpbi (step 2, step 3) |- ( -. ( ph <-> ps ) \/ -. ( ph <-> -. ps ) ) ;
		step 5 : wff = theorem ianor () |- ( -. ( ( ph <-> ps ) /\ ( ph <-> -. ps ) ) <-> ( -. ( ph <-> ps ) \/ -. ( ph <-> -. ps ) ) ) ;
		step 6 : wff = theorem mpbir (step 4, step 5) |- -. ( ( ph <-> ps ) /\ ( ph <-> -. ps ) ) ;
		qed prop = step 6 ;
	}

	/*  Theorem *5.17 of [WhiteheadRussell] p. 124.  */
	theorem pm5_17 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ps ) /\ -. ( ph /\ ps ) ) <-> ( ph <-> -. ps ) ) ;
	}

	/*  [22-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_17 {
		step 1 : wff = theorem orcom () |- ( ( ph \/ ps ) <-> ( ps \/ ph ) ) ;
		step 2 : wff = definition df-or () |- ( ( ps \/ ph ) <-> ( -. ps -> ph ) ) ;
		step 3 : wff = theorem bitr (step 1, step 2) |- ( ( ph \/ ps ) <-> ( -. ps -> ph ) ) ;
		step 4 : wff = theorem imnan () |- ( ( ph -> -. ps ) <-> -. ( ph /\ ps ) ) ;
		step 5 : wff = theorem bicomi (step 4) |- ( -. ( ph /\ ps ) <-> ( ph -> -. ps ) ) ;
		step 6 : wff = theorem anbi12i (step 3, step 5) |- ( ( ( ph \/ ps ) /\ -. ( ph /\ ps ) ) <-> ( ( -. ps -> ph ) /\ ( ph -> -. ps ) ) ) ;
		step 7 : wff = theorem bi () |- ( ( -. ps <-> ph ) <-> ( ( -. ps -> ph ) /\ ( ph -> -. ps ) ) ) ;
		step 8 : wff = theorem bicom () |- ( ( -. ps <-> ph ) <-> ( ph <-> -. ps ) ) ;
		step 9 : wff = theorem _3bitr2 (step 6, step 7, step 8) |- ( ( ( ph \/ ps ) /\ -. ( ph /\ ps ) ) <-> ( ph <-> -. ps ) ) ;
		qed prop = step 9 ;
	}

	/*  Theorem *5.19 of [WhiteheadRussell] p. 124.  */
	theorem pm5_19 (var ph : wff ) 
	{
		prop : wff = |- -. ( ph <-> -. ph ) ;
	}

	/*  [1-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_19 {
		step 1 : wff = theorem pm4_2 () |- ( ph <-> ph ) ;
		step 2 : wff = theorem pm5_18 () |- ( ( ph <-> ph ) <-> -. ( ph <-> -. ph ) ) ;
		step 3 : wff = theorem mpbi (step 1, step 2) |- -. ( ph <-> -. ph ) ;
		qed prop = step 3 ;
	}

	/*  An alternate definition of the biconditional.  Theorem *5.23 of
	     [WhiteheadRussell] p. 124.  */
	theorem dfbi (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph <-> ps ) <-> ( ( ph /\ ps ) \/ ( -. ph /\ -. ps ) ) ) ;
	}

	/*  [27-Jun-2002]  */ 
	proof of dfbi {
		step 1 : wff = theorem pm5_18 () |- ( ( ph <-> ps ) <-> -. ( ph <-> -. ps ) ) ;
		step 2 : wff = theorem imnan () |- ( ( ph -> -. ps ) <-> -. ( ph /\ ps ) ) ;
		step 3 : wff = theorem bi2_15 () |- ( ( -. ps -> ph ) <-> ( -. ph -> ps ) ) ;
		step 4 : wff = theorem iman () |- ( ( -. ph -> ps ) <-> -. ( -. ph /\ -. ps ) ) ;
		step 5 : wff = theorem bitr (step 3, step 4) |- ( ( -. ps -> ph ) <-> -. ( -. ph /\ -. ps ) ) ;
		step 6 : wff = theorem anbi12i (step 2, step 5) |- ( ( ( ph -> -. ps ) /\ ( -. ps -> ph ) ) <-> ( -. ( ph /\ ps ) /\ -. ( -. ph /\ -. ps ) ) ) ;
		step 7 : wff = theorem bi () |- ( ( ph <-> -. ps ) <-> ( ( ph -> -. ps ) /\ ( -. ps -> ph ) ) ) ;
		step 8 : wff = theorem ioran () |- ( -. ( ( ph /\ ps ) \/ ( -. ph /\ -. ps ) ) <-> ( -. ( ph /\ ps ) /\ -. ( -. ph /\ -. ps ) ) ) ;
		step 9 : wff = theorem _3bitr4r (step 6, step 7, step 8) |- ( -. ( ( ph /\ ps ) \/ ( -. ph /\ -. ps ) ) <-> ( ph <-> -. ps ) ) ;
		step 10 : wff = theorem con1bii (step 9) |- ( -. ( ph <-> -. ps ) <-> ( ( ph /\ ps ) \/ ( -. ph /\ -. ps ) ) ) ;
		step 11 : wff = theorem bitr (step 1, step 10) |- ( ( ph <-> ps ) <-> ( ( ph /\ ps ) \/ ( -. ph /\ -. ps ) ) ) ;
		qed prop = step 11 ;
	}

	/*  Two ways to express "exclusive or."  Theorem *5.22 of [WhiteheadRussell]
	     p. 124.  */
	theorem xor (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph <-> ps ) <-> ( ( ph /\ -. ps ) \/ ( ps /\ -. ph ) ) ) ;
	}

	/*  [11-Jan-2005]  */ /*  [3-Jan-2005]  */ 
	proof of xor {
		step 1 : wff = theorem dfbi () |- ( ( -. ph <-> ps ) <-> ( ( -. ph /\ ps ) \/ ( -. -. ph /\ -. ps ) ) ) ;
		step 2 : wff = theorem nbbn () |- ( ( -. ph <-> ps ) <-> -. ( ph <-> ps ) ) ;
		step 3 : wff = theorem ancom () |- ( ( ps /\ -. ph ) <-> ( -. ph /\ ps ) ) ;
		step 4 : wff = theorem pm4_13 () |- ( ph <-> -. -. ph ) ;
		step 5 : wff = theorem anbi1i (step 4) |- ( ( ph /\ -. ps ) <-> ( -. -. ph /\ -. ps ) ) ;
		step 6 : wff = theorem orbi12i (step 3, step 5) |- ( ( ( ps /\ -. ph ) \/ ( ph /\ -. ps ) ) <-> ( ( -. ph /\ ps ) \/ ( -. -. ph /\ -. ps ) ) ) ;
		step 7 : wff = theorem orcom () |- ( ( ( ps /\ -. ph ) \/ ( ph /\ -. ps ) ) <-> ( ( ph /\ -. ps ) \/ ( ps /\ -. ph ) ) ) ;
		step 8 : wff = theorem bitr3 (step 6, step 7) |- ( ( ( -. ph /\ ps ) \/ ( -. -. ph /\ -. ps ) ) <-> ( ( ph /\ -. ps ) \/ ( ps /\ -. ph ) ) ) ;
		step 9 : wff = theorem _3bitr3 (step 1, step 2, step 8) |- ( -. ( ph <-> ps ) <-> ( ( ph /\ -. ps ) \/ ( ps /\ -. ph ) ) ) ;
		qed prop = step 9 ;
	}

	/*  Theorem *5.24 of [WhiteheadRussell] p. 124.  */
	theorem pm5_24 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ( ph /\ ps ) \/ ( -. ph /\ -. ps ) ) <-> ( ( ph /\ -. ps ) \/ ( ps /\ -. ph ) ) ) ;
	}

	/*  [11-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_24 {
		step 1 : wff = theorem dfbi () |- ( ( ph <-> ps ) <-> ( ( ph /\ ps ) \/ ( -. ph /\ -. ps ) ) ) ;
		step 2 : wff = theorem negbii (step 1) |- ( -. ( ph <-> ps ) <-> -. ( ( ph /\ ps ) \/ ( -. ph /\ -. ps ) ) ) ;
		step 3 : wff = theorem xor () |- ( -. ( ph <-> ps ) <-> ( ( ph /\ -. ps ) \/ ( ps /\ -. ph ) ) ) ;
		step 4 : wff = theorem bitr3 (step 2, step 3) |- ( -. ( ( ph /\ ps ) \/ ( -. ph /\ -. ps ) ) <-> ( ( ph /\ -. ps ) \/ ( ps /\ -. ph ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Two ways to express "exclusive or."  */
	theorem xor2 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph <-> ps ) <-> ( ( ph \/ ps ) /\ -. ( ph /\ ps ) ) ) ;
	}

	/*  [11-Feb-2005]  */ /*  [3-Jan-2005]  */ 
	proof of xor2 {
		step 1 : wff = theorem xor () |- ( -. ( ph <-> ps ) <-> ( ( ph /\ -. ps ) \/ ( ps /\ -. ph ) ) ) ;
		step 2 : wff = theorem ioran () |- ( -. ( ( ph /\ ps ) \/ ( -. ph /\ -. ps ) ) <-> ( -. ( ph /\ ps ) /\ -. ( -. ph /\ -. ps ) ) ) ;
		step 3 : wff = theorem pm5_24 () |- ( -. ( ( ph /\ ps ) \/ ( -. ph /\ -. ps ) ) <-> ( ( ph /\ -. ps ) \/ ( ps /\ -. ph ) ) ) ;
		step 4 : wff = theorem oran () |- ( ( ph \/ ps ) <-> -. ( -. ph /\ -. ps ) ) ;
		step 5 : wff = theorem anbi2i (step 4) |- ( ( -. ( ph /\ ps ) /\ ( ph \/ ps ) ) <-> ( -. ( ph /\ ps ) /\ -. ( -. ph /\ -. ps ) ) ) ;
		step 6 : wff = theorem ancom () |- ( ( -. ( ph /\ ps ) /\ ( ph \/ ps ) ) <-> ( ( ph \/ ps ) /\ -. ( ph /\ ps ) ) ) ;
		step 7 : wff = theorem bitr3 (step 5, step 6) |- ( ( -. ( ph /\ ps ) /\ -. ( -. ph /\ -. ps ) ) <-> ( ( ph \/ ps ) /\ -. ( ph /\ ps ) ) ) ;
		step 8 : wff = theorem _3bitr3 (step 2, step 3, step 7) |- ( ( ( ph /\ -. ps ) \/ ( ps /\ -. ph ) ) <-> ( ( ph \/ ps ) /\ -. ( ph /\ ps ) ) ) ;
		step 9 : wff = theorem bitr (step 1, step 8) |- ( -. ( ph <-> ps ) <-> ( ( ph \/ ps ) /\ -. ( ph /\ ps ) ) ) ;
		qed prop = step 9 ;
	}

	/*  Two ways to express "exclusive or."  */
	theorem xor3 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ( ph <-> ps ) <-> ( ph <-> -. ps ) ) ;
	}

	/*  [4-Jan-2006]  */ /*  [1-Jan-2006]  */ 
	proof of xor3 {
		step 1 : wff = theorem pm5_18 () |- ( ( ph <-> ps ) <-> -. ( ph <-> -. ps ) ) ;
		step 2 : wff = theorem con2bii (step 1) |- ( ( ph <-> -. ps ) <-> -. ( ph <-> ps ) ) ;
		step 3 : wff = theorem bicomi (step 2) |- ( -. ( ph <-> ps ) <-> ( ph <-> -. ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *5.55 of [WhiteheadRussell] p. 125.  */
	theorem pm5_55 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ps ) <-> ph ) \/ ( ( ph \/ ps ) <-> ps ) ) ;
	}

	/*  [7-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_55 {
		step 1 : wff = theorem pm5_13 () |- ( ( ps -> ph ) \/ ( ph -> ps ) ) ;
		step 2 : wff = theorem pm4_72 () |- ( ( ps -> ph ) <-> ( ph <-> ( ps \/ ph ) ) ) ;
		step 3 : wff = theorem orcom () |- ( ( ps \/ ph ) <-> ( ph \/ ps ) ) ;
		step 4 : wff = theorem bibi2i (step 3) |- ( ( ph <-> ( ps \/ ph ) ) <-> ( ph <-> ( ph \/ ps ) ) ) ;
		step 5 : wff = theorem bicom () |- ( ( ph <-> ( ph \/ ps ) ) <-> ( ( ph \/ ps ) <-> ph ) ) ;
		step 6 : wff = theorem _3bitr (step 2, step 4, step 5) |- ( ( ps -> ph ) <-> ( ( ph \/ ps ) <-> ph ) ) ;
		step 7 : wff = theorem pm4_72 () |- ( ( ph -> ps ) <-> ( ps <-> ( ph \/ ps ) ) ) ;
		step 8 : wff = theorem bicom () |- ( ( ps <-> ( ph \/ ps ) ) <-> ( ( ph \/ ps ) <-> ps ) ) ;
		step 9 : wff = theorem bitr (step 7, step 8) |- ( ( ph -> ps ) <-> ( ( ph \/ ps ) <-> ps ) ) ;
		step 10 : wff = theorem orbi12i (step 6, step 9) |- ( ( ( ps -> ph ) \/ ( ph -> ps ) ) <-> ( ( ( ph \/ ps ) <-> ph ) \/ ( ( ph \/ ps ) <-> ps ) ) ) ;
		step 11 : wff = theorem mpbi (step 1, step 10) |- ( ( ( ph \/ ps ) <-> ph ) \/ ( ( ph \/ ps ) <-> ps ) ) ;
		qed prop = step 11 ;
	}

	/* 
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	        Miscellaneous theorems of propositional calculus
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	 */
	/*  Two propositions are equivalent if they are both true.  Theorem *5.1 of
	     [WhiteheadRussell] p. 123.  */
	theorem pm5_1 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps ) -> ( ph <-> ps ) ) ;
	}

	/*  [21-May-1994]  */ 
	proof of pm5_1 {
		step 1 : wff = theorem pm5_501 () |- ( ph -> ( ps <-> ( ph <-> ps ) ) ) ;
		step 2 : wff = theorem biimpa (step 1) |- ( ( ph /\ ps ) -> ( ph <-> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Two propositions are equivalent if they are both false.  Theorem *5.21 of
	     [WhiteheadRussell] p. 124.  */
	theorem pm5_21 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( -. ph /\ -. ps ) -> ( ph <-> ps ) ) ;
	}

	/*  [21-May-1994]  */ 
	proof of pm5_21 {
		step 1 : wff = theorem pm5_1 () |- ( ( -. ph /\ -. ps ) -> ( -. ph <-> -. ps ) ) ;
		step 2 : wff = theorem con4bid (step 1) |- ( ( -. ph /\ -. ps ) -> ( ph <-> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Two propositions implying a false one are equivalent.  */
	theorem pm5_21ni (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ch -> ps ) ;
		-----------------
		prop : wff = |- ( -. ps -> ( ph <-> ch ) ) ;
	}

	/*  [16-Feb-1996]  */ 
	proof of pm5_21ni {
		step 1 : wff = theorem pm5_21 () |- ( ( -. ph /\ -. ch ) -> ( ph <-> ch ) ) ;
		step 2 : wff = theorem con3i (hyp 1) |- ( -. ps -> -. ph ) ;
		step 3 : wff = theorem con3i (hyp 2) |- ( -. ps -> -. ch ) ;
		step 4 : wff = theorem sylanc (step 1, step 2, step 3) |- ( -. ps -> ( ph <-> ch ) ) ;
		qed prop = step 4 ;
	}

	/*  Eliminate an antecedent implied by each side of a biconditional.  */
	theorem pm5_21nii (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ch -> ps ) ;
		hyp 3 : wff = |- ( ps -> ( ph <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph <-> ch ) ;
	}

	/*  [21-May-1999]  */ 
	proof of pm5_21nii {
		step 1 : wff = theorem pm5_21ni (hyp 1, hyp 2) |- ( -. ps -> ( ph <-> ch ) ) ;
		step 2 : wff = theorem pm2_61i (hyp 3, step 1) |- ( ph <-> ch ) ;
		qed prop = step 2 ;
	}

	/*  Eliminate an antecedent implied by each side of a biconditional.  */
	theorem pm5_21nd (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> th ) ;
		hyp 2 : wff = |- ( ( ph /\ ch ) -> th ) ;
		hyp 3 : wff = |- ( th -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps <-> ch ) ) ;
	}

	/*  [23-Nov-2005]  */ /*  [20-Nov-2005]  */ 
	proof of pm5_21nd {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> th ) ) ;
		step 2 : wff = theorem con3d (step 1) |- ( ph -> ( -. th -> -. ps ) ) ;
		step 3 : wff = theorem ex (hyp 2) |- ( ph -> ( ch -> th ) ) ;
		step 4 : wff = theorem con3d (step 3) |- ( ph -> ( -. th -> -. ch ) ) ;
		step 5 : wff = theorem jcad (step 2, step 4) |- ( ph -> ( -. th -> ( -. ps /\ -. ch ) ) ) ;
		step 6 : wff = theorem pm5_21 () |- ( ( -. ps /\ -. ch ) -> ( ps <-> ch ) ) ;
		step 7 : wff = theorem syl6 (step 5, step 6) |- ( ph -> ( -. th -> ( ps <-> ch ) ) ) ;
		step 8 : wff = theorem pm2_61d2 (step 7, hyp 3) |- ( ph -> ( ps <-> ch ) ) ;
		qed prop = step 8 ;
	}

	/*  Transfer negation via an equivalence.  */
	theorem bibif (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ps -> ( ( ph <-> ps ) <-> -. ph ) ) ;
	}

	/*  [7-Nov-2007]  */ /*  [3-Oct-2007]  */ 
	proof of bibif {
		step 1 : wff = theorem bi1 () |- ( ( ph <-> ps ) -> ( ph -> ps ) ) ;
		step 2 : wff = theorem con3d (step 1) |- ( ( ph <-> ps ) -> ( -. ps -> -. ph ) ) ;
		step 3 : wff = theorem com12 (step 2) |- ( -. ps -> ( ( ph <-> ps ) -> -. ph ) ) ;
		step 4 : wff = theorem pm5_21 () |- ( ( -. ph /\ -. ps ) -> ( ph <-> ps ) ) ;
		step 5 : wff = theorem expcom (step 4) |- ( -. ps -> ( -. ph -> ( ph <-> ps ) ) ) ;
		step 6 : wff = theorem impbid (step 3, step 5) |- ( -. ps -> ( ( ph <-> ps ) <-> -. ph ) ) ;
		qed prop = step 6 ;
	}

	/*  Theorem *5.35 of [WhiteheadRussell] p. 125.  */
	theorem pm5_35 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) /\ ( ph -> ch ) ) -> ( ph -> ( ps <-> ch ) ) ) ;
	}

	/*  [28-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_35 {
		step 1 : wff = theorem pm5_1 () |- ( ( ( ph -> ps ) /\ ( ph -> ch ) ) -> ( ( ph -> ps ) <-> ( ph -> ch ) ) ) ;
		step 2 : wff = theorem pm5_74rd (step 1) |- ( ( ( ph -> ps ) /\ ( ph -> ch ) ) -> ( ph -> ( ps <-> ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *5.54 of [WhiteheadRussell] p. 125.  */
	theorem pm5_54 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) <-> ph ) \/ ( ( ph /\ ps ) <-> ps ) ) ;
	}

	/*  [28-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_54 {
		step 1 : wff = theorem pm5_1 () |- ( ( ( ph /\ ps ) /\ ph ) -> ( ( ph /\ ps ) <-> ph ) ) ;
		step 2 : wff = theorem anabss1 (step 1) |- ( ( ph /\ ps ) -> ( ( ph /\ ps ) <-> ph ) ) ;
		step 3 : wff = theorem iba () |- ( ps -> ( ph <-> ( ph /\ ps ) ) ) ;
		step 4 : wff = theorem bicomd (step 3) |- ( ps -> ( ( ph /\ ps ) <-> ph ) ) ;
		step 5 : wff = theorem pm5_21ni (step 2, step 4) |- ( -. ( ( ph /\ ps ) <-> ph ) -> ( ( ph /\ ps ) <-> ps ) ) ;
		step 6 : wff = theorem orri (step 5) |- ( ( ( ph /\ ps ) <-> ph ) \/ ( ( ph /\ ps ) <-> ps ) ) ;
		qed prop = step 6 ;
	}

	/*  Elimination of antecedents in an implication. (The proof was shortened by
	     Juha Arpiainen, 19-Jan-06.)  */
	theorem elimant (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) /\ ( ( ps -> ch ) -> ( ph -> th ) ) ) -> ( ph -> ( ch -> th ) ) ) ;
	}

	/*  [21-Jan-2006]  */ /*  [13-Oct-1999]  */ 
	proof of elimant {
		step 1 : wff = theorem pm3_27 () |- ( ( ( ph -> ps ) /\ ( ( ps -> ch ) -> ( ph -> th ) ) ) -> ( ( ps -> ch ) -> ( ph -> th ) ) ) ;
		step 2 : wff = axiom ax-1 () |- ( ch -> ( ps -> ch ) ) ;
		step 3 : wff = theorem syl5 (step 1, step 2) |- ( ( ( ph -> ps ) /\ ( ( ps -> ch ) -> ( ph -> th ) ) ) -> ( ch -> ( ph -> th ) ) ) ;
		step 4 : wff = theorem com23 (step 3) |- ( ( ( ph -> ps ) /\ ( ( ps -> ch ) -> ( ph -> th ) ) ) -> ( ph -> ( ch -> th ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Move conjunction outside of biconditional.  */
	theorem baib (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ( ps /\ ch ) ) ;
		-----------------
		prop : wff = |- ( ps -> ( ph <-> ch ) ) ;
	}

	/*  [13-May-1999]  */ 
	proof of baib {
		step 1 : wff = theorem ibar () |- ( ps -> ( ch <-> ( ps /\ ch ) ) ) ;
		step 2 : wff = theorem syl6rbbr (step 1, hyp 1) |- ( ps -> ( ph <-> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Move conjunction outside of biconditional.  */
	theorem baibr (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ( ps /\ ch ) ) ;
		-----------------
		prop : wff = |- ( ps -> ( ch <-> ph ) ) ;
	}

	/*  [11-Jul-1994]  */ 
	proof of baibr {
		step 1 : wff = theorem baib (hyp 1) |- ( ps -> ( ph <-> ch ) ) ;
		step 2 : wff = theorem bicomd (step 1) |- ( ps -> ( ch <-> ph ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *5.44 of [WhiteheadRussell] p. 125.  */
	theorem pm5_44 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( ph -> ch ) <-> ( ph -> ( ps /\ ch ) ) ) ) ;
	}

	/*  [28-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_44 {
		step 1 : wff = theorem jcab () |- ( ( ph -> ( ps /\ ch ) ) <-> ( ( ph -> ps ) /\ ( ph -> ch ) ) ) ;
		step 2 : wff = theorem baibr (step 1) |- ( ( ph -> ps ) -> ( ( ph -> ch ) <-> ( ph -> ( ps /\ ch ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Conjunction in antecedent versus disjunction in consequent.  Theorem *5.6
	     of [WhiteheadRussell] p. 125.  */
	theorem pm5_6 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ -. ps ) -> ch ) <-> ( ph -> ( ps \/ ch ) ) ) ;
	}

	/*  [22-Mar-2005]  */ /*  [8-Jun-1994]  */ 
	proof of pm5_6 {
		step 1 : wff = theorem impexp () |- ( ( ( ph /\ -. ps ) -> ch ) <-> ( ph -> ( -. ps -> ch ) ) ) ;
		step 2 : wff = definition df-or () |- ( ( ps \/ ch ) <-> ( -. ps -> ch ) ) ;
		step 3 : wff = theorem imbi2i (step 2) |- ( ( ph -> ( ps \/ ch ) ) <-> ( ph -> ( -. ps -> ch ) ) ) ;
		step 4 : wff = theorem bitr4 (step 1, step 3) |- ( ( ( ph /\ -. ps ) -> ch ) <-> ( ph -> ( ps \/ ch ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Theorem to move a conjunct in and out of a negation.  */
	theorem nan (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> -. ( ps /\ ch ) ) <-> ( ( ph /\ ps ) -> -. ch ) ) ;
	}

	/*  [9-Nov-2003]  */ /*  [9-Nov-2003]  */ 
	proof of nan {
		step 1 : wff = theorem impexp () |- ( ( ( ph /\ ps ) -> -. ch ) <-> ( ph -> ( ps -> -. ch ) ) ) ;
		step 2 : wff = theorem imnan () |- ( ( ps -> -. ch ) <-> -. ( ps /\ ch ) ) ;
		step 3 : wff = theorem imbi2i (step 2) |- ( ( ph -> ( ps -> -. ch ) ) <-> ( ph -> -. ( ps /\ ch ) ) ) ;
		step 4 : wff = theorem bitr2 (step 1, step 3) |- ( ( ph -> -. ( ps /\ ch ) ) <-> ( ( ph /\ ps ) -> -. ch ) ) ;
		qed prop = step 4 ;
	}

	/*  Change disjunction in consequent to conjunction in antecedent.  */
	theorem orcanai (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps \/ ch ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ -. ps ) -> ch ) ;
	}

	/*  [8-Jun-1994]  */ 
	proof of orcanai {
		step 1 : wff = theorem ord (hyp 1) |- ( ph -> ( -. ps -> ch ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ph /\ -. ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Introduction of conjunct inside of a contradiction.  */
	theorem intnan (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- -. ph ;
		-----------------
		prop : wff = |- -. ( ps /\ ph ) ;
	}

	/*  [16-Sep-1993]  */ 
	proof of intnan {
		step 1 : wff = theorem pm3_27 () |- ( ( ps /\ ph ) -> ph ) ;
		step 2 : wff = theorem mto (hyp 1, step 1) |- -. ( ps /\ ph ) ;
		qed prop = step 2 ;
	}

	/*  Introduction of conjunct inside of a contradiction.  */
	theorem intnanr (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- -. ph ;
		-----------------
		prop : wff = |- -. ( ph /\ ps ) ;
	}

	/*  [3-Apr-1995]  */ 
	proof of intnanr {
		step 1 : wff = theorem pm3_26 () |- ( ( ph /\ ps ) -> ph ) ;
		step 2 : wff = theorem mto (hyp 1, step 1) |- -. ( ph /\ ps ) ;
		qed prop = step 2 ;
	}

	/*  Introduction of conjunct inside of a contradiction.  */
	theorem intnand (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> -. ps ) ;
		-----------------
		prop : wff = |- ( ph -> -. ( ch /\ ps ) ) ;
	}

	/*  [12-Jul-2005]  */ /*  [10-Jul-2005]  */ 
	proof of intnand {
		step 1 : wff = theorem pm3_27 () |- ( ( ch /\ ps ) -> ps ) ;
		step 2 : wff = theorem nsyl (hyp 1, step 1) |- ( ph -> -. ( ch /\ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Introduction of conjunct inside of a contradiction.  */
	theorem intnanrd (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> -. ps ) ;
		-----------------
		prop : wff = |- ( ph -> -. ( ps /\ ch ) ) ;
	}

	/*  [12-Jul-2005]  */ /*  [10-Jul-2005]  */ 
	proof of intnanrd {
		step 1 : wff = theorem pm3_26 () |- ( ( ps /\ ch ) -> ps ) ;
		step 2 : wff = theorem nsyl (hyp 1, step 1) |- ( ph -> -. ( ps /\ ch ) ) ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mpan (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ps -> ch ) ;
	}

	/*  [30-Aug-1993]  */ 
	proof of mpan {
		step 1 : wff = theorem ex (hyp 2) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ps -> ch ) ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mpan2 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ps ;
		hyp 2 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [16-Sep-1993]  */ 
	proof of mpan2 {
		step 1 : wff = theorem ex (hyp 2) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem mpi (hyp 1, step 1) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mp2an (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- ps ;
		hyp 3 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ch ;
	}

	/*  [13-Apr-1995]  */ 
	proof of mp2an {
		step 1 : wff = theorem mpan (hyp 1, hyp 3) |- ( ps -> ch ) ;
		step 2 : wff = axiom ax-mp (hyp 2, step 1) |- ch ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mpani (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ps ;
		hyp 2 : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ch -> th ) ) ;
	}

	/*  [10-Apr-1994]  */ 
	proof of mpani {
		step 1 : wff = theorem exp3a (hyp 2) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem mpi (hyp 1, step 1) |- ( ph -> ( ch -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mpan2i (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ch ;
		hyp 2 : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [10-Apr-1994]  */ 
	proof of mpan2i {
		step 1 : wff = theorem exp3a (hyp 2) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem mpii (hyp 1, step 1) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mp2ani (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ps ;
		hyp 2 : wff = |- ch ;
		hyp 3 : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> th ) ;
	}

	/*  [13-Dec-2004]  */ /*  [12-Dec-2004]  */ 
	proof of mp2ani {
		step 1 : wff = theorem mpani (hyp 1, hyp 3) |- ( ph -> ( ch -> th ) ) ;
		step 2 : wff = theorem mpi (hyp 2, step 1) |- ( ph -> th ) ;
		qed prop = step 2 ;
	}

	/*  A deduction based on modus ponens.  */
	theorem mpand (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ch -> th ) ) ;
	}

	/*  [13-Dec-2004]  */ /*  [12-Dec-2004]  */ 
	proof of mpand {
		step 1 : wff = theorem exp3a (hyp 2) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem mpd (hyp 1, step 1) |- ( ph -> ( ch -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A deduction based on modus ponens.  */
	theorem mpan2d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ch ) ;
		hyp 2 : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	/*  [13-Dec-2004]  */ /*  [12-Dec-2004]  */ 
	proof of mpan2d {
		step 1 : wff = theorem exp3a (hyp 2) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem mpid (hyp 1, step 1) |- ( ph -> ( ps -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  A deduction based on modus ponens.  */
	theorem mp2and (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ph -> ch ) ;
		hyp 3 : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> th ) ;
	}

	/*  [13-Dec-2004]  */ /*  [12-Dec-2004]  */ 
	proof of mp2and {
		step 1 : wff = theorem mpand (hyp 1, hyp 3) |- ( ph -> ( ch -> th ) ) ;
		step 2 : wff = theorem mpd (hyp 2, step 1) |- ( ph -> th ) ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mpdan (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [23-May-1999]  */ 
	proof of mpdan {
		step 1 : wff = theorem ex (hyp 2) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem mpd (hyp 1, step 1) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens with commutation of antecedents.  */
	theorem mpancom (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ps -> ph ) ;
		hyp 2 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ps -> ch ) ;
	}

	/*  [13-Mar-2004]  */ /*  [28-Oct-2003]  */ 
	proof of mpancom {
		step 1 : wff = theorem ancoms (hyp 2) |- ( ( ps /\ ph ) -> ch ) ;
		step 2 : wff = theorem mpdan (hyp 1, step 1) |- ( ps -> ch ) ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mpanl1 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ps /\ ch ) -> th ) ;
	}

	/*  [16-Aug-1994]  */ 
	proof of mpanl1 {
		step 1 : wff = theorem ex (hyp 2) |- ( ( ph /\ ps ) -> ( ch -> th ) ) ;
		step 2 : wff = theorem mpan (hyp 1, step 1) |- ( ps -> ( ch -> th ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ps /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mpanl2 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ps ;
		hyp 2 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ch ) -> th ) ;
	}

	/*  [16-Aug-1994]  */ 
	proof of mpanl2 {
		step 1 : wff = theorem ex (hyp 2) |- ( ( ph /\ ps ) -> ( ch -> th ) ) ;
		step 2 : wff = theorem mpan2 (hyp 1, step 1) |- ( ph -> ( ch -> th ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ph /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mpanl12 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- ps ;
		hyp 3 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ch -> th ) ;
	}

	/*  [15-Jul-2005]  */ /*  [13-Jul-2005]  */ 
	proof of mpanl12 {
		step 1 : wff = theorem mpanl1 (hyp 1, hyp 3) |- ( ( ps /\ ch ) -> th ) ;
		step 2 : wff = theorem mpan (hyp 2, step 1) |- ( ch -> th ) ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mpanr1 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ps ;
		hyp 2 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ch ) -> th ) ;
	}

	/*  [3-May-1994]  */ 
	proof of mpanr1 {
		step 1 : wff = theorem ex (hyp 2) |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		step 2 : wff = theorem mpani (hyp 1, step 1) |- ( ph -> ( ch -> th ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ph /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mpanr2 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ch ;
		hyp 2 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> th ) ;
	}

	/*  [3-May-1994]  */ 
	proof of mpanr2 {
		step 1 : wff = theorem ex (hyp 2) |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		step 2 : wff = theorem mpan2i (hyp 1, step 1) |- ( ph -> ( ps -> th ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ph /\ ps ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mpanlr1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ps ;
		hyp 2 : wff = |- ( ( ( ph /\ ( ps /\ ch ) ) /\ th ) -> ta ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ch ) /\ th ) -> ta ) ;
	}

	/*  [7-Jan-2005]  */ /*  [30-Dec-2004]  */ 
	proof of mpanlr1 {
		step 1 : wff = theorem ex (hyp 2) |- ( ( ph /\ ( ps /\ ch ) ) -> ( th -> ta ) ) ;
		step 2 : wff = theorem mpanr1 (hyp 1, step 1) |- ( ( ph /\ ch ) -> ( th -> ta ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ( ph /\ ch ) /\ th ) -> ta ) ;
		qed prop = step 3 ;
	}

	/*  Modus-tollens-like theorem.  */
	theorem mtt (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ph -> ( -. ps <-> ( ps -> ph ) ) ) ;
	}

	/*  [7-Apr-2001]  */ 
	proof of mtt {
		step 1 : wff = theorem pm2_21 () |- ( -. ps -> ( ps -> ph ) ) ;
		step 2 : wff = theorem con3 () |- ( ( ps -> ph ) -> ( -. ph -> -. ps ) ) ;
		step 3 : wff = theorem com12 (step 2) |- ( -. ph -> ( ( ps -> ph ) -> -. ps ) ) ;
		step 4 : wff = theorem impbid2 (step 1, step 3) |- ( -. ph -> ( -. ps <-> ( ps -> ph ) ) ) ;
		qed prop = step 4 ;
	}

	/*  A false consequent falsifies an antecedent.  */
	theorem mt2bi (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ph ;
		-----------------
		prop : wff = |- ( -. ps <-> ( ps -> -. ph ) ) ;
	}

	/*  [19-Aug-1993]  */ 
	proof of mt2bi {
		step 1 : wff = theorem pm2_21 () |- ( -. ps -> ( ps -> -. ph ) ) ;
		step 2 : wff = theorem con2 () |- ( ( ps -> -. ph ) -> ( ph -> -. ps ) ) ;
		step 3 : wff = theorem mpi (hyp 1, step 2) |- ( ( ps -> -. ph ) -> -. ps ) ;
		step 4 : wff = theorem impbi (step 1, step 3) |- ( -. ps <-> ( ps -> -. ph ) ) ;
		qed prop = step 4 ;
	}

	/*  A deduction from a biconditional, similar to modus tollens.  */
	theorem mtbid (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> -. ps ) ;
		hyp 2 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> -. ch ) ;
	}

	/*  [26-Nov-1995]  */ 
	proof of mtbid {
		step 1 : wff = theorem biimprd (hyp 2) |- ( ph -> ( ch -> ps ) ) ;
		step 2 : wff = theorem mtod (hyp 1, step 1) |- ( ph -> -. ch ) ;
		qed prop = step 2 ;
	}

	/*  A deduction from a biconditional, similar to modus tollens.  */
	theorem mtbird (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> -. ch ) ;
		hyp 2 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> -. ps ) ;
	}

	/*  [10-May-1994]  */ 
	proof of mtbird {
		step 1 : wff = theorem biimpd (hyp 2) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem mtod (hyp 1, step 1) |- ( ph -> -. ps ) ;
		qed prop = step 2 ;
	}

	/*  An inference from a biconditional, similar to modus tollens.  */
	theorem mtbii (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- -. ps ;
		hyp 2 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> -. ch ) ;
	}

	/*  [27-Nov-1995]  */ 
	proof of mtbii {
		step 1 : wff = theorem biimprd (hyp 2) |- ( ph -> ( ch -> ps ) ) ;
		step 2 : wff = theorem mtoi (hyp 1, step 1) |- ( ph -> -. ch ) ;
		qed prop = step 2 ;
	}

	/*  An inference from a biconditional, similar to modus tollens.  */
	theorem mtbiri (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- -. ch ;
		hyp 2 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> -. ps ) ;
	}

	/*  [24-Aug-1995]  */ 
	proof of mtbiri {
		step 1 : wff = theorem biimpd (hyp 2) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem mtoi (hyp 1, step 1) |- ( ph -> -. ps ) ;
		qed prop = step 2 ;
	}

	/*  Two truths are equivalent.  */
	theorem _2th (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- ps ;
		-----------------
		prop : wff = |- ( ph <-> ps ) ;
	}

	/*  [18-Aug-1993]  */ 
	proof of _2th {
		step 1 : wff = theorem a1i (hyp 2) |- ( ph -> ps ) ;
		step 2 : wff = theorem a1i (hyp 1) |- ( ps -> ph ) ;
		step 3 : wff = theorem impbi (step 1, step 2) |- ( ph <-> ps ) ;
		qed prop = step 3 ;
	}

	/*  Two falsehoods are equivalent.  */
	theorem _2false (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- -. ph ;
		hyp 2 : wff = |- -. ps ;
		-----------------
		prop : wff = |- ( ph <-> ps ) ;
	}

	/*  [5-Apr-2005]  */ /*  [4-Apr-2005]  */ 
	proof of _2false {
		step 1 : wff = theorem pm5_21 () |- ( ( -. ph /\ -. ps ) -> ( ph <-> ps ) ) ;
		step 2 : wff = theorem mp2an (hyp 1, hyp 2, step 1) |- ( ph <-> ps ) ;
		qed prop = step 2 ;
	}

	/*  A wff is equivalent to its equivalence with truth. (The proof was
	       shortened by Juha Arpiainen, 19-Jan-06.)  */
	theorem tbt (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ph ;
		-----------------
		prop : wff = |- ( ps <-> ( ps <-> ph ) ) ;
	}

	/*  [21-Jan-2006]  */ /*  [18-Aug-1993]  */ 
	proof of tbt {
		step 1 : wff = theorem pm5_501 () |- ( ph -> ( ps <-> ( ph <-> ps ) ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ps <-> ( ph <-> ps ) ) ;
		step 3 : wff = theorem bicom () |- ( ( ph <-> ps ) <-> ( ps <-> ph ) ) ;
		step 4 : wff = theorem bitr (step 2, step 3) |- ( ps <-> ( ps <-> ph ) ) ;
		qed prop = step 4 ;
	}

	/*  The negation of a wff is equivalent to the wff's equivalence to
	     falsehood.  (Contributed by Juha Arpiainen, 19-Jan-06.)  */
	theorem nbn2 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ph -> ( -. ps <-> ( ph <-> ps ) ) ) ;
	}

	/*  [21-Jan-2006]  */ /*  [19-Jan-2006]  */ 
	proof of nbn2 {
		step 1 : wff = theorem pm5_21 () |- ( ( -. ph /\ -. ps ) -> ( ph <-> ps ) ) ;
		step 2 : wff = theorem ex (step 1) |- ( -. ph -> ( -. ps -> ( ph <-> ps ) ) ) ;
		step 3 : wff = theorem pm4_11 () |- ( ( ph <-> ps ) <-> ( -. ph <-> -. ps ) ) ;
		step 4 : wff = theorem biimp (step 3) |- ( ( ph <-> ps ) -> ( -. ph <-> -. ps ) ) ;
		step 5 : wff = theorem biimpcd (step 4) |- ( -. ph -> ( ( ph <-> ps ) -> -. ps ) ) ;
		step 6 : wff = theorem impbid (step 2, step 5) |- ( -. ph -> ( -. ps <-> ( ph <-> ps ) ) ) ;
		qed prop = step 6 ;
	}

	/*  The negation of a wff is equivalent to the wff's equivalence to
	       falsehood.  */
	theorem nbn (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- -. ph ;
		-----------------
		prop : wff = |- ( -. ps <-> ( ps <-> ph ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of nbn {
		step 1 : wff = theorem nbn2 () |- ( -. ph -> ( -. ps <-> ( ph <-> ps ) ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( -. ps <-> ( ph <-> ps ) ) ;
		step 3 : wff = theorem bicom () |- ( ( ph <-> ps ) <-> ( ps <-> ph ) ) ;
		step 4 : wff = theorem bitr (step 2, step 3) |- ( -. ps <-> ( ps <-> ph ) ) ;
		qed prop = step 4 ;
	}

	/*  Transfer falsehood via equivalence.  */
	theorem nbn3 (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ph ;
		-----------------
		prop : wff = |- ( -. ps <-> ( ps <-> -. ph ) ) ;
	}

	/*  [12-Sep-2006]  */ /*  [11-Sep-2006]  */ 
	proof of nbn3 {
		step 1 : wff = theorem negbi (hyp 1) |- -. -. ph ;
		step 2 : wff = theorem nbn (step 1) |- ( -. ps <-> ( ps <-> -. ph ) ) ;
		qed prop = step 2 ;
	}

	/*  A wff is equivalent to its conjunction with truth.  */
	theorem biantru (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ph ;
		-----------------
		prop : wff = |- ( ps <-> ( ps /\ ph ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of biantru {
		step 1 : wff = theorem iba () |- ( ph -> ( ps <-> ( ps /\ ph ) ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ps <-> ( ps /\ ph ) ) ;
		qed prop = step 2 ;
	}

	/*  A wff is equivalent to its conjunction with truth.  */
	theorem biantrur (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- ph ;
		-----------------
		prop : wff = |- ( ps <-> ( ph /\ ps ) ) ;
	}

	/*  [3-Aug-1994]  */ 
	proof of biantrur {
		step 1 : wff = theorem ibar () |- ( ph -> ( ps <-> ( ph /\ ps ) ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ps <-> ( ph /\ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  A wff is equivalent to its conjunction with truth.  */
	theorem biantrud (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( ch <-> ( ch /\ ps ) ) ) ;
	}

	/*  [2-Aug-1994]  */ 
	proof of biantrud {
		step 1 : wff = theorem anim2i (hyp 1) |- ( ( ch /\ ph ) -> ( ch /\ ps ) ) ;
		step 2 : wff = theorem expcom (step 1) |- ( ph -> ( ch -> ( ch /\ ps ) ) ) ;
		step 3 : wff = theorem pm3_26 () |- ( ( ch /\ ps ) -> ch ) ;
		step 4 : wff = theorem impbid1 (step 2, step 3) |- ( ph -> ( ch <-> ( ch /\ ps ) ) ) ;
		qed prop = step 4 ;
	}

	/*  A wff is equivalent to its conjunction with truth.  */
	theorem biantrurd (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( ch <-> ( ps /\ ch ) ) ) ;
	}

	/*  [1-May-1995]  */ 
	proof of biantrurd {
		step 1 : wff = theorem biantrud (hyp 1) |- ( ph -> ( ch <-> ( ch /\ ps ) ) ) ;
		step 2 : wff = theorem ancom () |- ( ( ch /\ ps ) <-> ( ps /\ ch ) ) ;
		step 3 : wff = theorem syl6bb (step 1, step 2) |- ( ph -> ( ch <-> ( ps /\ ch ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Detach truth from conjunction in biconditional.  */
	theorem mpbiran (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ( ps /\ ch ) ) ;
		hyp 2 : wff = |- ps ;
		-----------------
		prop : wff = |- ( ph <-> ch ) ;
	}

	/*  [27-Feb-1996]  */ 
	proof of mpbiran {
		step 1 : wff = theorem biantrur (hyp 2) |- ( ch <-> ( ps /\ ch ) ) ;
		step 2 : wff = theorem bitr4 (hyp 1, step 1) |- ( ph <-> ch ) ;
		qed prop = step 2 ;
	}

	/*  Detach truth from conjunction in biconditional.  */
	theorem mpbiran2 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ( ps /\ ch ) ) ;
		hyp 2 : wff = |- ch ;
		-----------------
		prop : wff = |- ( ph <-> ps ) ;
	}

	/*  [22-Feb-1996]  */ 
	proof of mpbiran2 {
		step 1 : wff = theorem biantru (hyp 2) |- ( ps <-> ( ps /\ ch ) ) ;
		step 2 : wff = theorem bitr4 (hyp 1, step 1) |- ( ph <-> ps ) ;
		qed prop = step 2 ;
	}

	/*  Detach a conjunction of truths in a biconditional.  */
	theorem mpbir2an (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ( ps /\ ch ) ) ;
		hyp 2 : wff = |- ps ;
		hyp 3 : wff = |- ch ;
		-----------------
		prop : wff = |- ph ;
	}

	/*  [12-May-2005]  */ /*  [10-May-2005]  */ 
	proof of mpbir2an {
		step 1 : wff = theorem mpbiran (hyp 1, hyp 2) |- ( ph <-> ch ) ;
		step 2 : wff = theorem mpbir (hyp 3, step 1) |- ph ;
		qed prop = step 2 ;
	}

	/*  A wff is equivalent to itself with true antecedent.  */
	theorem biimt (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ps <-> ( ph -> ps ) ) ) ;
	}

	/*  [28-Jan-1996]  */ 
	proof of biimt {
		step 1 : wff = axiom ax-1 () |- ( ps -> ( ph -> ps ) ) ;
		step 2 : wff = theorem pm2_27 () |- ( ph -> ( ( ph -> ps ) -> ps ) ) ;
		step 3 : wff = theorem impbid2 (step 1, step 2) |- ( ph -> ( ps <-> ( ph -> ps ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *5.5 of [WhiteheadRussell] p. 125.  */
	theorem pm5_5 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ( ph -> ps ) <-> ps ) ) ;
	}

	/*  [28-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_5 {
		step 1 : wff = theorem biimt () |- ( ph -> ( ps <-> ( ph -> ps ) ) ) ;
		step 2 : wff = theorem bicomd (step 1) |- ( ph -> ( ( ph -> ps ) <-> ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Theorem *5.62 of [WhiteheadRussell] p. 125.  (Contributed by Roy F.
	     Longton, 21-Jun-2005.)  */
	theorem pm5_62 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) \/ -. ps ) <-> ( ph \/ -. ps ) ) ;
	}

	/*  [22-Jun-2005]  */ /*  [21-Jun-2005]  */ 
	proof of pm5_62 {
		step 1 : wff = theorem ordir () |- ( ( ( ph /\ ps ) \/ -. ps ) <-> ( ( ph \/ -. ps ) /\ ( ps \/ -. ps ) ) ) ;
		step 2 : wff = theorem exmid () |- ( ps \/ -. ps ) ;
		step 3 : wff = theorem mpbiran2 (step 1, step 2) |- ( ( ( ph /\ ps ) \/ -. ps ) <-> ( ph \/ -. ps ) ) ;
		qed prop = step 3 ;
	}

	/*  A wff is disjoined with truth is true.  */
	theorem biort (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ph <-> ( ph \/ ps ) ) ) ;
	}

	/*  [23-May-1999]  */ 
	proof of biort {
		step 1 : wff = theorem orc () |- ( ph -> ( ph \/ ps ) ) ;
		step 2 : wff = axiom ax-1 () |- ( ph -> ( ( ph \/ ps ) -> ph ) ) ;
		step 3 : wff = theorem impbid2 (step 1, step 2) |- ( ph -> ( ph <-> ( ph \/ ps ) ) ) ;
		qed prop = step 3 ;
	}

	/*  A wff is equivalent to its disjunction with falsehood.  Theorem *4.74 of
	     [WhiteheadRussell] p. 121.  */
	theorem biorf (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( -. ph -> ( ps <-> ( ph \/ ps ) ) ) ;
	}

	/*  [23-Mar-1995]  */ 
	proof of biorf {
		step 1 : wff = theorem biimt () |- ( -. ph -> ( ps <-> ( -. ph -> ps ) ) ) ;
		step 2 : wff = definition df-or () |- ( ( ph \/ ps ) <-> ( -. ph -> ps ) ) ;
		step 3 : wff = theorem syl6bbr (step 1, step 2) |- ( -. ph -> ( ps <-> ( ph \/ ps ) ) ) ;
		qed prop = step 3 ;
	}

	/*  A wff is equivalent to its disjunction with falsehood.  */
	theorem biorfi (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- -. ph ;
		-----------------
		prop : wff = |- ( ps <-> ( ps \/ ph ) ) ;
	}

	/*  [23-Mar-1995]  */ 
	proof of biorfi {
		step 1 : wff = theorem biorf () |- ( -. ph -> ( ps <-> ( ph \/ ps ) ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ps <-> ( ph \/ ps ) ) ;
		step 3 : wff = theorem orcom () |- ( ( ph \/ ps ) <-> ( ps \/ ph ) ) ;
		step 4 : wff = theorem bitr (step 2, step 3) |- ( ps <-> ( ps \/ ph ) ) ;
		qed prop = step 4 ;
	}

	/*  A wff conjoined with falsehood is false.  */
	theorem bianfi (var ph : wff , var ps : wff ) 
	{
		hyp 1 : wff = |- -. ph ;
		-----------------
		prop : wff = |- ( ph <-> ( ps /\ ph ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bianfi {
		step 1 : wff = theorem pm2_21i (hyp 1) |- ( ph -> ( ps /\ ph ) ) ;
		step 2 : wff = theorem pm3_27 () |- ( ( ps /\ ph ) -> ph ) ;
		step 3 : wff = theorem impbi (step 1, step 2) |- ( ph <-> ( ps /\ ph ) ) ;
		qed prop = step 3 ;
	}

	/*  A wff conjoined with falsehood is false.  */
	theorem bianfd (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> -. ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps <-> ( ps /\ ch ) ) ) ;
	}

	/*  [27-Mar-1995]  */ 
	proof of bianfd {
		step 1 : wff = theorem pm2_21d (hyp 1) |- ( ph -> ( ps -> ( ps /\ ch ) ) ) ;
		step 2 : wff = theorem pm3_26 () |- ( ( ps /\ ch ) -> ps ) ;
		step 3 : wff = theorem impbid1 (step 1, step 2) |- ( ph -> ( ps <-> ( ps /\ ch ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Theorem *4.82 of [WhiteheadRussell] p. 122.  */
	theorem pm4_82 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) /\ ( ph -> -. ps ) ) <-> -. ph ) ;
	}

	/*  [28-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_82 {
		step 1 : wff = theorem pm2_65 () |- ( ( ph -> ps ) -> ( ( ph -> -. ps ) -> -. ph ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ( ph -> ps ) /\ ( ph -> -. ps ) ) -> -. ph ) ;
		step 3 : wff = theorem pm2_21 () |- ( -. ph -> ( ph -> ps ) ) ;
		step 4 : wff = theorem pm2_21 () |- ( -. ph -> ( ph -> -. ps ) ) ;
		step 5 : wff = theorem jca (step 3, step 4) |- ( -. ph -> ( ( ph -> ps ) /\ ( ph -> -. ps ) ) ) ;
		step 6 : wff = theorem impbi (step 2, step 5) |- ( ( ( ph -> ps ) /\ ( ph -> -. ps ) ) <-> -. ph ) ;
		qed prop = step 6 ;
	}

	/*  Theorem *4.83 of [WhiteheadRussell] p. 122.  */
	theorem pm4_83 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) /\ ( -. ph -> ps ) ) <-> ps ) ;
	}

	/*  [28-Jun-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm4_83 {
		step 1 : wff = theorem exmid () |- ( ph \/ -. ph ) ;
		step 2 : wff = theorem a1bi (step 1) |- ( ps <-> ( ( ph \/ -. ph ) -> ps ) ) ;
		step 3 : wff = theorem jaob () |- ( ( ( ph \/ -. ph ) -> ps ) <-> ( ( ph -> ps ) /\ ( -. ph -> ps ) ) ) ;
		step 4 : wff = theorem bitr2 (step 2, step 3) |- ( ( ( ph -> ps ) /\ ( -. ph -> ps ) ) <-> ps ) ;
		qed prop = step 4 ;
	}

	/*  Negation inferred from embedded conjunct.  */
	theorem pclem6 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph <-> ( ps /\ -. ph ) ) -> -. ps ) ;
	}

	/*  [20-Aug-1993]  */ 
	proof of pclem6 {
		step 1 : wff = theorem bi1 () |- ( ( ph <-> ( ps /\ -. ph ) ) -> ( ph -> ( ps /\ -. ph ) ) ) ;
		step 2 : wff = theorem pm3_27 () |- ( ( ps /\ -. ph ) -> -. ph ) ;
		step 3 : wff = theorem syl6 (step 1, step 2) |- ( ( ph <-> ( ps /\ -. ph ) ) -> ( ph -> -. ph ) ) ;
		step 4 : wff = theorem pm2_01d (step 3) |- ( ( ph <-> ( ps /\ -. ph ) ) -> -. ph ) ;
		step 5 : wff = theorem bi2 () |- ( ( ph <-> ( ps /\ -. ph ) ) -> ( ( ps /\ -. ph ) -> ph ) ) ;
		step 6 : wff = theorem exp3a (step 5) |- ( ( ph <-> ( ps /\ -. ph ) ) -> ( ps -> ( -. ph -> ph ) ) ) ;
		step 7 : wff = theorem com23 (step 6) |- ( ( ph <-> ( ps /\ -. ph ) ) -> ( -. ph -> ( ps -> ph ) ) ) ;
		step 8 : wff = theorem con3 () |- ( ( ps -> ph ) -> ( -. ph -> -. ps ) ) ;
		step 9 : wff = theorem syli (step 7, step 8) |- ( ( ph <-> ( ps /\ -. ph ) ) -> ( -. ph -> -. ps ) ) ;
		step 10 : wff = theorem mpd (step 4, step 9) |- ( ( ph <-> ( ps /\ -. ph ) ) -> -. ps ) ;
		qed prop = step 10 ;
	}

	/*  A transitive law of equivalence.  Compare Theorem *4.22 of
	     [WhiteheadRussell] p. 117.  */
	theorem biantr (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph <-> ps ) /\ ( ch <-> ps ) ) -> ( ph <-> ch ) ) ;
	}

	/*  [18-Aug-1993]  */ 
	proof of biantr {
		step 1 : wff = theorem id () |- ( ( ch <-> ps ) -> ( ch <-> ps ) ) ;
		step 2 : wff = theorem bibi2d (step 1) |- ( ( ch <-> ps ) -> ( ( ph <-> ch ) <-> ( ph <-> ps ) ) ) ;
		step 3 : wff = theorem biimparc (step 2) |- ( ( ( ph <-> ps ) /\ ( ch <-> ps ) ) -> ( ph <-> ch ) ) ;
		qed prop = step 3 ;
	}

	/*  Disjunction distributes over the biconditional.  An axiom of system DS in
	     Vladimir Lifschitz, "On calculational proofs" (1998),
	     ~ http://citeseer.ist.psu.edu/lifschitz98calculational.html .  */
	theorem orbidi (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph \/ ( ps <-> ch ) ) <-> ( ( ph \/ ps ) <-> ( ph \/ ch ) ) ) ;
	}

	/*  [9-Jan-2005]  */ /*  [8-Jan-2005]  */ 
	proof of orbidi {
		step 1 : wff = theorem orc () |- ( ph -> ( ph \/ ch ) ) ;
		step 2 : wff = theorem a1d (step 1) |- ( ph -> ( ( ph \/ ps ) -> ( ph \/ ch ) ) ) ;
		step 3 : wff = theorem orc () |- ( ph -> ( ph \/ ps ) ) ;
		step 4 : wff = theorem a1d (step 3) |- ( ph -> ( ( ph \/ ch ) -> ( ph \/ ps ) ) ) ;
		step 5 : wff = theorem impbid (step 2, step 4) |- ( ph -> ( ( ph \/ ps ) <-> ( ph \/ ch ) ) ) ;
		step 6 : wff = theorem id () |- ( ( ps <-> ch ) -> ( ps <-> ch ) ) ;
		step 7 : wff = theorem orbi2d (step 6) |- ( ( ps <-> ch ) -> ( ( ph \/ ps ) <-> ( ph \/ ch ) ) ) ;
		step 8 : wff = theorem jaoi (step 5, step 7) |- ( ( ph \/ ( ps <-> ch ) ) -> ( ( ph \/ ps ) <-> ( ph \/ ch ) ) ) ;
		step 9 : wff = theorem pm2_85 () |- ( ( ( ph \/ ps ) -> ( ph \/ ch ) ) -> ( ph \/ ( ps -> ch ) ) ) ;
		step 10 : wff = theorem pm2_85 () |- ( ( ( ph \/ ch ) -> ( ph \/ ps ) ) -> ( ph \/ ( ch -> ps ) ) ) ;
		step 11 : wff = theorem anim12i (step 9, step 10) |- ( ( ( ( ph \/ ps ) -> ( ph \/ ch ) ) /\ ( ( ph \/ ch ) -> ( ph \/ ps ) ) ) -> ( ( ph \/ ( ps -> ch ) ) /\ ( ph \/ ( ch -> ps ) ) ) ) ;
		step 12 : wff = theorem bi () |- ( ( ( ph \/ ps ) <-> ( ph \/ ch ) ) <-> ( ( ( ph \/ ps ) -> ( ph \/ ch ) ) /\ ( ( ph \/ ch ) -> ( ph \/ ps ) ) ) ) ;
		step 13 : wff = theorem bi () |- ( ( ps <-> ch ) <-> ( ( ps -> ch ) /\ ( ch -> ps ) ) ) ;
		step 14 : wff = theorem orbi2i (step 13) |- ( ( ph \/ ( ps <-> ch ) ) <-> ( ph \/ ( ( ps -> ch ) /\ ( ch -> ps ) ) ) ) ;
		step 15 : wff = theorem ordi () |- ( ( ph \/ ( ( ps -> ch ) /\ ( ch -> ps ) ) ) <-> ( ( ph \/ ( ps -> ch ) ) /\ ( ph \/ ( ch -> ps ) ) ) ) ;
		step 16 : wff = theorem bitr (step 14, step 15) |- ( ( ph \/ ( ps <-> ch ) ) <-> ( ( ph \/ ( ps -> ch ) ) /\ ( ph \/ ( ch -> ps ) ) ) ) ;
		step 17 : wff = theorem _3imtr4 (step 11, step 12, step 16) |- ( ( ( ph \/ ps ) <-> ( ph \/ ch ) ) -> ( ph \/ ( ps <-> ch ) ) ) ;
		step 18 : wff = theorem impbi (step 8, step 17) |- ( ( ph \/ ( ps <-> ch ) ) <-> ( ( ph \/ ps ) <-> ( ph \/ ch ) ) ) ;
		qed prop = step 18 ;
	}

	/*  Associative law for the biconditional.  An axiom of system DS in Vladimir
	     Lifschitz, "On calculational proofs" (1998),
	     ~ http://citeseer.ist.psu.edu/lifschitz98calculational.html .
	     Interestingly, this law was not included in _Principia Mathematica_ but
	     was apparently first noted by Jan Lukasiewicz circa 1923.  (The proof was
	     shortened by Juha Arpiainen, 19-Jan-06.)  */
	theorem biass (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph <-> ps ) <-> ch ) <-> ( ph <-> ( ps <-> ch ) ) ) ;
	}

	/*  [21-Jan-2006]  */ /*  [8-Jan-2005]  */ 
	proof of biass {
		step 1 : wff = theorem pm5_501 () |- ( ph -> ( ps <-> ( ph <-> ps ) ) ) ;
		step 2 : wff = theorem bibi1d (step 1) |- ( ph -> ( ( ps <-> ch ) <-> ( ( ph <-> ps ) <-> ch ) ) ) ;
		step 3 : wff = theorem pm5_501 () |- ( ph -> ( ( ps <-> ch ) <-> ( ph <-> ( ps <-> ch ) ) ) ) ;
		step 4 : wff = theorem bitr3d (step 2, step 3) |- ( ph -> ( ( ( ph <-> ps ) <-> ch ) <-> ( ph <-> ( ps <-> ch ) ) ) ) ;
		step 5 : wff = theorem nbbn () |- ( ( -. ps <-> ch ) <-> -. ( ps <-> ch ) ) ;
		step 6 : wff = theorem a1i (step 5) |- ( -. ph -> ( ( -. ps <-> ch ) <-> -. ( ps <-> ch ) ) ) ;
		step 7 : wff = theorem nbn2 () |- ( -. ph -> ( -. ps <-> ( ph <-> ps ) ) ) ;
		step 8 : wff = theorem bibi1d (step 7) |- ( -. ph -> ( ( -. ps <-> ch ) <-> ( ( ph <-> ps ) <-> ch ) ) ) ;
		step 9 : wff = theorem nbn2 () |- ( -. ph -> ( -. ( ps <-> ch ) <-> ( ph <-> ( ps <-> ch ) ) ) ) ;
		step 10 : wff = theorem _3bitr3d (step 6, step 8, step 9) |- ( -. ph -> ( ( ( ph <-> ps ) <-> ch ) <-> ( ph <-> ( ps <-> ch ) ) ) ) ;
		step 11 : wff = theorem pm2_61i (step 4, step 10) |- ( ( ( ph <-> ps ) <-> ch ) <-> ( ph <-> ( ps <-> ch ) ) ) ;
		qed prop = step 11 ;
	}

	/*  Lukasiewicz's shortest axiom for equivalential calculus.  Storrs McCall,
	     ed., _Polish Logic 1920-1939_ (Oxford, 1967), p. 96.  */
	theorem biluk (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph <-> ps ) <-> ( ( ch <-> ps ) <-> ( ph <-> ch ) ) ) ;
	}

	/*  [11-Jan-2005]  */ /*  [10-Jan-2005]  */ 
	proof of biluk {
		step 1 : wff = theorem bicom () |- ( ( ph <-> ps ) <-> ( ps <-> ph ) ) ;
		step 2 : wff = theorem bibi1i (step 1) |- ( ( ( ph <-> ps ) <-> ch ) <-> ( ( ps <-> ph ) <-> ch ) ) ;
		step 3 : wff = theorem biass () |- ( ( ( ps <-> ph ) <-> ch ) <-> ( ps <-> ( ph <-> ch ) ) ) ;
		step 4 : wff = theorem bitr (step 2, step 3) |- ( ( ( ph <-> ps ) <-> ch ) <-> ( ps <-> ( ph <-> ch ) ) ) ;
		step 5 : wff = theorem biass () |- ( ( ( ( ph <-> ps ) <-> ch ) <-> ( ps <-> ( ph <-> ch ) ) ) <-> ( ( ph <-> ps ) <-> ( ch <-> ( ps <-> ( ph <-> ch ) ) ) ) ) ;
		step 6 : wff = theorem mpbi (step 4, step 5) |- ( ( ph <-> ps ) <-> ( ch <-> ( ps <-> ( ph <-> ch ) ) ) ) ;
		step 7 : wff = theorem biass () |- ( ( ( ch <-> ps ) <-> ( ph <-> ch ) ) <-> ( ch <-> ( ps <-> ( ph <-> ch ) ) ) ) ;
		step 8 : wff = theorem bitr4 (step 6, step 7) |- ( ( ph <-> ps ) <-> ( ( ch <-> ps ) <-> ( ph <-> ch ) ) ) ;
		qed prop = step 8 ;
	}

	/*  Disjunction distributes over the biconditional.  Theorem *5.7 of
	     [WhiteheadRussell] p. 125.  This theorem is similar to ~ orbidi .
	     (Contributed by Roy F. Longton, 21-Jun-2005.)  */
	theorem pm5_7 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph \/ ch ) <-> ( ps \/ ch ) ) <-> ( ch \/ ( ph <-> ps ) ) ) ;
	}

	/*  [22-Jun-2005]  */ /*  [21-Jun-2005]  */ 
	proof of pm5_7 {
		step 1 : wff = theorem orbidi () |- ( ( ch \/ ( ph <-> ps ) ) <-> ( ( ch \/ ph ) <-> ( ch \/ ps ) ) ) ;
		step 2 : wff = theorem orcom () |- ( ( ch \/ ph ) <-> ( ph \/ ch ) ) ;
		step 3 : wff = theorem orcom () |- ( ( ch \/ ps ) <-> ( ps \/ ch ) ) ;
		step 4 : wff = theorem bibi12i (step 2, step 3) |- ( ( ( ch \/ ph ) <-> ( ch \/ ps ) ) <-> ( ( ph \/ ch ) <-> ( ps \/ ch ) ) ) ;
		step 5 : wff = theorem bitr2 (step 1, step 4) |- ( ( ( ph \/ ch ) <-> ( ps \/ ch ) ) <-> ( ch \/ ( ph <-> ps ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Dijkstra-Scholten's Golden Rule for calculational proofs.  */
	theorem bigolden (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) <-> ph ) <-> ( ps <-> ( ph \/ ps ) ) ) ;
	}

	/*  [12-Jan-2005]  */ /*  [10-Jan-2005]  */ 
	proof of bigolden {
		step 1 : wff = theorem pm4_71 () |- ( ( ph -> ps ) <-> ( ph <-> ( ph /\ ps ) ) ) ;
		step 2 : wff = theorem pm4_72 () |- ( ( ph -> ps ) <-> ( ps <-> ( ph \/ ps ) ) ) ;
		step 3 : wff = theorem bicom () |- ( ( ph <-> ( ph /\ ps ) ) <-> ( ( ph /\ ps ) <-> ph ) ) ;
		step 4 : wff = theorem _3bitr3r (step 1, step 2, step 3) |- ( ( ( ph /\ ps ) <-> ph ) <-> ( ps <-> ( ph \/ ps ) ) ) ;
		qed prop = step 4 ;
	}

	/*  Theorem *5.71 of [WhiteheadRussell] p. 125.  (Contributed by Roy F.
	     Longton, 23-Jun-2005.)  */
	theorem pm5_71 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ps -> -. ch ) -> ( ( ( ph \/ ps ) /\ ch ) <-> ( ph /\ ch ) ) ) ;
	}

	/*  [24-Jun-2005]  */ /*  [23-Jun-2005]  */ 
	proof of pm5_71 {
		step 1 : wff = theorem orel2 () |- ( -. ps -> ( ( ph \/ ps ) -> ph ) ) ;
		step 2 : wff = theorem orc () |- ( ph -> ( ph \/ ps ) ) ;
		step 3 : wff = theorem impbid1 (step 1, step 2) |- ( -. ps -> ( ( ph \/ ps ) <-> ph ) ) ;
		step 4 : wff = theorem anbi1d (step 3) |- ( -. ps -> ( ( ( ph \/ ps ) /\ ch ) <-> ( ph /\ ch ) ) ) ;
		step 5 : wff = theorem pm2_21 () |- ( -. ch -> ( ch -> ( ( ph \/ ps ) <-> ph ) ) ) ;
		step 6 : wff = theorem pm5_32rd (step 5) |- ( -. ch -> ( ( ( ph \/ ps ) /\ ch ) <-> ( ph /\ ch ) ) ) ;
		step 7 : wff = theorem ja (step 4, step 6) |- ( ( ps -> -. ch ) -> ( ( ( ph \/ ps ) /\ ch ) <-> ( ph /\ ch ) ) ) ;
		qed prop = step 7 ;
	}

	/*  Theorem *5.75 of [WhiteheadRussell] p. 126.  */
	theorem pm5_75 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ch -> -. ps ) /\ ( ph <-> ( ps \/ ch ) ) ) -> ( ( ph /\ -. ps ) <-> ch ) ) ;
	}

	/*  [22-Mar-2005]  */ /*  [3-Jan-2005]  */ 
	proof of pm5_75 {
		step 1 : wff = theorem bi1 () |- ( ( ph <-> ( ps \/ ch ) ) -> ( ph -> ( ps \/ ch ) ) ) ;
		step 2 : wff = theorem pm5_6 () |- ( ( ( ph /\ -. ps ) -> ch ) <-> ( ph -> ( ps \/ ch ) ) ) ;
		step 3 : wff = theorem sylibr (step 1, step 2) |- ( ( ph <-> ( ps \/ ch ) ) -> ( ( ph /\ -. ps ) -> ch ) ) ;
		step 4 : wff = theorem adantl (step 3) |- ( ( ( ch -> -. ps ) /\ ( ph <-> ( ps \/ ch ) ) ) -> ( ( ph /\ -. ps ) -> ch ) ) ;
		step 5 : wff = theorem bi2 () |- ( ( ph <-> ( ps \/ ch ) ) -> ( ( ps \/ ch ) -> ph ) ) ;
		step 6 : wff = theorem olc () |- ( ch -> ( ps \/ ch ) ) ;
		step 7 : wff = theorem olc () |- ( ph -> ( ps \/ ph ) ) ;
		step 8 : wff = theorem imim12i (step 6, step 7) |- ( ( ( ps \/ ch ) -> ph ) -> ( ch -> ( ps \/ ph ) ) ) ;
		step 9 : wff = theorem syl (step 5, step 8) |- ( ( ph <-> ( ps \/ ch ) ) -> ( ch -> ( ps \/ ph ) ) ) ;
		step 10 : wff = theorem pm5_6 () |- ( ( ( ch /\ -. ps ) -> ph ) <-> ( ch -> ( ps \/ ph ) ) ) ;
		step 11 : wff = theorem sylibr (step 9, step 10) |- ( ( ph <-> ( ps \/ ch ) ) -> ( ( ch /\ -. ps ) -> ph ) ) ;
		step 12 : wff = theorem exp3a (step 11) |- ( ( ph <-> ( ps \/ ch ) ) -> ( ch -> ( -. ps -> ph ) ) ) ;
		step 13 : wff = theorem a2d (step 12) |- ( ( ph <-> ( ps \/ ch ) ) -> ( ( ch -> -. ps ) -> ( ch -> ph ) ) ) ;
		step 14 : wff = theorem impcom (step 13) |- ( ( ( ch -> -. ps ) /\ ( ph <-> ( ps \/ ch ) ) ) -> ( ch -> ph ) ) ;
		step 15 : wff = theorem pm3_26 () |- ( ( ( ch -> -. ps ) /\ ( ph <-> ( ps \/ ch ) ) ) -> ( ch -> -. ps ) ) ;
		step 16 : wff = theorem jcad (step 14, step 15) |- ( ( ( ch -> -. ps ) /\ ( ph <-> ( ps \/ ch ) ) ) -> ( ch -> ( ph /\ -. ps ) ) ) ;
		step 17 : wff = theorem impbid (step 4, step 16) |- ( ( ( ch -> -. ps ) /\ ( ph <-> ( ps \/ ch ) ) ) -> ( ( ph /\ -. ps ) <-> ch ) ) ;
		qed prop = step 17 ;
	}

	/*  Removal of conjunct from one side of an equivalence.  */
	theorem bimsc1 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) /\ ( ch <-> ( ps /\ ph ) ) ) -> ( ch <-> ph ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of bimsc1 {
		step 1 : wff = theorem id () |- ( ( ch <-> ( ps /\ ph ) ) -> ( ch <-> ( ps /\ ph ) ) ) ;
		step 2 : wff = theorem pm4_71r () |- ( ( ph -> ps ) <-> ( ph <-> ( ps /\ ph ) ) ) ;
		step 3 : wff = theorem biimp (step 2) |- ( ( ph -> ps ) -> ( ph <-> ( ps /\ ph ) ) ) ;
		step 4 : wff = theorem bicomd (step 3) |- ( ( ph -> ps ) -> ( ( ps /\ ph ) <-> ph ) ) ;
		step 5 : wff = theorem sylan9bbr (step 1, step 4) |- ( ( ( ph -> ps ) /\ ( ch <-> ( ps /\ ph ) ) ) -> ( ch <-> ph ) ) ;
		qed prop = step 5 ;
	}

	/*  Deduction for elimination by cases.  */
	theorem ecase2d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ph -> -. ( ps /\ ch ) ) ;
		hyp 3 : wff = |- ( ph -> -. ( ps /\ th ) ) ;
		hyp 4 : wff = |- ( ph -> ( ta \/ ( ch \/ th ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ta ) ;
	}

	/*  [21-Apr-1994]  */ 
	proof of ecase2d {
		step 1 : wff = theorem imnan () |- ( ( ps -> -. ch ) <-> -. ( ps /\ ch ) ) ;
		step 2 : wff = theorem sylibr (hyp 2, step 1) |- ( ph -> ( ps -> -. ch ) ) ;
		step 3 : wff = theorem mpd (hyp 1, step 2) |- ( ph -> -. ch ) ;
		step 4 : wff = theorem imnan () |- ( ( ps -> -. th ) <-> -. ( ps /\ th ) ) ;
		step 5 : wff = theorem sylibr (hyp 3, step 4) |- ( ph -> ( ps -> -. th ) ) ;
		step 6 : wff = theorem mpd (hyp 1, step 5) |- ( ph -> -. th ) ;
		step 7 : wff = theorem jca (step 3, step 6) |- ( ph -> ( -. ch /\ -. th ) ) ;
		step 8 : wff = theorem ioran () |- ( -. ( ch \/ th ) <-> ( -. ch /\ -. th ) ) ;
		step 9 : wff = theorem sylibr (step 7, step 8) |- ( ph -> -. ( ch \/ th ) ) ;
		step 10 : wff = theorem orcom () |- ( ( ta \/ ( ch \/ th ) ) <-> ( ( ch \/ th ) \/ ta ) ) ;
		step 11 : wff = theorem sylib (hyp 4, step 10) |- ( ph -> ( ( ch \/ th ) \/ ta ) ) ;
		step 12 : wff = theorem ord (step 11) |- ( ph -> ( -. ( ch \/ th ) -> ta ) ) ;
		step 13 : wff = theorem mpd (step 9, step 12) |- ( ph -> ta ) ;
		qed prop = step 13 ;
	}

	/*  Inference for elimination by cases.  */
	theorem ecase3 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ch ) ;
		hyp 2 : wff = |- ( ps -> ch ) ;
		hyp 3 : wff = |- ( -. ( ph \/ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ch ;
	}

	/*  [23-Mar-1995]  */ 
	proof of ecase3 {
		step 1 : wff = theorem ioran () |- ( -. ( ph \/ ps ) <-> ( -. ph /\ -. ps ) ) ;
		step 2 : wff = theorem sylbir (step 1, hyp 3) |- ( ( -. ph /\ -. ps ) -> ch ) ;
		step 3 : wff = theorem ex (step 2) |- ( -. ph -> ( -. ps -> ch ) ) ;
		step 4 : wff = theorem pm2_61ii (step 3, hyp 1, hyp 2) |- ch ;
		qed prop = step 4 ;
	}

	/*  Inference for elimination by cases.  */
	theorem ecase (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( -. ph -> ch ) ;
		hyp 2 : wff = |- ( -. ps -> ch ) ;
		hyp 3 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ch ;
	}

	/*  [22-Jul-2005]  */ /*  [13-Jul-2005]  */ 
	proof of ecase {
		step 1 : wff = theorem ex (hyp 3) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem pm2_61nii (step 1, hyp 1, hyp 2) |- ch ;
		qed prop = step 2 ;
	}

	/*  Deduction for elimination by cases.  */
	theorem ecase3d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> th ) ) ;
		hyp 2 : wff = |- ( ph -> ( ch -> th ) ) ;
		hyp 3 : wff = |- ( ph -> ( -. ( ps \/ ch ) -> th ) ) ;
		-----------------
		prop : wff = |- ( ph -> th ) ;
	}

	/*  [2-May-1996]  */ 
	proof of ecase3d {
		step 1 : wff = theorem com12 (hyp 1) |- ( ps -> ( ph -> th ) ) ;
		step 2 : wff = theorem com12 (hyp 2) |- ( ch -> ( ph -> th ) ) ;
		step 3 : wff = theorem com12 (hyp 3) |- ( -. ( ps \/ ch ) -> ( ph -> th ) ) ;
		step 4 : wff = theorem ecase3 (step 1, step 2, step 3) |- ( ph -> th ) ;
		qed prop = step 4 ;
	}

	/*  Inference for combining cases.  */
	theorem ccase (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ta ) ;
		hyp 2 : wff = |- ( ( ch /\ ps ) -> ta ) ;
		hyp 3 : wff = |- ( ( ph /\ th ) -> ta ) ;
		hyp 4 : wff = |- ( ( ch /\ th ) -> ta ) ;
		-----------------
		prop : wff = |- ( ( ( ph \/ ch ) /\ ( ps \/ th ) ) -> ta ) ;
	}

	/*  [29-Jul-1999]  */ 
	proof of ccase {
		step 1 : wff = theorem anddi () |- ( ( ( ph \/ ch ) /\ ( ps \/ th ) ) <-> ( ( ( ph /\ ps ) \/ ( ph /\ th ) ) \/ ( ( ch /\ ps ) \/ ( ch /\ th ) ) ) ) ;
		step 2 : wff = theorem or4 () |- ( ( ( ( ph /\ ps ) \/ ( ph /\ th ) ) \/ ( ( ch /\ ps ) \/ ( ch /\ th ) ) ) <-> ( ( ( ph /\ ps ) \/ ( ch /\ ps ) ) \/ ( ( ph /\ th ) \/ ( ch /\ th ) ) ) ) ;
		step 3 : wff = theorem bitr (step 1, step 2) |- ( ( ( ph \/ ch ) /\ ( ps \/ th ) ) <-> ( ( ( ph /\ ps ) \/ ( ch /\ ps ) ) \/ ( ( ph /\ th ) \/ ( ch /\ th ) ) ) ) ;
		step 4 : wff = theorem jaoi (hyp 1, hyp 2) |- ( ( ( ph /\ ps ) \/ ( ch /\ ps ) ) -> ta ) ;
		step 5 : wff = theorem jaoi (hyp 3, hyp 4) |- ( ( ( ph /\ th ) \/ ( ch /\ th ) ) -> ta ) ;
		step 6 : wff = theorem jaoi (step 4, step 5) |- ( ( ( ( ph /\ ps ) \/ ( ch /\ ps ) ) \/ ( ( ph /\ th ) \/ ( ch /\ th ) ) ) -> ta ) ;
		step 7 : wff = theorem sylbi (step 3, step 6) |- ( ( ( ph \/ ch ) /\ ( ps \/ th ) ) -> ta ) ;
		qed prop = step 7 ;
	}

	/*  Deduction for combining cases.  */
	theorem ccased (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ps /\ ch ) -> et ) ) ;
		hyp 2 : wff = |- ( ph -> ( ( th /\ ch ) -> et ) ) ;
		hyp 3 : wff = |- ( ph -> ( ( ps /\ ta ) -> et ) ) ;
		hyp 4 : wff = |- ( ph -> ( ( th /\ ta ) -> et ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ( ps \/ th ) /\ ( ch \/ ta ) ) -> et ) ) ;
	}

	/*  [10-May-2004]  */ /*  [9-May-2004]  */ 
	proof of ccased {
		step 1 : wff = theorem jaod (hyp 1, hyp 2) |- ( ph -> ( ( ( ps /\ ch ) \/ ( th /\ ch ) ) -> et ) ) ;
		step 2 : wff = theorem jaod (hyp 3, hyp 4) |- ( ph -> ( ( ( ps /\ ta ) \/ ( th /\ ta ) ) -> et ) ) ;
		step 3 : wff = theorem jaod (step 1, step 2) |- ( ph -> ( ( ( ( ps /\ ch ) \/ ( th /\ ch ) ) \/ ( ( ps /\ ta ) \/ ( th /\ ta ) ) ) -> et ) ) ;
		step 4 : wff = theorem anddi () |- ( ( ( ps \/ th ) /\ ( ch \/ ta ) ) <-> ( ( ( ps /\ ch ) \/ ( ps /\ ta ) ) \/ ( ( th /\ ch ) \/ ( th /\ ta ) ) ) ) ;
		step 5 : wff = theorem or4 () |- ( ( ( ( ps /\ ch ) \/ ( ps /\ ta ) ) \/ ( ( th /\ ch ) \/ ( th /\ ta ) ) ) <-> ( ( ( ps /\ ch ) \/ ( th /\ ch ) ) \/ ( ( ps /\ ta ) \/ ( th /\ ta ) ) ) ) ;
		step 6 : wff = theorem bitr (step 4, step 5) |- ( ( ( ps \/ th ) /\ ( ch \/ ta ) ) <-> ( ( ( ps /\ ch ) \/ ( th /\ ch ) ) \/ ( ( ps /\ ta ) \/ ( th /\ ta ) ) ) ) ;
		step 7 : wff = theorem syl5ib (step 3, step 6) |- ( ph -> ( ( ( ps \/ th ) /\ ( ch \/ ta ) ) -> et ) ) ;
		qed prop = step 7 ;
	}

	/*  Inference for combining cases.  */
	theorem ccase2 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ta ) ;
		hyp 2 : wff = |- ( ch -> ta ) ;
		hyp 3 : wff = |- ( th -> ta ) ;
		-----------------
		prop : wff = |- ( ( ( ph \/ ch ) /\ ( ps \/ th ) ) -> ta ) ;
	}

	/*  [29-Jul-1999]  */ 
	proof of ccase2 {
		step 1 : wff = theorem adantr (hyp 2) |- ( ( ch /\ ps ) -> ta ) ;
		step 2 : wff = theorem adantl (hyp 3) |- ( ( ph /\ th ) -> ta ) ;
		step 3 : wff = theorem adantl (hyp 3) |- ( ( ch /\ th ) -> ta ) ;
		step 4 : wff = theorem ccase (hyp 1, step 1, step 2, step 3) |- ( ( ( ph \/ ch ) /\ ( ps \/ th ) ) -> ta ) ;
		qed prop = step 4 ;
	}

	/*  Inference eliminating two antecedents from the four possible cases that
	       result from their true/false combinations.  */
	theorem _4cases (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( ( ph /\ -. ps ) -> ch ) ;
		hyp 3 : wff = |- ( ( -. ph /\ ps ) -> ch ) ;
		hyp 4 : wff = |- ( ( -. ph /\ -. ps ) -> ch ) ;
		-----------------
		prop : wff = |- ch ;
	}

	/*  [25-Oct-2003]  */ /*  [25-Oct-2003]  */ 
	proof of _4cases {
		step 1 : wff = theorem pm2_61ian (hyp 1, hyp 3) |- ( ps -> ch ) ;
		step 2 : wff = theorem pm2_61ian (hyp 2, hyp 4) |- ( -. ps -> ch ) ;
		step 3 : wff = theorem pm2_61i (step 1, step 2) |- ch ;
		qed prop = step 3 ;
	}

	/*  Miscellaneous inference relating falsehoods.  */
	theorem niabn (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ph ;
		-----------------
		prop : wff = |- ( -. ps -> ( ( ch /\ ps ) <-> -. ph ) ) ;
	}

	/*  [31-Mar-1994]  */ 
	proof of niabn {
		step 1 : wff = theorem pm3_27 () |- ( ( ch /\ ps ) -> ps ) ;
		step 2 : wff = theorem pm2_24i (hyp 1) |- ( -. ph -> ps ) ;
		step 3 : wff = theorem pm5_21ni (step 1, step 2) |- ( -. ps -> ( ( ch /\ ps ) <-> -. ph ) ) ;
		qed prop = step 3 ;
	}

	/*  Lemma for an alternate version of weak deduction theorem.  */
	theorem dedlem0a (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ph -> ( ps <-> ( ( ch -> ph ) -> ( ps /\ ph ) ) ) ) ;
	}

	/*  [2-Apr-1994]  */ 
	proof of dedlem0a {
		step 1 : wff = axiom ax-1 () |- ( ps -> ( ( ch -> ph ) -> ps ) ) ;
		step 2 : wff = axiom ax-1 () |- ( ph -> ( ch -> ph ) ) ;
		step 3 : wff = theorem imim1i (step 2) |- ( ( ( ch -> ph ) -> ps ) -> ( ph -> ps ) ) ;
		step 4 : wff = theorem com12 (step 3) |- ( ph -> ( ( ( ch -> ph ) -> ps ) -> ps ) ) ;
		step 5 : wff = theorem impbid2 (step 1, step 4) |- ( ph -> ( ps <-> ( ( ch -> ph ) -> ps ) ) ) ;
		step 6 : wff = theorem iba () |- ( ph -> ( ps <-> ( ps /\ ph ) ) ) ;
		step 7 : wff = theorem imbi2d (step 6) |- ( ph -> ( ( ( ch -> ph ) -> ps ) <-> ( ( ch -> ph ) -> ( ps /\ ph ) ) ) ) ;
		step 8 : wff = theorem bitrd (step 5, step 7) |- ( ph -> ( ps <-> ( ( ch -> ph ) -> ( ps /\ ph ) ) ) ) ;
		qed prop = step 8 ;
	}

	/*  Lemma for an alternate version of weak deduction theorem.  */
	theorem dedlem0b (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( -. ph -> ( ps <-> ( ( ps -> ph ) -> ( ch /\ ph ) ) ) ) ;
	}

	/*  [2-Apr-1994]  */ 
	proof of dedlem0b {
		step 1 : wff = theorem pm2_21 () |- ( -. ph -> ( ph -> ( ch /\ ph ) ) ) ;
		step 2 : wff = theorem imim2d (step 1) |- ( -. ph -> ( ( ps -> ph ) -> ( ps -> ( ch /\ ph ) ) ) ) ;
		step 3 : wff = theorem com23 (step 2) |- ( -. ph -> ( ps -> ( ( ps -> ph ) -> ( ch /\ ph ) ) ) ) ;
		step 4 : wff = theorem pm2_21 () |- ( -. ps -> ( ps -> ph ) ) ;
		step 5 : wff = theorem pm3_27 () |- ( ( ch /\ ph ) -> ph ) ;
		step 6 : wff = theorem imim12i (step 4, step 5) |- ( ( ( ps -> ph ) -> ( ch /\ ph ) ) -> ( -. ps -> ph ) ) ;
		step 7 : wff = theorem con1d (step 6) |- ( ( ( ps -> ph ) -> ( ch /\ ph ) ) -> ( -. ph -> ps ) ) ;
		step 8 : wff = theorem com12 (step 7) |- ( -. ph -> ( ( ( ps -> ph ) -> ( ch /\ ph ) ) -> ps ) ) ;
		step 9 : wff = theorem impbid (step 3, step 8) |- ( -. ph -> ( ps <-> ( ( ps -> ph ) -> ( ch /\ ph ) ) ) ) ;
		qed prop = step 9 ;
	}

	/*  Lemma for weak deduction theorem.  */
	theorem dedlema (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ph -> ( ps <-> ( ( ps /\ ph ) \/ ( ch /\ -. ph ) ) ) ) ;
	}

	/*  [26-Jun-2002]  */ 
	proof of dedlema {
		step 1 : wff = theorem orc () |- ( ps -> ( ps \/ ( ch /\ -. ph ) ) ) ;
		step 2 : wff = theorem idd () |- ( ph -> ( ps -> ps ) ) ;
		step 3 : wff = theorem pm2_24 () |- ( ph -> ( -. ph -> ps ) ) ;
		step 4 : wff = theorem adantld (step 3) |- ( ph -> ( ( ch /\ -. ph ) -> ps ) ) ;
		step 5 : wff = theorem jaod (step 2, step 4) |- ( ph -> ( ( ps \/ ( ch /\ -. ph ) ) -> ps ) ) ;
		step 6 : wff = theorem impbid2 (step 1, step 5) |- ( ph -> ( ps <-> ( ps \/ ( ch /\ -. ph ) ) ) ) ;
		step 7 : wff = theorem iba () |- ( ph -> ( ps <-> ( ps /\ ph ) ) ) ;
		step 8 : wff = theorem orbi1d (step 7) |- ( ph -> ( ( ps \/ ( ch /\ -. ph ) ) <-> ( ( ps /\ ph ) \/ ( ch /\ -. ph ) ) ) ) ;
		step 9 : wff = theorem bitrd (step 6, step 8) |- ( ph -> ( ps <-> ( ( ps /\ ph ) \/ ( ch /\ -. ph ) ) ) ) ;
		qed prop = step 9 ;
	}

	/*  Lemma for weak deduction theorem.  */
	theorem dedlemb (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( -. ph -> ( ch <-> ( ( ps /\ ph ) \/ ( ch /\ -. ph ) ) ) ) ;
	}

	/*  [15-May-1999]  */ 
	proof of dedlemb {
		step 1 : wff = theorem olc () |- ( ( ch /\ -. ph ) -> ( ( ps /\ ph ) \/ ( ch /\ -. ph ) ) ) ;
		step 2 : wff = theorem expcom (step 1) |- ( -. ph -> ( ch -> ( ( ps /\ ph ) \/ ( ch /\ -. ph ) ) ) ) ;
		step 3 : wff = theorem pm2_21 () |- ( -. ph -> ( ph -> ( ps -> ch ) ) ) ;
		step 4 : wff = theorem com23 (step 3) |- ( -. ph -> ( ps -> ( ph -> ch ) ) ) ;
		step 5 : wff = theorem imp3a (step 4) |- ( -. ph -> ( ( ps /\ ph ) -> ch ) ) ;
		step 6 : wff = theorem pm3_26 () |- ( ( ch /\ -. ph ) -> ch ) ;
		step 7 : wff = theorem a1i (step 6) |- ( -. ph -> ( ( ch /\ -. ph ) -> ch ) ) ;
		step 8 : wff = theorem jaod (step 5, step 7) |- ( -. ph -> ( ( ( ps /\ ph ) \/ ( ch /\ -. ph ) ) -> ch ) ) ;
		step 9 : wff = theorem impbid (step 2, step 8) |- ( -. ph -> ( ch <-> ( ( ps /\ ph ) \/ ( ch /\ -. ph ) ) ) ) ;
		qed prop = step 9 ;
	}

	/*  Hypothesis builder for weak deduction theorem.  For more information,
	       see the Deduction Theorem link on the Metamath Proof Explorer home
	       page.  */
	theorem elimh (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph <-> ( ( ph /\ ch ) \/ ( ps /\ -. ch ) ) ) -> ( ch <-> ta ) ) ;
		hyp 2 : wff = |- ( ( ps <-> ( ( ph /\ ch ) \/ ( ps /\ -. ch ) ) ) -> ( th <-> ta ) ) ;
		hyp 3 : wff = |- th ;
		-----------------
		prop : wff = |- ta ;
	}

	/*  [26-Jun-2002]  */ 
	proof of elimh {
		step 1 : wff = theorem dedlema () |- ( ch -> ( ph <-> ( ( ph /\ ch ) \/ ( ps /\ -. ch ) ) ) ) ;
		step 2 : wff = theorem syl (step 1, hyp 1) |- ( ch -> ( ch <-> ta ) ) ;
		step 3 : wff = theorem ibi (step 2) |- ( ch -> ta ) ;
		step 4 : wff = theorem dedlemb () |- ( -. ch -> ( ps <-> ( ( ph /\ ch ) \/ ( ps /\ -. ch ) ) ) ) ;
		step 5 : wff = theorem syl (step 4, hyp 2) |- ( -. ch -> ( th <-> ta ) ) ;
		step 6 : wff = theorem mpbii (hyp 3, step 5) |- ( -. ch -> ta ) ;
		step 7 : wff = theorem pm2_61i (step 3, step 6) |- ta ;
		qed prop = step 7 ;
	}

	/*  The weak deduction theorem.  For more information, see the Deduction
	       Theorem link on the Metamath Proof Explorer home page.  */
	theorem dedt (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph <-> ( ( ph /\ ch ) \/ ( ps /\ -. ch ) ) ) -> ( th <-> ta ) ) ;
		hyp 2 : wff = |- ta ;
		-----------------
		prop : wff = |- ( ch -> th ) ;
	}

	/*  [26-Jun-2002]  */ 
	proof of dedt {
		step 1 : wff = theorem dedlema () |- ( ch -> ( ph <-> ( ( ph /\ ch ) \/ ( ps /\ -. ch ) ) ) ) ;
		step 2 : wff = theorem mpbiri (hyp 2, hyp 1) |- ( ( ph <-> ( ( ph /\ ch ) \/ ( ps /\ -. ch ) ) ) -> th ) ;
		step 3 : wff = theorem syl (step 1, step 2) |- ( ch -> th ) ;
		qed prop = step 3 ;
	}

	/*  Contraposition.  Theorem *2.16 of [WhiteheadRussell] p. 103.  This version
	     of ~ con3 demonstrates the use of the weak deduction theorem to derive
	     it from ~ con3i .  */
	theorem con3th (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( -. ps -> -. ph ) ) ;
	}

	/*  [27-Jun-2002]  */ 
	proof of con3th {
		step 1 : wff = theorem id () |- ( ( ps <-> ( ( ps /\ ( ph -> ps ) ) \/ ( ph /\ -. ( ph -> ps ) ) ) ) -> ( ps <-> ( ( ps /\ ( ph -> ps ) ) \/ ( ph /\ -. ( ph -> ps ) ) ) ) ) ;
		step 2 : wff = theorem negbid (step 1) |- ( ( ps <-> ( ( ps /\ ( ph -> ps ) ) \/ ( ph /\ -. ( ph -> ps ) ) ) ) -> ( -. ps <-> -. ( ( ps /\ ( ph -> ps ) ) \/ ( ph /\ -. ( ph -> ps ) ) ) ) ) ;
		step 3 : wff = theorem imbi1d (step 2) |- ( ( ps <-> ( ( ps /\ ( ph -> ps ) ) \/ ( ph /\ -. ( ph -> ps ) ) ) ) -> ( ( -. ps -> -. ph ) <-> ( -. ( ( ps /\ ( ph -> ps ) ) \/ ( ph /\ -. ( ph -> ps ) ) ) -> -. ph ) ) ) ;
		step 4 : wff = theorem id () |- ( ( ps <-> ( ( ps /\ ( ph -> ps ) ) \/ ( ph /\ -. ( ph -> ps ) ) ) ) -> ( ps <-> ( ( ps /\ ( ph -> ps ) ) \/ ( ph /\ -. ( ph -> ps ) ) ) ) ) ;
		step 5 : wff = theorem imbi2d (step 4) |- ( ( ps <-> ( ( ps /\ ( ph -> ps ) ) \/ ( ph /\ -. ( ph -> ps ) ) ) ) -> ( ( ph -> ps ) <-> ( ph -> ( ( ps /\ ( ph -> ps ) ) \/ ( ph /\ -. ( ph -> ps ) ) ) ) ) ) ;
		step 6 : wff = theorem id () |- ( ( ph <-> ( ( ps /\ ( ph -> ps ) ) \/ ( ph /\ -. ( ph -> ps ) ) ) ) -> ( ph <-> ( ( ps /\ ( ph -> ps ) ) \/ ( ph /\ -. ( ph -> ps ) ) ) ) ) ;
		step 7 : wff = theorem imbi2d (step 6) |- ( ( ph <-> ( ( ps /\ ( ph -> ps ) ) \/ ( ph /\ -. ( ph -> ps ) ) ) ) -> ( ( ph -> ph ) <-> ( ph -> ( ( ps /\ ( ph -> ps ) ) \/ ( ph /\ -. ( ph -> ps ) ) ) ) ) ) ;
		step 8 : wff = theorem id () |- ( ph -> ph ) ;
		step 9 : wff = theorem elimh (step 5, step 7, step 8) |- ( ph -> ( ( ps /\ ( ph -> ps ) ) \/ ( ph /\ -. ( ph -> ps ) ) ) ) ;
		step 10 : wff = theorem con3i (step 9) |- ( -. ( ( ps /\ ( ph -> ps ) ) \/ ( ph /\ -. ( ph -> ps ) ) ) -> -. ph ) ;
		step 11 : wff = theorem dedt (step 3, step 10) |- ( ( ph -> ps ) -> ( -. ps -> -. ph ) ) ;
		qed prop = step 11 ;
	}

	/*  The consensus theorem.  This theorem and its dual (with ` \/ ` and ` /\ `
	     interchanged) are commonly used in computer logic design to eliminate
	     redundant terms from Boolean expressions.  Specifically, we prove that the
	     term ` ( ps /\ ch ) ` on the left-hand side is redundant.  */
	theorem consensus (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ( ph /\ ps ) \/ ( -. ph /\ ch ) ) \/ ( ps /\ ch ) ) <-> ( ( ph /\ ps ) \/ ( -. ph /\ ch ) ) ) ;
	}

	/*  [16-May-2003]  */ 
	proof of consensus {
		step 1 : wff = theorem id () |- ( ( ( ph /\ ps ) \/ ( -. ph /\ ch ) ) -> ( ( ph /\ ps ) \/ ( -. ph /\ ch ) ) ) ;
		step 2 : wff = theorem dedlema () |- ( ph -> ( ps <-> ( ( ps /\ ph ) \/ ( ch /\ -. ph ) ) ) ) ;
		step 3 : wff = theorem biimpd (step 2) |- ( ph -> ( ps -> ( ( ps /\ ph ) \/ ( ch /\ -. ph ) ) ) ) ;
		step 4 : wff = theorem adantrd (step 3) |- ( ph -> ( ( ps /\ ch ) -> ( ( ps /\ ph ) \/ ( ch /\ -. ph ) ) ) ) ;
		step 5 : wff = theorem dedlemb () |- ( -. ph -> ( ch <-> ( ( ps /\ ph ) \/ ( ch /\ -. ph ) ) ) ) ;
		step 6 : wff = theorem biimpd (step 5) |- ( -. ph -> ( ch -> ( ( ps /\ ph ) \/ ( ch /\ -. ph ) ) ) ) ;
		step 7 : wff = theorem adantld (step 6) |- ( -. ph -> ( ( ps /\ ch ) -> ( ( ps /\ ph ) \/ ( ch /\ -. ph ) ) ) ) ;
		step 8 : wff = theorem pm2_61i (step 4, step 7) |- ( ( ps /\ ch ) -> ( ( ps /\ ph ) \/ ( ch /\ -. ph ) ) ) ;
		step 9 : wff = theorem ancom () |- ( ( ps /\ ph ) <-> ( ph /\ ps ) ) ;
		step 10 : wff = theorem ancom () |- ( ( ch /\ -. ph ) <-> ( -. ph /\ ch ) ) ;
		step 11 : wff = theorem orbi12i (step 9, step 10) |- ( ( ( ps /\ ph ) \/ ( ch /\ -. ph ) ) <-> ( ( ph /\ ps ) \/ ( -. ph /\ ch ) ) ) ;
		step 12 : wff = theorem sylib (step 8, step 11) |- ( ( ps /\ ch ) -> ( ( ph /\ ps ) \/ ( -. ph /\ ch ) ) ) ;
		step 13 : wff = theorem jaoi (step 1, step 12) |- ( ( ( ( ph /\ ps ) \/ ( -. ph /\ ch ) ) \/ ( ps /\ ch ) ) -> ( ( ph /\ ps ) \/ ( -. ph /\ ch ) ) ) ;
		step 14 : wff = theorem orc () |- ( ( ( ph /\ ps ) \/ ( -. ph /\ ch ) ) -> ( ( ( ph /\ ps ) \/ ( -. ph /\ ch ) ) \/ ( ps /\ ch ) ) ) ;
		step 15 : wff = theorem impbi (step 13, step 14) |- ( ( ( ( ph /\ ps ) \/ ( -. ph /\ ch ) ) \/ ( ps /\ ch ) ) <-> ( ( ph /\ ps ) \/ ( -. ph /\ ch ) ) ) ;
		qed prop = step 15 ;
	}

	/*  Theorem *4.42 of [WhiteheadRussell] p. 119.  (Contributed by Roy F.
	     Longton, 21-Jun-2005.)  */
	theorem pm4_42 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph <-> ( ( ph /\ ps ) \/ ( ph /\ -. ps ) ) ) ;
	}

	/*  [21-Jun-2005]  */ /*  [21-Jun-2005]  */ 
	proof of pm4_42 {
		step 1 : wff = theorem dedlema () |- ( ps -> ( ph <-> ( ( ph /\ ps ) \/ ( ph /\ -. ps ) ) ) ) ;
		step 2 : wff = theorem dedlemb () |- ( -. ps -> ( ph <-> ( ( ph /\ ps ) \/ ( ph /\ -. ps ) ) ) ) ;
		step 3 : wff = theorem pm2_61i (step 1, step 2) |- ( ph <-> ( ( ph /\ ps ) \/ ( ph /\ -. ps ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Miscellaneous inference relating falsehoods.  */
	theorem ninba (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ph ;
		-----------------
		prop : wff = |- ( -. ps -> ( -. ph <-> ( ch /\ ps ) ) ) ;
	}

	/*  [31-Mar-1994]  */ 
	proof of ninba {
		step 1 : wff = theorem niabn (hyp 1) |- ( -. ps -> ( ( ch /\ ps ) <-> -. ph ) ) ;
		step 2 : wff = theorem bicomd (step 1) |- ( -. ps -> ( -. ph <-> ( ch /\ ps ) ) ) ;
		qed prop = step 2 ;
	}

	/*  A specialized lemma for set theory (to derive the Axiom of Pairing).  */
	theorem prlem1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( et <-> ch ) ) ;
		hyp 2 : wff = |- ( ps -> -. th ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ( ( ps /\ ch ) \/ ( th /\ ta ) ) -> et ) ) ) ;
	}

	/*  [18-Oct-1995]  */ 
	proof of prlem1 {
		step 1 : wff = theorem biimprcd (hyp 1) |- ( ch -> ( ph -> et ) ) ;
		step 2 : wff = theorem adantl (step 1) |- ( ( ps /\ ch ) -> ( ph -> et ) ) ;
		step 3 : wff = theorem a1dd (step 2) |- ( ( ps /\ ch ) -> ( ph -> ( ps -> et ) ) ) ;
		step 4 : wff = theorem pm2_24 () |- ( th -> ( -. th -> et ) ) ;
		step 5 : wff = theorem syl5 (step 4, hyp 2) |- ( th -> ( ps -> et ) ) ;
		step 6 : wff = theorem adantr (step 5) |- ( ( th /\ ta ) -> ( ps -> et ) ) ;
		step 7 : wff = theorem a1d (step 6) |- ( ( th /\ ta ) -> ( ph -> ( ps -> et ) ) ) ;
		step 8 : wff = theorem jaoi (step 3, step 7) |- ( ( ( ps /\ ch ) \/ ( th /\ ta ) ) -> ( ph -> ( ps -> et ) ) ) ;
		step 9 : wff = theorem com3l (step 8) |- ( ph -> ( ps -> ( ( ( ps /\ ch ) \/ ( th /\ ta ) ) -> et ) ) ) ;
		qed prop = step 9 ;
	}

	/*  A specialized lemma for set theory (to derive the Axiom of Pairing).  */
	theorem prlem2 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) \/ ( ch /\ th ) ) <-> ( ( ph \/ ch ) /\ ( ( ph /\ ps ) \/ ( ch /\ th ) ) ) ) ;
	}

	/*  [5-Aug-1993]  */ 
	proof of prlem2 {
		step 1 : wff = theorem orabs () |- ( ph <-> ( ( ph \/ ch ) /\ ph ) ) ;
		step 2 : wff = theorem anbi1i (step 1) |- ( ( ph /\ ps ) <-> ( ( ( ph \/ ch ) /\ ph ) /\ ps ) ) ;
		step 3 : wff = theorem anass () |- ( ( ( ( ph \/ ch ) /\ ph ) /\ ps ) <-> ( ( ph \/ ch ) /\ ( ph /\ ps ) ) ) ;
		step 4 : wff = theorem bitr (step 2, step 3) |- ( ( ph /\ ps ) <-> ( ( ph \/ ch ) /\ ( ph /\ ps ) ) ) ;
		step 5 : wff = theorem orabs () |- ( ch <-> ( ( ch \/ ph ) /\ ch ) ) ;
		step 6 : wff = theorem orcom () |- ( ( ch \/ ph ) <-> ( ph \/ ch ) ) ;
		step 7 : wff = theorem anbi1i (step 6) |- ( ( ( ch \/ ph ) /\ ch ) <-> ( ( ph \/ ch ) /\ ch ) ) ;
		step 8 : wff = theorem bitr (step 5, step 7) |- ( ch <-> ( ( ph \/ ch ) /\ ch ) ) ;
		step 9 : wff = theorem anbi1i (step 8) |- ( ( ch /\ th ) <-> ( ( ( ph \/ ch ) /\ ch ) /\ th ) ) ;
		step 10 : wff = theorem anass () |- ( ( ( ( ph \/ ch ) /\ ch ) /\ th ) <-> ( ( ph \/ ch ) /\ ( ch /\ th ) ) ) ;
		step 11 : wff = theorem bitr (step 9, step 10) |- ( ( ch /\ th ) <-> ( ( ph \/ ch ) /\ ( ch /\ th ) ) ) ;
		step 12 : wff = theorem orbi12i (step 4, step 11) |- ( ( ( ph /\ ps ) \/ ( ch /\ th ) ) <-> ( ( ( ph \/ ch ) /\ ( ph /\ ps ) ) \/ ( ( ph \/ ch ) /\ ( ch /\ th ) ) ) ) ;
		step 13 : wff = theorem andi () |- ( ( ( ph \/ ch ) /\ ( ( ph /\ ps ) \/ ( ch /\ th ) ) ) <-> ( ( ( ph \/ ch ) /\ ( ph /\ ps ) ) \/ ( ( ph \/ ch ) /\ ( ch /\ th ) ) ) ) ;
		step 14 : wff = theorem bitr4 (step 12, step 13) |- ( ( ( ph /\ ps ) \/ ( ch /\ th ) ) <-> ( ( ph \/ ch ) /\ ( ( ph /\ ps ) \/ ( ch /\ th ) ) ) ) ;
		qed prop = step 14 ;
	}

	/*  A specialized lemma for set theory (ordered pair theorem).  */
	theorem oplem1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps \/ ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th \/ ta ) ) ;
		hyp 3 : wff = |- ( ps <-> th ) ;
		hyp 4 : wff = |- ( ch -> ( th <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ps ) ;
	}

	/*  [18-Oct-1995]  */ 
	proof of oplem1 {
		step 1 : wff = theorem ord (hyp 1) |- ( ph -> ( -. ps -> ch ) ) ;
		step 2 : wff = theorem ord (hyp 2) |- ( ph -> ( -. th -> ta ) ) ;
		step 3 : wff = theorem negbii (hyp 3) |- ( -. ps <-> -. th ) ;
		step 4 : wff = theorem syl5ib (step 2, step 3) |- ( ph -> ( -. ps -> ta ) ) ;
		step 5 : wff = theorem jcad (step 1, step 4) |- ( ph -> ( -. ps -> ( ch /\ ta ) ) ) ;
		step 6 : wff = theorem syl5bb (hyp 4, hyp 3) |- ( ch -> ( ps <-> ta ) ) ;
		step 7 : wff = theorem biimpar (step 6) |- ( ( ch /\ ta ) -> ps ) ;
		step 8 : wff = theorem syl6 (step 5, step 7) |- ( ph -> ( -. ps -> ps ) ) ;
		step 9 : wff = theorem pm2_18 () |- ( ( -. ps -> ps ) -> ps ) ;
		step 10 : wff = theorem syl (step 8, step 9) |- ( ph -> ps ) ;
		qed prop = step 10 ;
	}

	/*  Lemma used in construction of real numbers.  */
	theorem rnlem (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps ) /\ ( ch /\ th ) ) <-> ( ( ( ph /\ ch ) /\ ( ps /\ th ) ) /\ ( ( ph /\ th ) /\ ( ps /\ ch ) ) ) ) ;
	}

	/*  [4-Sep-1995]  */ /*  [22-Jun-2005]  */ 
	proof of rnlem {
		step 1 : wff = theorem anandir () |- ( ( ( ph /\ ps ) /\ ( ch /\ th ) ) <-> ( ( ph /\ ( ch /\ th ) ) /\ ( ps /\ ( ch /\ th ) ) ) ) ;
		step 2 : wff = theorem anandi () |- ( ( ph /\ ( ch /\ th ) ) <-> ( ( ph /\ ch ) /\ ( ph /\ th ) ) ) ;
		step 3 : wff = theorem anandi () |- ( ( ps /\ ( ch /\ th ) ) <-> ( ( ps /\ ch ) /\ ( ps /\ th ) ) ) ;
		step 4 : wff = theorem anbi12i (step 2, step 3) |- ( ( ( ph /\ ( ch /\ th ) ) /\ ( ps /\ ( ch /\ th ) ) ) <-> ( ( ( ph /\ ch ) /\ ( ph /\ th ) ) /\ ( ( ps /\ ch ) /\ ( ps /\ th ) ) ) ) ;
		step 5 : wff = theorem ancom () |- ( ( ( ps /\ ch ) /\ ( ps /\ th ) ) <-> ( ( ps /\ th ) /\ ( ps /\ ch ) ) ) ;
		step 6 : wff = theorem anbi2i (step 5) |- ( ( ( ( ph /\ ch ) /\ ( ph /\ th ) ) /\ ( ( ps /\ ch ) /\ ( ps /\ th ) ) ) <-> ( ( ( ph /\ ch ) /\ ( ph /\ th ) ) /\ ( ( ps /\ th ) /\ ( ps /\ ch ) ) ) ) ;
		step 7 : wff = theorem an4 () |- ( ( ( ( ph /\ ch ) /\ ( ph /\ th ) ) /\ ( ( ps /\ th ) /\ ( ps /\ ch ) ) ) <-> ( ( ( ph /\ ch ) /\ ( ps /\ th ) ) /\ ( ( ph /\ th ) /\ ( ps /\ ch ) ) ) ) ;
		step 8 : wff = theorem bitr (step 6, step 7) |- ( ( ( ( ph /\ ch ) /\ ( ph /\ th ) ) /\ ( ( ps /\ ch ) /\ ( ps /\ th ) ) ) <-> ( ( ( ph /\ ch ) /\ ( ps /\ th ) ) /\ ( ( ph /\ th ) /\ ( ps /\ ch ) ) ) ) ;
		step 9 : wff = theorem _3bitr (step 1, step 4, step 8) |- ( ( ( ph /\ ps ) /\ ( ch /\ th ) ) <-> ( ( ( ph /\ ch ) /\ ( ps /\ th ) ) /\ ( ( ph /\ th ) /\ ( ps /\ ch ) ) ) ) ;
		qed prop = step 9 ;
	}

	/*  A single axiom for Boolean algebra known as DN_1.  See
	     ~ http://www-unix.mcs.anl.gov/~~mccune/papers/basax/v12.pdf .  */
	/* 
	  dn1 pp |- ( -. ( -. ( -. ( ph \/ ps ) \/ ch ) \/
	            -. ( ph \/ -. ( -. ch \/ -. ( ch \/ th ) ) ) ) <-> ch ) ==
	            ? ..
	 */
	/*  [@]  */
	/* 
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	        Abbreviated conjunction and disjunction of three wff's
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	 */
	/*  Extend wff definition to include 3-way disjunction ('or').  */
	rule w3o (var ph : wff , var ps : wff , var ch : wff ) 
	{
		term : wff = # ( ph \/ ps \/ ch ) ;
	}

	/*  Extend wff definition to include 3-way conjunction ('and').  */
	rule w3a (var ph : wff , var ps : wff , var ch : wff ) 
	{
		term : wff = # ( ph /\ ps /\ ch ) ;
	}

	/*  These abbreviations help eliminate parentheses to aid readability.  */
	/*  Define disjunction ('or') of 3 wff's.  Definition *2.33 of
	     [WhiteheadRussell] p. 105.  This abbreviation reduces the number of
	     parentheses and emphasizes that the order of bracketing is not
	     important by virtue of the associative law ~ orass .  */
	definition df-3or (var ph : wff , var ps : wff , var ch : wff ) 
	{
		defiendum : wff = # ( ph \/ ps \/ ch ) ;
		definiens : wff = # ( ( ph \/ ps ) \/ ch ) ;
		-----------------
		prop : wff = |- ( defiendum <-> definiens ) ;
	}

	/*  Define conjunction ('and') of 3 wff.s.  Definition *4.34 of
	     [WhiteheadRussell] p. 118.  This abbreviation reduces the number of
	     parentheses and emphasizes that the order of bracketing is not
	     important by virtue of the associative law ~ anass .  */
	definition df-3an (var ph : wff , var ps : wff , var ch : wff ) 
	{
		defiendum : wff = # ( ph /\ ps /\ ch ) ;
		definiens : wff = # ( ( ph /\ ps ) /\ ch ) ;
		-----------------
		prop : wff = |- ( defiendum <-> definiens ) ;
	}

	/*  Associative law for triple disjunction.  */
	theorem _3orass (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph \/ ps \/ ch ) <-> ( ph \/ ( ps \/ ch ) ) ) ;
	}

	/*  [8-Apr-1994]  */ 
	proof of _3orass {
		step 1 : wff = definition df-3or () |- ( ( ph \/ ps \/ ch ) <-> ( ( ph \/ ps ) \/ ch ) ) ;
		step 2 : wff = theorem orass () |- ( ( ( ph \/ ps ) \/ ch ) <-> ( ph \/ ( ps \/ ch ) ) ) ;
		step 3 : wff = theorem bitr (step 1, step 2) |- ( ( ph \/ ps \/ ch ) <-> ( ph \/ ( ps \/ ch ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Associative law for triple conjunction.  */
	theorem _3anass (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps /\ ch ) <-> ( ph /\ ( ps /\ ch ) ) ) ;
	}

	/*  [8-Apr-1994]  */ 
	proof of _3anass {
		step 1 : wff = definition df-3an () |- ( ( ph /\ ps /\ ch ) <-> ( ( ph /\ ps ) /\ ch ) ) ;
		step 2 : wff = theorem anass () |- ( ( ( ph /\ ps ) /\ ch ) <-> ( ph /\ ( ps /\ ch ) ) ) ;
		step 3 : wff = theorem bitr (step 1, step 2) |- ( ( ph /\ ps /\ ch ) <-> ( ph /\ ( ps /\ ch ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Rotation law for triple conjunction.  */
	theorem _3anrot (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps /\ ch ) <-> ( ps /\ ch /\ ph ) ) ;
	}

	/*  [8-Apr-1994]  */ 
	proof of _3anrot {
		step 1 : wff = theorem ancom () |- ( ( ph /\ ( ps /\ ch ) ) <-> ( ( ps /\ ch ) /\ ph ) ) ;
		step 2 : wff = theorem _3anass () |- ( ( ph /\ ps /\ ch ) <-> ( ph /\ ( ps /\ ch ) ) ) ;
		step 3 : wff = definition df-3an () |- ( ( ps /\ ch /\ ph ) <-> ( ( ps /\ ch ) /\ ph ) ) ;
		step 4 : wff = theorem _3bitr4 (step 1, step 2, step 3) |- ( ( ph /\ ps /\ ch ) <-> ( ps /\ ch /\ ph ) ) ;
		qed prop = step 4 ;
	}

	/*  Rotation law for triple disjunction.  */
	theorem _3orrot (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph \/ ps \/ ch ) <-> ( ps \/ ch \/ ph ) ) ;
	}

	/*  [4-Apr-1995]  */ 
	proof of _3orrot {
		step 1 : wff = theorem orcom () |- ( ( ph \/ ( ps \/ ch ) ) <-> ( ( ps \/ ch ) \/ ph ) ) ;
		step 2 : wff = theorem _3orass () |- ( ( ph \/ ps \/ ch ) <-> ( ph \/ ( ps \/ ch ) ) ) ;
		step 3 : wff = definition df-3or () |- ( ( ps \/ ch \/ ph ) <-> ( ( ps \/ ch ) \/ ph ) ) ;
		step 4 : wff = theorem _3bitr4 (step 1, step 2, step 3) |- ( ( ph \/ ps \/ ch ) <-> ( ps \/ ch \/ ph ) ) ;
		qed prop = step 4 ;
	}

	/*  Commutation law for triple conjunction.  */
	theorem _3ancoma (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps /\ ch ) <-> ( ps /\ ph /\ ch ) ) ;
	}

	/*  [21-Apr-1994]  */ 
	proof of _3ancoma {
		step 1 : wff = theorem ancom () |- ( ( ph /\ ps ) <-> ( ps /\ ph ) ) ;
		step 2 : wff = theorem anbi1i (step 1) |- ( ( ( ph /\ ps ) /\ ch ) <-> ( ( ps /\ ph ) /\ ch ) ) ;
		step 3 : wff = definition df-3an () |- ( ( ph /\ ps /\ ch ) <-> ( ( ph /\ ps ) /\ ch ) ) ;
		step 4 : wff = definition df-3an () |- ( ( ps /\ ph /\ ch ) <-> ( ( ps /\ ph ) /\ ch ) ) ;
		step 5 : wff = theorem _3bitr4 (step 2, step 3, step 4) |- ( ( ph /\ ps /\ ch ) <-> ( ps /\ ph /\ ch ) ) ;
		qed prop = step 5 ;
	}

	/*  Commutation law for triple conjunction.  */
	theorem _3ancomb (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps /\ ch ) <-> ( ph /\ ch /\ ps ) ) ;
	}

	/*  [21-Apr-1994]  */ 
	proof of _3ancomb {
		step 1 : wff = theorem _3ancoma () |- ( ( ph /\ ps /\ ch ) <-> ( ps /\ ph /\ ch ) ) ;
		step 2 : wff = theorem _3anrot () |- ( ( ps /\ ph /\ ch ) <-> ( ph /\ ch /\ ps ) ) ;
		step 3 : wff = theorem bitr (step 1, step 2) |- ( ( ph /\ ps /\ ch ) <-> ( ph /\ ch /\ ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Reversal law for triple conjunction.  */
	theorem _3anrev (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps /\ ch ) <-> ( ch /\ ps /\ ph ) ) ;
	}

	/*  [21-Apr-1994]  */ 
	proof of _3anrev {
		step 1 : wff = theorem _3ancoma () |- ( ( ph /\ ps /\ ch ) <-> ( ps /\ ph /\ ch ) ) ;
		step 2 : wff = theorem _3anrot () |- ( ( ch /\ ps /\ ph ) <-> ( ps /\ ph /\ ch ) ) ;
		step 3 : wff = theorem bitr4 (step 1, step 2) |- ( ( ph /\ ps /\ ch ) <-> ( ch /\ ps /\ ph ) ) ;
		qed prop = step 3 ;
	}

	/*  Simplification of triple conjunction.  */
	theorem _3simpa (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps /\ ch ) -> ( ph /\ ps ) ) ;
	}

	/*  [21-Apr-1994]  */ 
	proof of _3simpa {
		step 1 : wff = definition df-3an () |- ( ( ph /\ ps /\ ch ) <-> ( ( ph /\ ps ) /\ ch ) ) ;
		step 2 : wff = theorem pm3_26bi (step 1) |- ( ( ph /\ ps /\ ch ) -> ( ph /\ ps ) ) ;
		qed prop = step 2 ;
	}

	/*  Simplification of triple conjunction.  */
	theorem _3simpb (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps /\ ch ) -> ( ph /\ ch ) ) ;
	}

	/*  [21-Apr-1994]  */ 
	proof of _3simpb {
		step 1 : wff = theorem _3ancomb () |- ( ( ph /\ ps /\ ch ) <-> ( ph /\ ch /\ ps ) ) ;
		step 2 : wff = theorem _3simpa () |- ( ( ph /\ ch /\ ps ) -> ( ph /\ ch ) ) ;
		step 3 : wff = theorem sylbi (step 1, step 2) |- ( ( ph /\ ps /\ ch ) -> ( ph /\ ch ) ) ;
		qed prop = step 3 ;
	}

	/*  Simplification of triple conjunction.  */
	theorem _3simpc (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps /\ ch ) -> ( ps /\ ch ) ) ;
	}

	/*  [21-Apr-1994]  */ 
	proof of _3simpc {
		step 1 : wff = theorem _3anrot () |- ( ( ph /\ ps /\ ch ) <-> ( ps /\ ch /\ ph ) ) ;
		step 2 : wff = theorem _3simpa () |- ( ( ps /\ ch /\ ph ) -> ( ps /\ ch ) ) ;
		step 3 : wff = theorem sylbi (step 1, step 2) |- ( ( ph /\ ps /\ ch ) -> ( ps /\ ch ) ) ;
		qed prop = step 3 ;
	}

	/*  Simplification of triple conjunction.  */
	theorem _3simp1 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps /\ ch ) -> ph ) ;
	}

	/*  [21-Apr-1994]  */ 
	proof of _3simp1 {
		step 1 : wff = theorem _3simpa () |- ( ( ph /\ ps /\ ch ) -> ( ph /\ ps ) ) ;
		step 2 : wff = theorem pm3_26d (step 1) |- ( ( ph /\ ps /\ ch ) -> ph ) ;
		qed prop = step 2 ;
	}

	/*  Simplification of triple conjunction.  */
	theorem _3simp2 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps /\ ch ) -> ps ) ;
	}

	/*  [21-Apr-1994]  */ 
	proof of _3simp2 {
		step 1 : wff = theorem _3simpa () |- ( ( ph /\ ps /\ ch ) -> ( ph /\ ps ) ) ;
		step 2 : wff = theorem pm3_27d (step 1) |- ( ( ph /\ ps /\ ch ) -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Simplification of triple conjunction.  */
	theorem _3simp3 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph /\ ps /\ ch ) -> ch ) ;
	}

	/*  [21-Apr-1994]  */ 
	proof of _3simp3 {
		step 1 : wff = theorem _3simpc () |- ( ( ph /\ ps /\ ch ) -> ( ps /\ ch ) ) ;
		step 2 : wff = theorem pm3_27d (step 1) |- ( ( ph /\ ps /\ ch ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Infer a conjunct from a triple conjunction.  */
	theorem _3simp1i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph /\ ps /\ ch ) ;
		-----------------
		prop : wff = |- ph ;
	}

	/*  [21-Apr-2005]  */ /*  [19-Apr-2005]  */ 
	proof of _3simp1i {
		step 1 : wff = theorem _3simp1 () |- ( ( ph /\ ps /\ ch ) -> ph ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ph ;
		qed prop = step 2 ;
	}

	/*  Infer a conjunct from a triple conjunction.  */
	theorem _3simp2i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph /\ ps /\ ch ) ;
		-----------------
		prop : wff = |- ps ;
	}

	/*  [21-Apr-2005]  */ /*  [19-Apr-2005]  */ 
	proof of _3simp2i {
		step 1 : wff = theorem _3simp2 () |- ( ( ph /\ ps /\ ch ) -> ps ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ps ;
		qed prop = step 2 ;
	}

	/*  Infer a conjunct from a triple conjunction.  */
	theorem _3simp3i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph /\ ps /\ ch ) ;
		-----------------
		prop : wff = |- ch ;
	}

	/*  [21-Apr-2005]  */ /*  [19-Apr-2005]  */ 
	proof of _3simp3i {
		step 1 : wff = theorem _3simp3 () |- ( ( ph /\ ps /\ ch ) -> ch ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ch ;
		qed prop = step 2 ;
	}

	/*  Deduce a conjunct from a triple conjunction.  */
	theorem _3simp1d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps /\ ch /\ th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ps ) ;
	}

	/*  [6-Sep-2005]  */ /*  [4-Sep-2005]  */ 
	proof of _3simp1d {
		step 1 : wff = theorem _3simp1 () |- ( ( ps /\ ch /\ th ) -> ps ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ps ) ;
		qed prop = step 2 ;
	}

	/*  Deduce a conjunct from a triple conjunction.  */
	theorem _3simp2d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps /\ ch /\ th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [6-Sep-2005]  */ /*  [4-Sep-2005]  */ 
	proof of _3simp2d {
		step 1 : wff = theorem _3simp2 () |- ( ( ps /\ ch /\ th ) -> ch ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Deduce a conjunct from a triple conjunction.  */
	theorem _3simp3d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps /\ ch /\ th ) ) ;
		-----------------
		prop : wff = |- ( ph -> th ) ;
	}

	/*  [7-Sep-2005]  */ /*  [4-Sep-2005]  */ 
	proof of _3simp3d {
		step 1 : wff = theorem _3simp3 () |- ( ( ps /\ ch /\ th ) -> th ) ;
		step 2 : wff = theorem syl (hyp 1, step 1) |- ( ph -> th ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adant1 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( th /\ ph /\ ps ) -> ch ) ;
	}

	/*  [16-Jul-1995]  */ 
	proof of _3adant1 {
		step 1 : wff = theorem _3simpc () |- ( ( th /\ ph /\ ps ) -> ( ph /\ ps ) ) ;
		step 2 : wff = theorem syl (step 1, hyp 1) |- ( ( th /\ ph /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adant2 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ th /\ ps ) -> ch ) ;
	}

	/*  [16-Jul-1995]  */ 
	proof of _3adant2 {
		step 1 : wff = theorem _3simpb () |- ( ( ph /\ th /\ ps ) -> ( ph /\ ps ) ) ;
		step 2 : wff = theorem syl (step 1, hyp 1) |- ( ( ph /\ th /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adant3 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps /\ th ) -> ch ) ;
	}

	/*  [16-Jul-1995]  */ 
	proof of _3adant3 {
		step 1 : wff = theorem _3simpa () |- ( ( ph /\ ps /\ th ) -> ( ph /\ ps ) ) ;
		step 2 : wff = theorem syl (step 1, hyp 1) |- ( ( ph /\ ps /\ th ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding conjuncts to an antecedent.  */
	theorem _3ad2ant1 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps /\ th ) -> ch ) ;
	}

	/*  [23-Apr-2005]  */ /*  [21-Apr-2005]  */ 
	proof of _3ad2ant1 {
		step 1 : wff = theorem adantr (hyp 1) |- ( ( ph /\ th ) -> ch ) ;
		step 2 : wff = theorem _3adant2 (step 1) |- ( ( ph /\ ps /\ th ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding conjuncts to an antecedent.  */
	theorem _3ad2ant2 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ch ) ;
		-----------------
		prop : wff = |- ( ( ps /\ ph /\ th ) -> ch ) ;
	}

	/*  [23-Apr-2005]  */ /*  [21-Apr-2005]  */ 
	proof of _3ad2ant2 {
		step 1 : wff = theorem adantr (hyp 1) |- ( ( ph /\ th ) -> ch ) ;
		step 2 : wff = theorem _3adant1 (step 1) |- ( ( ps /\ ph /\ th ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding conjuncts to an antecedent.  */
	theorem _3ad2ant3 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ch ) ;
		-----------------
		prop : wff = |- ( ( ps /\ th /\ ph ) -> ch ) ;
	}

	/*  [23-Apr-2005]  */ /*  [21-Apr-2005]  */ 
	proof of _3ad2ant3 {
		step 1 : wff = theorem adantl (hyp 1) |- ( ( th /\ ph ) -> ch ) ;
		step 2 : wff = theorem _3adant1 (step 1) |- ( ( ps /\ th /\ ph ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adantl1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ta /\ ph /\ ps ) /\ ch ) -> th ) ;
	}

	/*  [26-Feb-2005]  */ /*  [24-Feb-2005]  */ 
	proof of _3adantl1 {
		step 1 : wff = theorem ex (hyp 1) |- ( ( ph /\ ps ) -> ( ch -> th ) ) ;
		step 2 : wff = theorem _3adant1 (step 1) |- ( ( ta /\ ph /\ ps ) -> ( ch -> th ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ( ta /\ ph /\ ps ) /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adantl2 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ta /\ ps ) /\ ch ) -> th ) ;
	}

	/*  [25-Feb-2005]  */ /*  [24-Feb-2005]  */ 
	proof of _3adantl2 {
		step 1 : wff = theorem ex (hyp 1) |- ( ( ph /\ ps ) -> ( ch -> th ) ) ;
		step 2 : wff = theorem _3adant2 (step 1) |- ( ( ph /\ ta /\ ps ) -> ( ch -> th ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ( ph /\ ta /\ ps ) /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adantl3 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ps /\ ta ) /\ ch ) -> th ) ;
	}

	/*  [28-Apr-2005]  */ /*  [24-Feb-2005]  */ 
	proof of _3adantl3 {
		step 1 : wff = theorem ex (hyp 1) |- ( ( ph /\ ps ) -> ( ch -> th ) ) ;
		step 2 : wff = theorem _3adant3 (step 1) |- ( ( ph /\ ps /\ ta ) -> ( ch -> th ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ( ph /\ ps /\ ta ) /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adantr1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ta /\ ps /\ ch ) ) -> th ) ;
	}

	/*  [27-Jun-2005]  */ /*  [27-Apr-2005]  */ 
	proof of _3adantr1 {
		step 1 : wff = theorem ancoms (hyp 1) |- ( ( ( ps /\ ch ) /\ ph ) -> th ) ;
		step 2 : wff = theorem _3adantl1 (step 1) |- ( ( ( ta /\ ps /\ ch ) /\ ph ) -> th ) ;
		step 3 : wff = theorem ancoms (step 2) |- ( ( ph /\ ( ta /\ ps /\ ch ) ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adantr2 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ta /\ ch ) ) -> th ) ;
	}

	/*  [28-Apr-2005]  */ /*  [27-Apr-2005]  */ 
	proof of _3adantr2 {
		step 1 : wff = theorem ancoms (hyp 1) |- ( ( ( ps /\ ch ) /\ ph ) -> th ) ;
		step 2 : wff = theorem _3adantl2 (step 1) |- ( ( ( ps /\ ta /\ ch ) /\ ph ) -> th ) ;
		step 3 : wff = theorem ancoms (step 2) |- ( ( ph /\ ( ps /\ ta /\ ch ) ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adantr3 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ch /\ ta ) ) -> th ) ;
	}

	/*  [28-Apr-2005]  */ /*  [27-Apr-2005]  */ 
	proof of _3adantr3 {
		step 1 : wff = theorem ancoms (hyp 1) |- ( ( ( ps /\ ch ) /\ ph ) -> th ) ;
		step 2 : wff = theorem _3adantl3 (step 1) |- ( ( ( ps /\ ch /\ ta ) /\ ph ) -> th ) ;
		step 3 : wff = theorem ancoms (step 2) |- ( ( ph /\ ( ps /\ ch /\ ta ) ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding conjuncts to antecedent.  */
	theorem _3ad2antl1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ps /\ ta ) /\ ch ) -> th ) ;
	}

	/*  [4-Aug-2007]  */ /*  [4-Aug-2007]  */ 
	proof of _3ad2antl1 {
		step 1 : wff = theorem adantlr (hyp 1) |- ( ( ( ph /\ ta ) /\ ch ) -> th ) ;
		step 2 : wff = theorem _3adantl2 (step 1) |- ( ( ( ph /\ ps /\ ta ) /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding conjuncts to antecedent.  */
	theorem _3ad2antl2 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ps /\ ph /\ ta ) /\ ch ) -> th ) ;
	}

	/*  [4-Aug-2007]  */ /*  [4-Aug-2007]  */ 
	proof of _3ad2antl2 {
		step 1 : wff = theorem adantlr (hyp 1) |- ( ( ( ph /\ ta ) /\ ch ) -> th ) ;
		step 2 : wff = theorem _3adantl1 (step 1) |- ( ( ( ps /\ ph /\ ta ) /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding conjuncts to antecedent.  */
	theorem _3ad2antl3 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ps /\ ta /\ ph ) /\ ch ) -> th ) ;
	}

	/*  [4-Aug-2007]  */ /*  [4-Aug-2007]  */ 
	proof of _3ad2antl3 {
		step 1 : wff = theorem adantll (hyp 1) |- ( ( ( ta /\ ph ) /\ ch ) -> th ) ;
		step 2 : wff = theorem _3adantl1 (step 1) |- ( ( ( ps /\ ta /\ ph ) /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding a conjuncts to antecedent.  */
	theorem _3ad2antr1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ch /\ ps /\ ta ) ) -> th ) ;
	}

	/*  [25-Dec-2007]  */ /*  [25-Dec-2007]  */ 
	proof of _3ad2antr1 {
		step 1 : wff = theorem adantrr (hyp 1) |- ( ( ph /\ ( ch /\ ps ) ) -> th ) ;
		step 2 : wff = theorem _3adantr3 (step 1) |- ( ( ph /\ ( ch /\ ps /\ ta ) ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding a conjuncts to antecedent.  */
	theorem _3ad2antr2 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ch /\ ta ) ) -> th ) ;
	}

	/*  [27-Dec-2007]  */ /*  [27-Dec-2007]  */ 
	proof of _3ad2antr2 {
		step 1 : wff = theorem adantrl (hyp 1) |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		step 2 : wff = theorem _3adantr3 (step 1) |- ( ( ph /\ ( ps /\ ch /\ ta ) ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding a conjuncts to antecedent.  */
	theorem _3ad2antr3 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ta /\ ch ) ) -> th ) ;
	}

	/*  [30-Dec-2007]  */ /*  [30-Dec-2007]  */ 
	proof of _3ad2antr3 {
		step 1 : wff = theorem adantrl (hyp 1) |- ( ( ph /\ ( ta /\ ch ) ) -> th ) ;
		step 2 : wff = theorem _3adantr1 (step 1) |- ( ( ph /\ ( ps /\ ta /\ ch ) ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Introduction in triple disjunction.  */
	theorem _3mix1 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ph -> ( ph \/ ps \/ ch ) ) ;
	}

	/*  [4-Apr-1995]  */ 
	proof of _3mix1 {
		step 1 : wff = theorem orc () |- ( ph -> ( ph \/ ( ps \/ ch ) ) ) ;
		step 2 : wff = theorem _3orass () |- ( ( ph \/ ps \/ ch ) <-> ( ph \/ ( ps \/ ch ) ) ) ;
		step 3 : wff = theorem sylibr (step 1, step 2) |- ( ph -> ( ph \/ ps \/ ch ) ) ;
		qed prop = step 3 ;
	}

	/*  Introduction in triple disjunction.  */
	theorem _3mix2 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ph -> ( ps \/ ph \/ ch ) ) ;
	}

	/*  [4-Apr-1995]  */ 
	proof of _3mix2 {
		step 1 : wff = theorem _3mix1 () |- ( ph -> ( ph \/ ch \/ ps ) ) ;
		step 2 : wff = theorem _3orrot () |- ( ( ps \/ ph \/ ch ) <-> ( ph \/ ch \/ ps ) ) ;
		step 3 : wff = theorem sylibr (step 1, step 2) |- ( ph -> ( ps \/ ph \/ ch ) ) ;
		qed prop = step 3 ;
	}

	/*  Introduction in triple disjunction.  */
	theorem _3mix3 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ph -> ( ps \/ ch \/ ph ) ) ;
	}

	/*  [4-Apr-1995]  */ 
	proof of _3mix3 {
		step 1 : wff = theorem _3mix1 () |- ( ph -> ( ph \/ ps \/ ch ) ) ;
		step 2 : wff = theorem _3orrot () |- ( ( ph \/ ps \/ ch ) <-> ( ps \/ ch \/ ph ) ) ;
		step 3 : wff = theorem sylib (step 1, step 2) |- ( ph -> ( ps \/ ch \/ ph ) ) ;
		qed prop = step 3 ;
	}

	/*  Infer conjunction of premises.  */
	theorem _3pm3_2i (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- ps ;
		hyp 3 : wff = |- ch ;
		-----------------
		prop : wff = |- ( ph /\ ps /\ ch ) ;
	}

	/*  [10-Feb-1995]  */ 
	proof of _3pm3_2i {
		step 1 : wff = definition df-3an () |- ( ( ph /\ ps /\ ch ) <-> ( ( ph /\ ps ) /\ ch ) ) ;
		step 2 : wff = theorem pm3_2i (hyp 1, hyp 2) |- ( ph /\ ps ) ;
		step 3 : wff = theorem mpbir2an (step 1, step 2, hyp 3) |- ( ph /\ ps /\ ch ) ;
		qed prop = step 3 ;
	}

	/*  Join consequents with conjunction.  */
	theorem _3jca (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ph -> ch ) ;
		hyp 3 : wff = |- ( ph -> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps /\ ch /\ th ) ) ;
	}

	/*  [9-Apr-1994]  */ 
	proof of _3jca {
		step 1 : wff = theorem jca (hyp 1, hyp 2) |- ( ph -> ( ps /\ ch ) ) ;
		step 2 : wff = theorem jca (step 1, hyp 3) |- ( ph -> ( ( ps /\ ch ) /\ th ) ) ;
		step 3 : wff = definition df-3an () |- ( ( ps /\ ch /\ th ) <-> ( ( ps /\ ch ) /\ th ) ) ;
		step 4 : wff = theorem sylibr (step 2, step 3) |- ( ph -> ( ps /\ ch /\ th ) ) ;
		qed prop = step 4 ;
	}

	/*  Deduction conjoining the consequents of three implications.  */
	theorem _3jcad (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( ps -> th ) ) ;
		hyp 3 : wff = |- ( ph -> ( ps -> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch /\ th /\ ta ) ) ) ;
	}

	/*  [3-Oct-2005]  */ /*  [25-Sep-2005]  */ 
	proof of _3jcad {
		step 1 : wff = theorem imp (hyp 1) |- ( ( ph /\ ps ) -> ch ) ;
		step 2 : wff = theorem imp (hyp 2) |- ( ( ph /\ ps ) -> th ) ;
		step 3 : wff = theorem imp (hyp 3) |- ( ( ph /\ ps ) -> ta ) ;
		step 4 : wff = theorem _3jca (step 1, step 2, step 3) |- ( ( ph /\ ps ) -> ( ch /\ th /\ ta ) ) ;
		step 5 : wff = theorem ex (step 4) |- ( ph -> ( ps -> ( ch /\ th /\ ta ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Join antecedents and consequents with conjunction.  */
	theorem _3anim123i (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ch -> th ) ;
		hyp 3 : wff = |- ( ta -> et ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ch /\ ta ) -> ( ps /\ th /\ et ) ) ;
	}

	/*  [8-Apr-1994]  */ 
	proof of _3anim123i {
		step 1 : wff = theorem anim12i (hyp 1, hyp 2) |- ( ( ph /\ ch ) -> ( ps /\ th ) ) ;
		step 2 : wff = theorem anim12i (step 1, hyp 3) |- ( ( ( ph /\ ch ) /\ ta ) -> ( ( ps /\ th ) /\ et ) ) ;
		step 3 : wff = definition df-3an () |- ( ( ph /\ ch /\ ta ) <-> ( ( ph /\ ch ) /\ ta ) ) ;
		step 4 : wff = definition df-3an () |- ( ( ps /\ th /\ et ) <-> ( ( ps /\ th ) /\ et ) ) ;
		step 5 : wff = theorem _3imtr4 (step 2, step 3, step 4) |- ( ( ph /\ ch /\ ta ) -> ( ps /\ th /\ et ) ) ;
		qed prop = step 5 ;
	}

	/*  Join 3 biconditionals with conjunction.  */
	theorem _3anbi123i (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ch <-> th ) ;
		hyp 3 : wff = |- ( ta <-> et ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ch /\ ta ) <-> ( ps /\ th /\ et ) ) ;
	}

	/*  [21-Apr-1994]  */ 
	proof of _3anbi123i {
		step 1 : wff = theorem anbi12i (hyp 1, hyp 2) |- ( ( ph /\ ch ) <-> ( ps /\ th ) ) ;
		step 2 : wff = theorem anbi12i (step 1, hyp 3) |- ( ( ( ph /\ ch ) /\ ta ) <-> ( ( ps /\ th ) /\ et ) ) ;
		step 3 : wff = definition df-3an () |- ( ( ph /\ ch /\ ta ) <-> ( ( ph /\ ch ) /\ ta ) ) ;
		step 4 : wff = definition df-3an () |- ( ( ps /\ th /\ et ) <-> ( ( ps /\ th ) /\ et ) ) ;
		step 5 : wff = theorem _3bitr4 (step 2, step 3, step 4) |- ( ( ph /\ ch /\ ta ) <-> ( ps /\ th /\ et ) ) ;
		qed prop = step 5 ;
	}

	/*  Join 3 biconditionals with disjunction.  */
	theorem _3orbi123i (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		hyp 2 : wff = |- ( ch <-> th ) ;
		hyp 3 : wff = |- ( ta <-> et ) ;
		-----------------
		prop : wff = |- ( ( ph \/ ch \/ ta ) <-> ( ps \/ th \/ et ) ) ;
	}

	/*  [17-May-1994]  */ 
	proof of _3orbi123i {
		step 1 : wff = theorem orbi12i (hyp 1, hyp 2) |- ( ( ph \/ ch ) <-> ( ps \/ th ) ) ;
		step 2 : wff = theorem orbi12i (step 1, hyp 3) |- ( ( ( ph \/ ch ) \/ ta ) <-> ( ( ps \/ th ) \/ et ) ) ;
		step 3 : wff = definition df-3or () |- ( ( ph \/ ch \/ ta ) <-> ( ( ph \/ ch ) \/ ta ) ) ;
		step 4 : wff = definition df-3or () |- ( ( ps \/ th \/ et ) <-> ( ( ps \/ th ) \/ et ) ) ;
		step 5 : wff = theorem _3bitr4 (step 2, step 3, step 4) |- ( ( ph \/ ch \/ ta ) <-> ( ps \/ th \/ et ) ) ;
		qed prop = step 5 ;
	}

	/*  Inference adding two conjuncts to each side of a biconditional.  */
	theorem _3anbi1i (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ch /\ th ) <-> ( ps /\ ch /\ th ) ) ;
	}

	/*  [8-Sep-2006]  */ /*  [8-Sep-2006]  */ 
	proof of _3anbi1i {
		step 1 : wff = theorem pm4_2 () |- ( ch <-> ch ) ;
		step 2 : wff = theorem pm4_2 () |- ( th <-> th ) ;
		step 3 : wff = theorem _3anbi123i (hyp 1, step 1, step 2) |- ( ( ph /\ ch /\ th ) <-> ( ps /\ ch /\ th ) ) ;
		qed prop = step 3 ;
	}

	/*  Inference adding two conjuncts to each side of a biconditional.  */
	theorem _3anbi2i (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ( ( ch /\ ph /\ th ) <-> ( ch /\ ps /\ th ) ) ;
	}

	/*  [5-Oct-2006]  */ /*  [8-Sep-2006]  */ 
	proof of _3anbi2i {
		step 1 : wff = theorem pm4_2 () |- ( ch <-> ch ) ;
		step 2 : wff = theorem pm4_2 () |- ( th <-> th ) ;
		step 3 : wff = theorem _3anbi123i (step 1, hyp 1, step 2) |- ( ( ch /\ ph /\ th ) <-> ( ch /\ ps /\ th ) ) ;
		qed prop = step 3 ;
	}

	/*  Inference adding two conjuncts to each side of a biconditional.  */
	theorem _3anbi3i (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph <-> ps ) ;
		-----------------
		prop : wff = |- ( ( ch /\ th /\ ph ) <-> ( ch /\ th /\ ps ) ) ;
	}

	/*  [18-Oct-2006]  */ /*  [8-Sep-2006]  */ 
	proof of _3anbi3i {
		step 1 : wff = theorem pm4_2 () |- ( ch <-> ch ) ;
		step 2 : wff = theorem pm4_2 () |- ( th <-> th ) ;
		step 3 : wff = theorem _3anbi123i (step 1, step 2, hyp 1) |- ( ( ch /\ th /\ ph ) <-> ( ch /\ th /\ ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Importation inference.  */
	theorem _3imp (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
	}

	/*  [8-Apr-1994]  */ 
	proof of _3imp {
		step 1 : wff = definition df-3an () |- ( ( ph /\ ps /\ ch ) <-> ( ( ph /\ ps ) /\ ch ) ) ;
		step 2 : wff = theorem imp31 (hyp 1) |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		step 3 : wff = theorem sylbi (step 1, step 2) |- ( ( ph /\ ps /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Importation from double to triple conjunction.  */
	theorem _3impa (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
	}

	/*  [20-Aug-1995]  */ 
	proof of _3impa {
		step 1 : wff = theorem exp31 (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem _3imp (step 1) |- ( ( ph /\ ps /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Importation from double to triple conjunction.  */
	theorem _3impb (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
	}

	/*  [20-Aug-1995]  */ 
	proof of _3impb {
		step 1 : wff = theorem exp32 (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem _3imp (step 1) |- ( ( ph /\ ps /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Importation to triple conjunction.  */
	theorem _3impia (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ( ch -> th ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
	}

	/*  [13-Jun-2006]  */ /*  [13-Jun-2006]  */ 
	proof of _3impia {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem _3imp (step 1) |- ( ( ph /\ ps /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Importation to triple conjunction.  */
	theorem _3impib (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
	}

	/*  [15-Jun-2006]  */ /*  [13-Jun-2006]  */ 
	proof of _3impib {
		step 1 : wff = theorem exp3a (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem _3imp (step 1) |- ( ( ph /\ ps /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Exportation inference.  */
	theorem _3exp (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
	}

	/*  [30-May-1994]  */ 
	proof of _3exp {
		step 1 : wff = definition df-3an () |- ( ( ph /\ ps /\ ch ) <-> ( ( ph /\ ps ) /\ ch ) ) ;
		step 2 : wff = theorem sylbir (step 1, hyp 1) |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		step 3 : wff = theorem exp31 (step 2) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Exportation from triple to double conjunction.  */
	theorem _3expa (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
	}

	/*  [20-Aug-1995]  */ 
	proof of _3expa {
		step 1 : wff = theorem _3exp (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem imp31 (step 1) |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Exportation from triple to double conjunction.  */
	theorem _3expb (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
	}

	/*  [20-Aug-1995]  */ 
	proof of _3expb {
		step 1 : wff = theorem _3exp (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem imp32 (step 1) |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Exportation from triple conjunction.  */
	theorem _3expia (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ( ch -> th ) ) ;
	}

	/*  [19-May-2007]  */ /*  [19-May-2007]  */ 
	proof of _3expia {
		step 1 : wff = theorem _3exp (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ph /\ ps ) -> ( ch -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  Exportation from triple conjunction.  */
	theorem _3expib (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
	}

	/*  [20-May-2007]  */ /*  [19-May-2007]  */ 
	proof of _3expib {
		step 1 : wff = theorem _3exp (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem imp3a (step 1) |- ( ph -> ( ( ps /\ ch ) -> th ) ) ;
		qed prop = step 2 ;
	}

	/*  Commutation in antecedent.  Swap 1st and 3rd.  */
	theorem _3com12 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ps /\ ph /\ ch ) -> th ) ;
	}

	/*  [28-Jan-1996]  */ 
	proof of _3com12 {
		step 1 : wff = theorem _3exp (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem com12 (step 1) |- ( ps -> ( ph -> ( ch -> th ) ) ) ;
		step 3 : wff = theorem _3imp (step 2) |- ( ( ps /\ ph /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Commutation in antecedent.  Swap 1st and 3rd.  */
	theorem _3com13 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ch /\ ps /\ ph ) -> th ) ;
	}

	/*  [28-Jan-1996]  */ 
	proof of _3com13 {
		step 1 : wff = theorem _3anrev () |- ( ( ch /\ ps /\ ph ) <-> ( ph /\ ps /\ ch ) ) ;
		step 2 : wff = theorem sylbi (step 1, hyp 1) |- ( ( ch /\ ps /\ ph ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Commutation in antecedent.  Swap 2nd and 3rd.  */
	theorem _3com23 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ch /\ ps ) -> th ) ;
	}

	/*  [28-Jan-1996]  */ 
	proof of _3com23 {
		step 1 : wff = theorem _3exp (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem com23 (step 1) |- ( ph -> ( ch -> ( ps -> th ) ) ) ;
		step 3 : wff = theorem _3imp (step 2) |- ( ( ph /\ ch /\ ps ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Commutation in antecedent.  Rotate left.  */
	theorem _3coml (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ps /\ ch /\ ph ) -> th ) ;
	}

	/*  [28-Jan-1996]  */ 
	proof of _3coml {
		step 1 : wff = theorem _3com23 (hyp 1) |- ( ( ph /\ ch /\ ps ) -> th ) ;
		step 2 : wff = theorem _3com13 (step 1) |- ( ( ps /\ ch /\ ph ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Commutation in antecedent.  Rotate right.  */
	theorem _3comr (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ch /\ ph /\ ps ) -> th ) ;
	}

	/*  [28-Jan-1996]  */ 
	proof of _3comr {
		step 1 : wff = theorem _3coml (hyp 1) |- ( ( ps /\ ch /\ ph ) -> th ) ;
		step 2 : wff = theorem _3coml (step 1) |- ( ( ch /\ ph /\ ps ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adant3r1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ta /\ ps /\ ch ) ) -> th ) ;
	}

	/*  [16-Feb-2008]  */ /*  [16-Feb-2008]  */ 
	proof of _3adant3r1 {
		step 1 : wff = theorem _3expb (hyp 1) |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		step 2 : wff = theorem _3adantr1 (step 1) |- ( ( ph /\ ( ta /\ ps /\ ch ) ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adant3r2 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ta /\ ch ) ) -> th ) ;
	}

	/*  [17-Feb-2008]  */ /*  [17-Feb-2008]  */ 
	proof of _3adant3r2 {
		step 1 : wff = theorem _3expb (hyp 1) |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		step 2 : wff = theorem _3adantr2 (step 1) |- ( ( ph /\ ( ps /\ ta /\ ch ) ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adant3r3 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ch /\ ta ) ) -> th ) ;
	}

	/*  [18-Feb-2008]  */ /*  [18-Feb-2008]  */ 
	proof of _3adant3r3 {
		step 1 : wff = theorem _3expb (hyp 1) |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		step 2 : wff = theorem _3adantr3 (step 1) |- ( ( ph /\ ( ps /\ ch /\ ta ) ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Importation to left triple conjunction.  */
	theorem _3imp1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ps /\ ch ) /\ th ) -> ta ) ;
	}

	/*  [26-Feb-2005]  */ /*  [24-Feb-2005]  */ 
	proof of _3imp1 {
		step 1 : wff = theorem _3imp (hyp 1) |- ( ( ph /\ ps /\ ch ) -> ( th -> ta ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ( ph /\ ps /\ ch ) /\ th ) -> ta ) ;
		qed prop = step 2 ;
	}

	/*  Importation deduction for triple conjunction.  */
	theorem _3impd (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ ch /\ th ) -> ta ) ) ;
	}

	/*  [28-Oct-2006]  */ /*  [26-Oct-2006]  */ 
	proof of _3impd {
		step 1 : wff = theorem com4l (hyp 1) |- ( ps -> ( ch -> ( th -> ( ph -> ta ) ) ) ) ;
		step 2 : wff = theorem _3imp (step 1) |- ( ( ps /\ ch /\ th ) -> ( ph -> ta ) ) ;
		step 3 : wff = theorem com12 (step 2) |- ( ph -> ( ( ps /\ ch /\ th ) -> ta ) ) ;
		qed prop = step 3 ;
	}

	/*  Importation to right triple conjunction.  */
	theorem _3imp2 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ch /\ th ) ) -> ta ) ;
	}

	/*  [28-Oct-2006]  */ /*  [26-Oct-2006]  */ 
	proof of _3imp2 {
		step 1 : wff = theorem _3impd (hyp 1) |- ( ph -> ( ( ps /\ ch /\ th ) -> ta ) ) ;
		step 2 : wff = theorem imp (step 1) |- ( ( ph /\ ( ps /\ ch /\ th ) ) -> ta ) ;
		qed prop = step 2 ;
	}

	/*  Exportation from left triple conjunction.  */
	theorem _3exp1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps /\ ch ) /\ th ) -> ta ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
	}

	/*  [26-Feb-2005]  */ /*  [24-Feb-2005]  */ 
	proof of _3exp1 {
		step 1 : wff = theorem ex (hyp 1) |- ( ( ph /\ ps /\ ch ) -> ( th -> ta ) ) ;
		step 2 : wff = theorem _3exp (step 1) |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Exportation deduction for triple conjunction.  */
	theorem _3expd (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ( ps /\ ch /\ th ) -> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
	}

	/*  [27-Oct-2006]  */ /*  [26-Oct-2006]  */ 
	proof of _3expd {
		step 1 : wff = theorem com12 (hyp 1) |- ( ( ps /\ ch /\ th ) -> ( ph -> ta ) ) ;
		step 2 : wff = theorem _3exp (step 1) |- ( ps -> ( ch -> ( th -> ( ph -> ta ) ) ) ) ;
		step 3 : wff = theorem com4r (step 2) |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Exportation from right triple conjunction.  */
	theorem _3exp2 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch /\ th ) ) -> ta ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
	}

	/*  [28-Oct-2006]  */ /*  [26-Oct-2006]  */ 
	proof of _3exp2 {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ( ps /\ ch /\ th ) -> ta ) ) ;
		step 2 : wff = theorem _3expd (step 1) |- ( ph -> ( ps -> ( ch -> ( th -> ta ) ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adant1l (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ta /\ ph ) /\ ps /\ ch ) -> th ) ;
	}

	/*  [12-Jan-2006]  */ /*  [8-Jan-2006]  */ 
	proof of _3adant1l {
		step 1 : wff = theorem _3expb (hyp 1) |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		step 2 : wff = theorem adantll (step 1) |- ( ( ( ta /\ ph ) /\ ( ps /\ ch ) ) -> th ) ;
		step 3 : wff = theorem _3impb (step 2) |- ( ( ( ta /\ ph ) /\ ps /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adant1r (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ta ) /\ ps /\ ch ) -> th ) ;
	}

	/*  [17-Jan-2006]  */ /*  [8-Jan-2006]  */ 
	proof of _3adant1r {
		step 1 : wff = theorem _3expb (hyp 1) |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		step 2 : wff = theorem adantlr (step 1) |- ( ( ( ph /\ ta ) /\ ( ps /\ ch ) ) -> th ) ;
		step 3 : wff = theorem _3impb (step 2) |- ( ( ( ph /\ ta ) /\ ps /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adant2l (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ta /\ ps ) /\ ch ) -> th ) ;
	}

	/*  [22-Feb-2006]  */ /*  [8-Jan-2006]  */ 
	proof of _3adant2l {
		step 1 : wff = theorem _3com12 (hyp 1) |- ( ( ps /\ ph /\ ch ) -> th ) ;
		step 2 : wff = theorem _3adant1l (step 1) |- ( ( ( ta /\ ps ) /\ ph /\ ch ) -> th ) ;
		step 3 : wff = theorem _3com12 (step 2) |- ( ( ph /\ ( ta /\ ps ) /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adant2r (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ta ) /\ ch ) -> th ) ;
	}

	/*  [23-Jan-2006]  */ /*  [8-Jan-2006]  */ 
	proof of _3adant2r {
		step 1 : wff = theorem _3com12 (hyp 1) |- ( ( ps /\ ph /\ ch ) -> th ) ;
		step 2 : wff = theorem _3adant1r (step 1) |- ( ( ( ps /\ ta ) /\ ph /\ ch ) -> th ) ;
		step 3 : wff = theorem _3com12 (step 2) |- ( ( ph /\ ( ps /\ ta ) /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adant3l (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps /\ ( ta /\ ch ) ) -> th ) ;
	}

	/*  [5-Feb-2006]  */ /*  [8-Jan-2006]  */ 
	proof of _3adant3l {
		step 1 : wff = theorem _3com13 (hyp 1) |- ( ( ch /\ ps /\ ph ) -> th ) ;
		step 2 : wff = theorem _3adant1l (step 1) |- ( ( ( ta /\ ch ) /\ ps /\ ph ) -> th ) ;
		step 3 : wff = theorem _3com13 (step 2) |- ( ( ph /\ ps /\ ( ta /\ ch ) ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  Deduction adding a conjunct to antecedent.  */
	theorem _3adant3r (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps /\ ( ch /\ ta ) ) -> th ) ;
	}

	/*  [27-Jan-2006]  */ /*  [8-Jan-2006]  */ 
	proof of _3adant3r {
		step 1 : wff = theorem _3com13 (hyp 1) |- ( ( ch /\ ps /\ ph ) -> th ) ;
		step 2 : wff = theorem _3adant1r (step 1) |- ( ( ( ch /\ ta ) /\ ps /\ ph ) -> th ) ;
		step 3 : wff = theorem _3com13 (step 2) |- ( ( ph /\ ps /\ ( ch /\ ta ) ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  A syllogism inference combined with contraction.  */
	theorem syl3anc (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		hyp 2 : wff = |- ( ta -> ph ) ;
		hyp 3 : wff = |- ( ta -> ps ) ;
		hyp 4 : wff = |- ( ta -> ch ) ;
		-----------------
		prop : wff = |- ( ta -> th ) ;
	}

	/*  [2-Jan-2005]  */ /*  [1-Jan-2005]  */ 
	proof of syl3anc {
		step 1 : wff = theorem _3jca (hyp 2, hyp 3, hyp 4) |- ( ta -> ( ph /\ ps /\ ch ) ) ;
		step 2 : wff = theorem syl (step 1, hyp 1) |- ( ta -> th ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem syl3an1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		hyp 2 : wff = |- ( ta -> ph ) ;
		-----------------
		prop : wff = |- ( ( ta /\ ps /\ ch ) -> th ) ;
	}

	/*  [22-Aug-1995]  */ 
	proof of syl3an1 {
		step 1 : wff = theorem _3expb (hyp 1) |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		step 2 : wff = theorem sylan (step 1, hyp 2) |- ( ( ta /\ ( ps /\ ch ) ) -> th ) ;
		step 3 : wff = theorem _3impb (step 2) |- ( ( ta /\ ps /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  A syllogism inference.  */
	theorem syl3an2 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		hyp 2 : wff = |- ( ta -> ps ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ta /\ ch ) -> th ) ;
	}

	/*  [22-Aug-1995]  */ 
	proof of syl3an2 {
		step 1 : wff = theorem _3exp (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem syl5 (step 1, hyp 2) |- ( ph -> ( ta -> ( ch -> th ) ) ) ;
		step 3 : wff = theorem _3imp (step 2) |- ( ( ph /\ ta /\ ch ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  A syllogism inference.  */
	theorem syl3an3 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		hyp 2 : wff = |- ( ta -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps /\ ta ) -> th ) ;
	}

	/*  [22-Aug-1995]  */ 
	proof of syl3an3 {
		step 1 : wff = theorem _3exp (hyp 1) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem syl7 (step 1, hyp 2) |- ( ph -> ( ps -> ( ta -> th ) ) ) ;
		step 3 : wff = theorem _3imp (step 2) |- ( ( ph /\ ps /\ ta ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  A syllogism inference.  */
	theorem syl3an1b (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		hyp 2 : wff = |- ( ta <-> ph ) ;
		-----------------
		prop : wff = |- ( ( ta /\ ps /\ ch ) -> th ) ;
	}

	/*  [22-Aug-1995]  */ 
	proof of syl3an1b {
		step 1 : wff = theorem biimp (hyp 2) |- ( ta -> ph ) ;
		step 2 : wff = theorem syl3an1 (hyp 1, step 1) |- ( ( ta /\ ps /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem syl3an2b (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		hyp 2 : wff = |- ( ta <-> ps ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ta /\ ch ) -> th ) ;
	}

	/*  [22-Aug-1995]  */ 
	proof of syl3an2b {
		step 1 : wff = theorem biimp (hyp 2) |- ( ta -> ps ) ;
		step 2 : wff = theorem syl3an2 (hyp 1, step 1) |- ( ( ph /\ ta /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem syl3an3b (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		hyp 2 : wff = |- ( ta <-> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps /\ ta ) -> th ) ;
	}

	/*  [22-Aug-1995]  */ 
	proof of syl3an3b {
		step 1 : wff = theorem biimp (hyp 2) |- ( ta -> ch ) ;
		step 2 : wff = theorem syl3an3 (hyp 1, step 1) |- ( ( ph /\ ps /\ ta ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem syl3an1br (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		hyp 2 : wff = |- ( ph <-> ta ) ;
		-----------------
		prop : wff = |- ( ( ta /\ ps /\ ch ) -> th ) ;
	}

	/*  [22-Aug-1995]  */ 
	proof of syl3an1br {
		step 1 : wff = theorem biimpr (hyp 2) |- ( ta -> ph ) ;
		step 2 : wff = theorem syl3an1 (hyp 1, step 1) |- ( ( ta /\ ps /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem syl3an2br (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		hyp 2 : wff = |- ( ps <-> ta ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ta /\ ch ) -> th ) ;
	}

	/*  [22-Aug-1995]  */ 
	proof of syl3an2br {
		step 1 : wff = theorem biimpr (hyp 2) |- ( ta -> ps ) ;
		step 2 : wff = theorem syl3an2 (hyp 1, step 1) |- ( ( ph /\ ta /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem syl3an3br (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		hyp 2 : wff = |- ( ch <-> ta ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps /\ ta ) -> th ) ;
	}

	/*  [22-Aug-1995]  */ 
	proof of syl3an3br {
		step 1 : wff = theorem biimpr (hyp 2) |- ( ta -> ch ) ;
		step 2 : wff = theorem syl3an3 (hyp 1, step 1) |- ( ( ph /\ ps /\ ta ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  A triple syllogism inference.  */
	theorem syl3an (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff , var ze : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		hyp 2 : wff = |- ( ta -> ph ) ;
		hyp 3 : wff = |- ( et -> ps ) ;
		hyp 4 : wff = |- ( ze -> ch ) ;
		-----------------
		prop : wff = |- ( ( ta /\ et /\ ze ) -> th ) ;
	}

	/*  [14-May-2004]  */ /*  [13-May-2004]  */ 
	proof of syl3an {
		step 1 : wff = theorem _3anim123i (hyp 2, hyp 3, hyp 4) |- ( ( ta /\ et /\ ze ) -> ( ph /\ ps /\ ch ) ) ;
		step 2 : wff = theorem syl (step 1, hyp 1) |- ( ( ta /\ et /\ ze ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  A triple syllogism inference.  */
	theorem syl3anb (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff , var ze : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		hyp 2 : wff = |- ( ta <-> ph ) ;
		hyp 3 : wff = |- ( et <-> ps ) ;
		hyp 4 : wff = |- ( ze <-> ch ) ;
		-----------------
		prop : wff = |- ( ( ta /\ et /\ ze ) -> th ) ;
	}

	/*  [20-Oct-2005]  */ /*  [15-Oct-2005]  */ 
	proof of syl3anb {
		step 1 : wff = theorem _3anbi123i (hyp 2, hyp 3, hyp 4) |- ( ( ta /\ et /\ ze ) <-> ( ph /\ ps /\ ch ) ) ;
		step 2 : wff = theorem sylbi (step 1, hyp 1) |- ( ( ta /\ et /\ ze ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem syl3dan3 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		hyp 2 : wff = |- ( ( ph /\ ps /\ ta ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps /\ ta ) -> th ) ;
	}

	/*  [23-May-2007]  */ /*  [20-May-2007]  */ 
	proof of syl3dan3 {
		step 1 : wff = theorem _3simp1 () |- ( ( ph /\ ps /\ ta ) -> ph ) ;
		step 2 : wff = theorem _3simp2 () |- ( ( ph /\ ps /\ ta ) -> ps ) ;
		step 3 : wff = theorem syl3anc (hyp 1, step 1, step 2, hyp 2) |- ( ( ph /\ ps /\ ta ) -> th ) ;
		qed prop = step 3 ;
	}

	/*  A syllogism inference.  */
	theorem syl3dan2 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		hyp 2 : wff = |- ( ( ph /\ ta /\ ch ) -> ps ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ta /\ ch ) -> th ) ;
	}

	/*  [24-May-2007]  */ /*  [20-May-2007]  */ 
	proof of syl3dan2 {
		step 1 : wff = theorem _3com23 (hyp 1) |- ( ( ph /\ ch /\ ps ) -> th ) ;
		step 2 : wff = theorem _3com23 (hyp 2) |- ( ( ph /\ ch /\ ta ) -> ps ) ;
		step 3 : wff = theorem syl3dan3 (step 1, step 2) |- ( ( ph /\ ch /\ ta ) -> th ) ;
		step 4 : wff = theorem _3com23 (step 3) |- ( ( ph /\ ta /\ ch ) -> th ) ;
		qed prop = step 4 ;
	}

	/*  A syllogism inference.  */
	theorem syl3anl1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps /\ ch ) /\ th ) -> ta ) ;
		hyp 2 : wff = |- ( et -> ph ) ;
		-----------------
		prop : wff = |- ( ( ( et /\ ps /\ ch ) /\ th ) -> ta ) ;
	}

	/*  [28-Apr-2005]  */ /*  [24-Feb-2005]  */ 
	proof of syl3anl1 {
		step 1 : wff = theorem ex (hyp 1) |- ( ( ph /\ ps /\ ch ) -> ( th -> ta ) ) ;
		step 2 : wff = theorem syl3an1 (step 1, hyp 2) |- ( ( et /\ ps /\ ch ) -> ( th -> ta ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ( et /\ ps /\ ch ) /\ th ) -> ta ) ;
		qed prop = step 3 ;
	}

	/*  A syllogism inference.  */
	theorem syl3anl2 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps /\ ch ) /\ th ) -> ta ) ;
		hyp 2 : wff = |- ( et -> ps ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ et /\ ch ) /\ th ) -> ta ) ;
	}

	/*  [26-Feb-2005]  */ /*  [24-Feb-2005]  */ 
	proof of syl3anl2 {
		step 1 : wff = theorem ex (hyp 1) |- ( ( ph /\ ps /\ ch ) -> ( th -> ta ) ) ;
		step 2 : wff = theorem syl3an2 (step 1, hyp 2) |- ( ( ph /\ et /\ ch ) -> ( th -> ta ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ( ph /\ et /\ ch ) /\ th ) -> ta ) ;
		qed prop = step 3 ;
	}

	/*  A syllogism inference.  */
	theorem syl3anl3 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps /\ ch ) /\ th ) -> ta ) ;
		hyp 2 : wff = |- ( et -> ch ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ps /\ et ) /\ th ) -> ta ) ;
	}

	/*  [27-Jun-2005]  */ /*  [24-Feb-2005]  */ 
	proof of syl3anl3 {
		step 1 : wff = theorem ex (hyp 1) |- ( ( ph /\ ps /\ ch ) -> ( th -> ta ) ) ;
		step 2 : wff = theorem syl3an3 (step 1, hyp 2) |- ( ( ph /\ ps /\ et ) -> ( th -> ta ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ( ph /\ ps /\ et ) /\ th ) -> ta ) ;
		qed prop = step 3 ;
	}

	/*  A triple syllogism inference.  */
	theorem syl3anl (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff , var ze : wff , var si : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps /\ ch ) /\ th ) -> ta ) ;
		hyp 2 : wff = |- ( et -> ph ) ;
		hyp 3 : wff = |- ( ze -> ps ) ;
		hyp 4 : wff = |- ( si -> ch ) ;
		-----------------
		prop : wff = |- ( ( ( et /\ ze /\ si ) /\ th ) -> ta ) ;
	}

	/*  [24-Dec-2006]  */ /*  [24-Dec-2006]  */ 
	proof of syl3anl {
		step 1 : wff = theorem _3anim123i (hyp 2, hyp 3, hyp 4) |- ( ( et /\ ze /\ si ) -> ( ph /\ ps /\ ch ) ) ;
		step 2 : wff = theorem sylan (hyp 1, step 1) |- ( ( ( et /\ ze /\ si ) /\ th ) -> ta ) ;
		qed prop = step 2 ;
	}

	/*  A syllogism inference.  */
	theorem syl3anr1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch /\ th ) ) -> ta ) ;
		hyp 2 : wff = |- ( et -> ps ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( et /\ ch /\ th ) ) -> ta ) ;
	}

	/*  [16-Aug-2007]  */ /*  [31-Jul-2007]  */ 
	proof of syl3anr1 {
		step 1 : wff = theorem ancoms (hyp 1) |- ( ( ( ps /\ ch /\ th ) /\ ph ) -> ta ) ;
		step 2 : wff = theorem syl3anl1 (step 1, hyp 2) |- ( ( ( et /\ ch /\ th ) /\ ph ) -> ta ) ;
		step 3 : wff = theorem ancoms (step 2) |- ( ( ph /\ ( et /\ ch /\ th ) ) -> ta ) ;
		qed prop = step 3 ;
	}

	/*  A syllogism inference.  */
	theorem syl3anr2 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch /\ th ) ) -> ta ) ;
		hyp 2 : wff = |- ( et -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ et /\ th ) ) -> ta ) ;
	}

	/*  [6-Aug-2007]  */ /*  [1-Aug-2007]  */ 
	proof of syl3anr2 {
		step 1 : wff = theorem ancoms (hyp 1) |- ( ( ( ps /\ ch /\ th ) /\ ph ) -> ta ) ;
		step 2 : wff = theorem syl3anl2 (step 1, hyp 2) |- ( ( ( ps /\ et /\ th ) /\ ph ) -> ta ) ;
		step 3 : wff = theorem ancoms (step 2) |- ( ( ph /\ ( ps /\ et /\ th ) ) -> ta ) ;
		qed prop = step 3 ;
	}

	/*  A syllogism inference.  */
	theorem syl3anr3 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ( ps /\ ch /\ th ) ) -> ta ) ;
		hyp 2 : wff = |- ( et -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ch /\ et ) ) -> ta ) ;
	}

	/*  [23-Aug-2007]  */ /*  [23-Aug-2007]  */ 
	proof of syl3anr3 {
		step 1 : wff = theorem ancoms (hyp 1) |- ( ( ( ps /\ ch /\ th ) /\ ph ) -> ta ) ;
		step 2 : wff = theorem syl3anl3 (step 1, hyp 2) |- ( ( ( ps /\ ch /\ et ) /\ ph ) -> ta ) ;
		step 3 : wff = theorem ancoms (step 2) |- ( ( ph /\ ( ps /\ ch /\ et ) ) -> ta ) ;
		qed prop = step 3 ;
	}

	/*  Importation inference (undistribute conjunction).  */
	theorem _3impdi (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ( ph /\ ch ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
	}

	/*  [14-Aug-1995]  */ 
	proof of _3impdi {
		step 1 : wff = theorem anandis (hyp 1) |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		step 2 : wff = theorem _3impb (step 1) |- ( ( ph /\ ps /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Importation inference (undistribute conjunction).  */
	theorem _3impdir (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ( ch /\ ps ) ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ch /\ ps ) -> th ) ;
	}

	/*  [20-Aug-1995]  */ 
	proof of _3impdir {
		step 1 : wff = theorem anandirs (hyp 1) |- ( ( ( ph /\ ch ) /\ ps ) -> th ) ;
		step 2 : wff = theorem _3impa (step 1) |- ( ( ph /\ ch /\ ps ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Inference from idempotent law for conjunction.  */
	theorem _3anidm12 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ph /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [7-Mar-2008]  */ /*  [7-Mar-2008]  */ 
	proof of _3anidm12 {
		step 1 : wff = theorem _3exp (hyp 1) |- ( ph -> ( ph -> ( ps -> ch ) ) ) ;
		step 2 : wff = theorem pm2_43i (step 1) |- ( ph -> ( ps -> ch ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 3 ;
	}

	/*  Inference from idempotent law for conjunction.  */
	theorem _3anidm13 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ph ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [10-Mar-2008]  */ /*  [7-Mar-2008]  */ 
	proof of _3anidm13 {
		step 1 : wff = theorem _3com23 (hyp 1) |- ( ( ph /\ ph /\ ps ) -> ch ) ;
		step 2 : wff = theorem _3anidm12 (step 1) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 2 ;
	}

	/*  Inference from idempotent law for conjunction.  */
	theorem _3anidm23 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> ch ) ;
	}

	/*  [1-Feb-2007]  */ /*  [1-Feb-2007]  */ 
	proof of _3anidm23 {
		step 1 : wff = theorem _3exp (hyp 1) |- ( ph -> ( ps -> ( ps -> ch ) ) ) ;
		step 2 : wff = theorem pm2_43d (step 1) |- ( ph -> ( ps -> ch ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ph /\ ps ) -> ch ) ;
		qed prop = step 3 ;
	}

	/*  Infer implication from triple disjunction.  */
	theorem _3ori (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph \/ ps \/ ch ) ;
		-----------------
		prop : wff = |- ( ( -. ph /\ -. ps ) -> ch ) ;
	}

	/*  [28-Sep-2006]  */ /*  [26-Sep-2006]  */ 
	proof of _3ori {
		step 1 : wff = theorem ioran () |- ( -. ( ph \/ ps ) <-> ( -. ph /\ -. ps ) ) ;
		step 2 : wff = definition df-3or () |- ( ( ph \/ ps \/ ch ) <-> ( ( ph \/ ps ) \/ ch ) ) ;
		step 3 : wff = theorem mpbi (hyp 1, step 2) |- ( ( ph \/ ps ) \/ ch ) ;
		step 4 : wff = theorem ori (step 3) |- ( -. ( ph \/ ps ) -> ch ) ;
		step 5 : wff = theorem sylbir (step 1, step 4) |- ( ( -. ph /\ -. ps ) -> ch ) ;
		qed prop = step 5 ;
	}

	/*  Disjunction of 3 antecedents.  */
	theorem _3jao (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) /\ ( ch -> ps ) /\ ( th -> ps ) ) -> ( ( ph \/ ch \/ th ) -> ps ) ) ;
	}

	/*  [8-Apr-1994]  */ 
	proof of _3jao {
		step 1 : wff = theorem jao () |- ( ( ph -> ps ) -> ( ( ch -> ps ) -> ( ( ph \/ ch ) -> ps ) ) ) ;
		step 2 : wff = theorem jao () |- ( ( ( ph \/ ch ) -> ps ) -> ( ( th -> ps ) -> ( ( ( ph \/ ch ) \/ th ) -> ps ) ) ) ;
		step 3 : wff = theorem syl6 (step 1, step 2) |- ( ( ph -> ps ) -> ( ( ch -> ps ) -> ( ( th -> ps ) -> ( ( ( ph \/ ch ) \/ th ) -> ps ) ) ) ) ;
		step 4 : wff = theorem _3imp (step 3) |- ( ( ( ph -> ps ) /\ ( ch -> ps ) /\ ( th -> ps ) ) -> ( ( ( ph \/ ch ) \/ th ) -> ps ) ) ;
		step 5 : wff = definition df-3or () |- ( ( ph \/ ch \/ th ) <-> ( ( ph \/ ch ) \/ th ) ) ;
		step 6 : wff = theorem syl5ib (step 4, step 5) |- ( ( ( ph -> ps ) /\ ( ch -> ps ) /\ ( th -> ps ) ) -> ( ( ph \/ ch \/ th ) -> ps ) ) ;
		qed prop = step 6 ;
	}

	/*  Disjunction of 3 antecedents (inference).  */
	theorem _3jaoi (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ch -> ps ) ;
		hyp 3 : wff = |- ( th -> ps ) ;
		-----------------
		prop : wff = |- ( ( ph \/ ch \/ th ) -> ps ) ;
	}

	/*  [12-Sep-1995]  */ 
	proof of _3jaoi {
		step 1 : wff = theorem _3pm3_2i (hyp 1, hyp 2, hyp 3) |- ( ( ph -> ps ) /\ ( ch -> ps ) /\ ( th -> ps ) ) ;
		step 2 : wff = theorem _3jao () |- ( ( ( ph -> ps ) /\ ( ch -> ps ) /\ ( th -> ps ) ) -> ( ( ph \/ ch \/ th ) -> ps ) ) ;
		step 3 : wff = axiom ax-mp (step 1, step 2) |- ( ( ph \/ ch \/ th ) -> ps ) ;
		qed prop = step 3 ;
	}

	/*  Disjunction of 3 antecedents (deduction).  */
	theorem _3jaod (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th -> ch ) ) ;
		hyp 3 : wff = |- ( ph -> ( ta -> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps \/ th \/ ta ) -> ch ) ) ;
	}

	/*  [16-Oct-2005]  */ /*  [14-Oct-2005]  */ 
	proof of _3jaod {
		step 1 : wff = theorem _3jao () |- ( ( ( ps -> ch ) /\ ( th -> ch ) /\ ( ta -> ch ) ) -> ( ( ps \/ th \/ ta ) -> ch ) ) ;
		step 2 : wff = theorem syl3anc (step 1, hyp 1, hyp 2, hyp 3) |- ( ph -> ( ( ps \/ th \/ ta ) -> ch ) ) ;
		qed prop = step 2 ;
	}

	/*  Disjunction of 3 antecedents (inference).  */
	theorem _3jaoian (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( ( th /\ ps ) -> ch ) ;
		hyp 3 : wff = |- ( ( ta /\ ps ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ( ph \/ th \/ ta ) /\ ps ) -> ch ) ;
	}

	/*  [17-Oct-2005]  */ /*  [14-Oct-2005]  */ 
	proof of _3jaoian {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem ex (hyp 2) |- ( th -> ( ps -> ch ) ) ;
		step 3 : wff = theorem ex (hyp 3) |- ( ta -> ( ps -> ch ) ) ;
		step 4 : wff = theorem _3jaoi (step 1, step 2, step 3) |- ( ( ph \/ th \/ ta ) -> ( ps -> ch ) ) ;
		step 5 : wff = theorem imp (step 4) |- ( ( ( ph \/ th \/ ta ) /\ ps ) -> ch ) ;
		qed prop = step 5 ;
	}

	/*  Disjunction of 3 antecedents (deduction).  */
	theorem _3jaodan (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( ( ph /\ th ) -> ch ) ;
		hyp 3 : wff = |- ( ( ph /\ ta ) -> ch ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps \/ th \/ ta ) ) -> ch ) ;
	}

	/*  [21-Oct-2005]  */ /*  [14-Oct-2005]  */ 
	proof of _3jaodan {
		step 1 : wff = theorem ex (hyp 1) |- ( ph -> ( ps -> ch ) ) ;
		step 2 : wff = theorem ex (hyp 2) |- ( ph -> ( th -> ch ) ) ;
		step 3 : wff = theorem ex (hyp 3) |- ( ph -> ( ta -> ch ) ) ;
		step 4 : wff = theorem _3jaod (step 1, step 2, step 3) |- ( ph -> ( ( ps \/ th \/ ta ) -> ch ) ) ;
		step 5 : wff = theorem imp (step 4) |- ( ( ph /\ ( ps \/ th \/ ta ) ) -> ch ) ;
		qed prop = step 5 ;
	}

	/*  Nested syllogism inference conjoining 3 dissimilar antecedents.  */
	theorem syl3an9b (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff , var ze : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( th -> ( ch <-> ta ) ) ;
		hyp 3 : wff = |- ( et -> ( ta <-> ze ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ th /\ et ) -> ( ps <-> ze ) ) ;
	}

	/*  [1-May-1995]  */ 
	proof of syl3an9b {
		step 1 : wff = theorem sylan9bb (hyp 1, hyp 2) |- ( ( ph /\ th ) -> ( ps <-> ta ) ) ;
		step 2 : wff = theorem sylan9bb (step 1, hyp 3) |- ( ( ( ph /\ th ) /\ et ) -> ( ps <-> ze ) ) ;
		step 3 : wff = theorem _3impa (step 2) |- ( ( ph /\ th /\ et ) -> ( ps <-> ze ) ) ;
		qed prop = step 3 ;
	}

	/*  Deduction joining 3 equivalences to form equivalence of disjunctions.  */
	theorem _3orbi123d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff , var ze : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th <-> ta ) ) ;
		hyp 3 : wff = |- ( ph -> ( et <-> ze ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps \/ th \/ et ) <-> ( ch \/ ta \/ ze ) ) ) ;
	}

	/*  [20-Apr-1994]  */ 
	proof of _3orbi123d {
		step 1 : wff = theorem orbi12d (hyp 1, hyp 2) |- ( ph -> ( ( ps \/ th ) <-> ( ch \/ ta ) ) ) ;
		step 2 : wff = theorem orbi12d (step 1, hyp 3) |- ( ph -> ( ( ( ps \/ th ) \/ et ) <-> ( ( ch \/ ta ) \/ ze ) ) ) ;
		step 3 : wff = definition df-3or () |- ( ( ps \/ th \/ et ) <-> ( ( ps \/ th ) \/ et ) ) ;
		step 4 : wff = definition df-3or () |- ( ( ch \/ ta \/ ze ) <-> ( ( ch \/ ta ) \/ ze ) ) ;
		step 5 : wff = theorem _3bitr4g (step 2, step 3, step 4) |- ( ph -> ( ( ps \/ th \/ et ) <-> ( ch \/ ta \/ ze ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Deduction joining 3 equivalences to form equivalence of conjunctions.  */
	theorem _3anbi123d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff , var ze : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th <-> ta ) ) ;
		hyp 3 : wff = |- ( ph -> ( et <-> ze ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ th /\ et ) <-> ( ch /\ ta /\ ze ) ) ) ;
	}

	/*  [22-Apr-1994]  */ 
	proof of _3anbi123d {
		step 1 : wff = theorem anbi12d (hyp 1, hyp 2) |- ( ph -> ( ( ps /\ th ) <-> ( ch /\ ta ) ) ) ;
		step 2 : wff = theorem anbi12d (step 1, hyp 3) |- ( ph -> ( ( ( ps /\ th ) /\ et ) <-> ( ( ch /\ ta ) /\ ze ) ) ) ;
		step 3 : wff = definition df-3an () |- ( ( ps /\ th /\ et ) <-> ( ( ps /\ th ) /\ et ) ) ;
		step 4 : wff = definition df-3an () |- ( ( ch /\ ta /\ ze ) <-> ( ( ch /\ ta ) /\ ze ) ) ;
		step 5 : wff = theorem _3bitr4g (step 2, step 3, step 4) |- ( ph -> ( ( ps /\ th /\ et ) <-> ( ch /\ ta /\ ze ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Deduction conjoining and adding a conjunct to equivalences.  */
	theorem _3anbi12d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ th /\ et ) <-> ( ch /\ ta /\ et ) ) ) ;
	}

	/*  [8-Sep-2006]  */ /*  [8-Sep-2006]  */ 
	proof of _3anbi12d {
		step 1 : wff = theorem pm4_2i () |- ( ph -> ( et <-> et ) ) ;
		step 2 : wff = theorem _3anbi123d (hyp 1, hyp 2, step 1) |- ( ph -> ( ( ps /\ th /\ et ) <-> ( ch /\ ta /\ et ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction conjoining and adding a conjunct to equivalences.  */
	theorem _3anbi13d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ et /\ th ) <-> ( ch /\ et /\ ta ) ) ) ;
	}

	/*  [9-Sep-2006]  */ /*  [8-Sep-2006]  */ 
	proof of _3anbi13d {
		step 1 : wff = theorem pm4_2i () |- ( ph -> ( et <-> et ) ) ;
		step 2 : wff = theorem _3anbi123d (hyp 1, step 1, hyp 2) |- ( ph -> ( ( ps /\ et /\ th ) <-> ( ch /\ et /\ ta ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction conjoining and adding a conjunct to equivalences.  */
	theorem _3anbi23d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th <-> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( et /\ ps /\ th ) <-> ( et /\ ch /\ ta ) ) ) ;
	}

	/*  [10-Sep-2006]  */ /*  [8-Sep-2006]  */ 
	proof of _3anbi23d {
		step 1 : wff = theorem pm4_2i () |- ( ph -> ( et <-> et ) ) ;
		step 2 : wff = theorem _3anbi123d (step 1, hyp 1, hyp 2) |- ( ph -> ( ( et /\ ps /\ th ) <-> ( et /\ ch /\ ta ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding conjuncts to an equivalence.  */
	theorem _3anbi1d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ th /\ ta ) <-> ( ch /\ th /\ ta ) ) ) ;
	}

	/*  [9-Sep-2006]  */ /*  [8-Sep-2006]  */ 
	proof of _3anbi1d {
		step 1 : wff = theorem pm4_2i () |- ( ph -> ( th <-> th ) ) ;
		step 2 : wff = theorem _3anbi12d (hyp 1, step 1) |- ( ph -> ( ( ps /\ th /\ ta ) <-> ( ch /\ th /\ ta ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding conjuncts to an equivalence.  */
	theorem _3anbi2d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( th /\ ps /\ ta ) <-> ( th /\ ch /\ ta ) ) ) ;
	}

	/*  [2-Nov-2006]  */ /*  [8-Sep-2006]  */ 
	proof of _3anbi2d {
		step 1 : wff = theorem pm4_2i () |- ( ph -> ( th <-> th ) ) ;
		step 2 : wff = theorem _3anbi12d (step 1, hyp 1) |- ( ph -> ( ( th /\ ps /\ ta ) <-> ( th /\ ch /\ ta ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction adding conjuncts to an equivalence.  */
	theorem _3anbi3d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps <-> ch ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( th /\ ta /\ ps ) <-> ( th /\ ta /\ ch ) ) ) ;
	}

	/*  [11-Sep-2006]  */ /*  [8-Sep-2006]  */ 
	proof of _3anbi3d {
		step 1 : wff = theorem pm4_2i () |- ( ph -> ( th <-> th ) ) ;
		step 2 : wff = theorem _3anbi13d (step 1, hyp 1) |- ( ph -> ( ( th /\ ta /\ ps ) <-> ( th /\ ta /\ ch ) ) ) ;
		qed prop = step 2 ;
	}

	/*  Deduction joining 3 implications to form implication of conjunctions.  */
	theorem _3anim123d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff , var ze : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th -> ta ) ) ;
		hyp 3 : wff = |- ( ph -> ( et -> ze ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps /\ th /\ et ) -> ( ch /\ ta /\ ze ) ) ) ;
	}

	/*  [30-Jun-2005]  */ /*  [24-Feb-2005]  */ 
	proof of _3anim123d {
		step 1 : wff = theorem anim12d (hyp 1, hyp 2) |- ( ph -> ( ( ps /\ th ) -> ( ch /\ ta ) ) ) ;
		step 2 : wff = theorem anim12d (step 1, hyp 3) |- ( ph -> ( ( ( ps /\ th ) /\ et ) -> ( ( ch /\ ta ) /\ ze ) ) ) ;
		step 3 : wff = definition df-3an () |- ( ( ps /\ th /\ et ) <-> ( ( ps /\ th ) /\ et ) ) ;
		step 4 : wff = definition df-3an () |- ( ( ch /\ ta /\ ze ) <-> ( ( ch /\ ta ) /\ ze ) ) ;
		step 5 : wff = theorem _3imtr4g (step 2, step 3, step 4) |- ( ph -> ( ( ps /\ th /\ et ) -> ( ch /\ ta /\ ze ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Deduction joining 3 implications to form implication of disjunctions.  */
	theorem _3orim123d (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff , var ze : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ph -> ( th -> ta ) ) ;
		hyp 3 : wff = |- ( ph -> ( et -> ze ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps \/ th \/ et ) -> ( ch \/ ta \/ ze ) ) ) ;
	}

	/*  [4-Apr-1997]  */ 
	proof of _3orim123d {
		step 1 : wff = theorem orim12d (hyp 1, hyp 2) |- ( ph -> ( ( ps \/ th ) -> ( ch \/ ta ) ) ) ;
		step 2 : wff = theorem orim12d (step 1, hyp 3) |- ( ph -> ( ( ( ps \/ th ) \/ et ) -> ( ( ch \/ ta ) \/ ze ) ) ) ;
		step 3 : wff = definition df-3or () |- ( ( ps \/ th \/ et ) <-> ( ( ps \/ th ) \/ et ) ) ;
		step 4 : wff = definition df-3or () |- ( ( ch \/ ta \/ ze ) <-> ( ( ch \/ ta ) \/ ze ) ) ;
		step 5 : wff = theorem _3imtr4g (step 2, step 3, step 4) |- ( ph -> ( ( ps \/ th \/ et ) -> ( ch \/ ta \/ ze ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Rearrangement of 6 conjuncts.  */
	theorem an6 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		prop : wff = |- ( ( ( ph /\ ps /\ ch ) /\ ( th /\ ta /\ et ) ) <-> ( ( ph /\ th ) /\ ( ps /\ ta ) /\ ( ch /\ et ) ) ) ;
	}

	/*  [13-Mar-1995]  */ 
	proof of an6 {
		step 1 : wff = definition df-3an () |- ( ( ph /\ ps /\ ch ) <-> ( ( ph /\ ps ) /\ ch ) ) ;
		step 2 : wff = definition df-3an () |- ( ( th /\ ta /\ et ) <-> ( ( th /\ ta ) /\ et ) ) ;
		step 3 : wff = theorem anbi12i (step 1, step 2) |- ( ( ( ph /\ ps /\ ch ) /\ ( th /\ ta /\ et ) ) <-> ( ( ( ph /\ ps ) /\ ch ) /\ ( ( th /\ ta ) /\ et ) ) ) ;
		step 4 : wff = theorem an4 () |- ( ( ( ( ph /\ ps ) /\ ch ) /\ ( ( th /\ ta ) /\ et ) ) <-> ( ( ( ph /\ ps ) /\ ( th /\ ta ) ) /\ ( ch /\ et ) ) ) ;
		step 5 : wff = theorem an4 () |- ( ( ( ph /\ ps ) /\ ( th /\ ta ) ) <-> ( ( ph /\ th ) /\ ( ps /\ ta ) ) ) ;
		step 6 : wff = theorem anbi1i (step 5) |- ( ( ( ( ph /\ ps ) /\ ( th /\ ta ) ) /\ ( ch /\ et ) ) <-> ( ( ( ph /\ th ) /\ ( ps /\ ta ) ) /\ ( ch /\ et ) ) ) ;
		step 7 : wff = theorem _3bitr (step 3, step 4, step 6) |- ( ( ( ph /\ ps /\ ch ) /\ ( th /\ ta /\ et ) ) <-> ( ( ( ph /\ th ) /\ ( ps /\ ta ) ) /\ ( ch /\ et ) ) ) ;
		step 8 : wff = definition df-3an () |- ( ( ( ph /\ th ) /\ ( ps /\ ta ) /\ ( ch /\ et ) ) <-> ( ( ( ph /\ th ) /\ ( ps /\ ta ) ) /\ ( ch /\ et ) ) ) ;
		step 9 : wff = theorem bitr4 (step 7, step 8) |- ( ( ( ph /\ ps /\ ch ) /\ ( th /\ ta /\ et ) ) <-> ( ( ph /\ th ) /\ ( ps /\ ta ) /\ ( ch /\ et ) ) ) ;
		qed prop = step 9 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mp3an1 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ps /\ ch ) -> th ) ;
	}

	/*  [21-Nov-1994]  */ 
	proof of mp3an1 {
		step 1 : wff = theorem _3expb (hyp 2) |- ( ( ph /\ ( ps /\ ch ) ) -> th ) ;
		step 2 : wff = theorem mpan (hyp 1, step 1) |- ( ( ps /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mp3an2 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ps ;
		hyp 2 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ch ) -> th ) ;
	}

	/*  [21-Nov-1994]  */ 
	proof of mp3an2 {
		step 1 : wff = theorem _3expa (hyp 2) |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		step 2 : wff = theorem mpanl2 (hyp 1, step 1) |- ( ( ph /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mp3an3 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ch ;
		hyp 2 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> th ) ;
	}

	/*  [21-Nov-1994]  */ 
	proof of mp3an3 {
		step 1 : wff = theorem _3expa (hyp 2) |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		step 2 : wff = theorem mpan2 (hyp 1, step 1) |- ( ( ph /\ ps ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mp3an12 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- ps ;
		hyp 3 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ch -> th ) ;
	}

	/*  [15-Jul-2005]  */ /*  [13-Jul-2005]  */ 
	proof of mp3an12 {
		step 1 : wff = theorem mp3an1 (hyp 1, hyp 3) |- ( ( ps /\ ch ) -> th ) ;
		step 2 : wff = theorem mpan (hyp 2, step 1) |- ( ch -> th ) ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mp3an13 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- ch ;
		hyp 3 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ps -> th ) ;
	}

	/*  [16-Jul-2005]  */ /*  [14-Jul-2005]  */ 
	proof of mp3an13 {
		step 1 : wff = theorem mp3an3 (hyp 2, hyp 3) |- ( ( ph /\ ps ) -> th ) ;
		step 2 : wff = theorem mpan (hyp 1, step 1) |- ( ps -> th ) ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mp3an23 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ps ;
		hyp 2 : wff = |- ch ;
		hyp 3 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ph -> th ) ;
	}

	/*  [16-Jul-2005]  */ /*  [14-Jul-2005]  */ 
	proof of mp3an23 {
		step 1 : wff = theorem mp3an3 (hyp 2, hyp 3) |- ( ( ph /\ ps ) -> th ) ;
		step 2 : wff = theorem mpan2 (hyp 1, step 1) |- ( ph -> th ) ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mp3an1i (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ps ;
		hyp 2 : wff = |- ( ph -> ( ( ps /\ ch /\ th ) -> ta ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ch /\ th ) -> ta ) ) ;
	}

	/*  [9-Jul-2005]  */ /*  [5-Jul-2005]  */ 
	proof of mp3an1i {
		step 1 : wff = theorem com12 (hyp 2) |- ( ( ps /\ ch /\ th ) -> ( ph -> ta ) ) ;
		step 2 : wff = theorem mp3an1 (hyp 1, step 1) |- ( ( ch /\ th ) -> ( ph -> ta ) ) ;
		step 3 : wff = theorem com12 (step 2) |- ( ph -> ( ( ch /\ th ) -> ta ) ) ;
		qed prop = step 3 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mp3anl1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- ( ( ( ph /\ ps /\ ch ) /\ th ) -> ta ) ;
		-----------------
		prop : wff = |- ( ( ( ps /\ ch ) /\ th ) -> ta ) ;
	}

	/*  [25-Feb-2005]  */ /*  [24-Feb-2005]  */ 
	proof of mp3anl1 {
		step 1 : wff = theorem ex (hyp 2) |- ( ( ph /\ ps /\ ch ) -> ( th -> ta ) ) ;
		step 2 : wff = theorem mp3an1 (hyp 1, step 1) |- ( ( ps /\ ch ) -> ( th -> ta ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ( ps /\ ch ) /\ th ) -> ta ) ;
		qed prop = step 3 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mp3anl2 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ps ;
		hyp 2 : wff = |- ( ( ( ph /\ ps /\ ch ) /\ th ) -> ta ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ch ) /\ th ) -> ta ) ;
	}

	/*  [26-Feb-2005]  */ /*  [24-Feb-2005]  */ 
	proof of mp3anl2 {
		step 1 : wff = theorem ex (hyp 2) |- ( ( ph /\ ps /\ ch ) -> ( th -> ta ) ) ;
		step 2 : wff = theorem mp3an2 (hyp 1, step 1) |- ( ( ph /\ ch ) -> ( th -> ta ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ( ph /\ ch ) /\ th ) -> ta ) ;
		qed prop = step 3 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mp3anl3 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ch ;
		hyp 2 : wff = |- ( ( ( ph /\ ps /\ ch ) /\ th ) -> ta ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ps ) /\ th ) -> ta ) ;
	}

	/*  [25-Feb-2005]  */ /*  [24-Feb-2005]  */ 
	proof of mp3anl3 {
		step 1 : wff = theorem ex (hyp 2) |- ( ( ph /\ ps /\ ch ) -> ( th -> ta ) ) ;
		step 2 : wff = theorem mp3an3 (hyp 1, step 1) |- ( ( ph /\ ps ) -> ( th -> ta ) ) ;
		step 3 : wff = theorem imp (step 2) |- ( ( ( ph /\ ps ) /\ th ) -> ta ) ;
		qed prop = step 3 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mp3anr1 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ps ;
		hyp 2 : wff = |- ( ( ph /\ ( ps /\ ch /\ th ) ) -> ta ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ch /\ th ) ) -> ta ) ;
	}

	/*  [6-Nov-2006]  */ /*  [4-Nov-2006]  */ 
	proof of mp3anr1 {
		step 1 : wff = theorem ancoms (hyp 2) |- ( ( ( ps /\ ch /\ th ) /\ ph ) -> ta ) ;
		step 2 : wff = theorem mp3anl1 (hyp 1, step 1) |- ( ( ( ch /\ th ) /\ ph ) -> ta ) ;
		step 3 : wff = theorem ancoms (step 2) |- ( ( ph /\ ( ch /\ th ) ) -> ta ) ;
		qed prop = step 3 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mp3anr2 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ch ;
		hyp 2 : wff = |- ( ( ph /\ ( ps /\ ch /\ th ) ) -> ta ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ th ) ) -> ta ) ;
	}

	/*  [25-Nov-2006]  */ /*  [24-Nov-2006]  */ 
	proof of mp3anr2 {
		step 1 : wff = theorem ancoms (hyp 2) |- ( ( ( ps /\ ch /\ th ) /\ ph ) -> ta ) ;
		step 2 : wff = theorem mp3anl2 (hyp 1, step 1) |- ( ( ( ps /\ th ) /\ ph ) -> ta ) ;
		step 3 : wff = theorem ancoms (step 2) |- ( ( ph /\ ( ps /\ th ) ) -> ta ) ;
		qed prop = step 3 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mp3anr3 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- th ;
		hyp 2 : wff = |- ( ( ph /\ ( ps /\ ch /\ th ) ) -> ta ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ch ) ) -> ta ) ;
	}

	/*  [19-Oct-2007]  */ /*  [19-Oct-2007]  */ 
	proof of mp3anr3 {
		step 1 : wff = theorem ancoms (hyp 2) |- ( ( ( ps /\ ch /\ th ) /\ ph ) -> ta ) ;
		step 2 : wff = theorem mp3anl3 (hyp 1, step 1) |- ( ( ( ps /\ ch ) /\ ph ) -> ta ) ;
		step 3 : wff = theorem ancoms (step 2) |- ( ( ph /\ ( ps /\ ch ) ) -> ta ) ;
		qed prop = step 3 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mp3an (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- ps ;
		hyp 3 : wff = |- ch ;
		hyp 4 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- th ;
	}

	/*  [14-May-1999]  */ 
	proof of mp3an {
		step 1 : wff = theorem mp3an1 (hyp 1, hyp 4) |- ( ( ps /\ ch ) -> th ) ;
		step 2 : wff = theorem mp2an (hyp 2, hyp 3, step 1) |- th ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mpd3an3 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ch ) ;
		hyp 2 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps ) -> th ) ;
	}

	/*  [12-Nov-2007]  */ /*  [8-Nov-2007]  */ 
	proof of mpd3an3 {
		step 1 : wff = theorem _3expa (hyp 2) |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		step 2 : wff = theorem mpdan (hyp 1, step 1) |- ( ( ph /\ ps ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  An inference based on modus ponens.  */
	theorem mpd3an23 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ph -> ch ) ;
		hyp 3 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- ( ph -> th ) ;
	}

	/*  [5-Dec-2006]  */ /*  [4-Dec-2006]  */ 
	proof of mpd3an23 {
		step 1 : wff = theorem id () |- ( ph -> ph ) ;
		step 2 : wff = theorem syl3anc (hyp 3, step 1, hyp 1, hyp 2) |- ( ph -> th ) ;
		qed prop = step 2 ;
	}

	/*  Infer implication from a logical equivalence.  Similar to ~ biimpa .  */
	theorem biimp3a (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ( ph /\ ps ) -> ( ch <-> th ) ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
	}

	/*  [6-Sep-2005]  */ /*  [4-Sep-2005]  */ 
	proof of biimp3a {
		step 1 : wff = theorem biimpa (hyp 1) |- ( ( ( ph /\ ps ) /\ ch ) -> th ) ;
		step 2 : wff = theorem _3impa (step 1) |- ( ( ph /\ ps /\ ch ) -> th ) ;
		qed prop = step 2 ;
	}

	/*  Inference that undistributes a triple conjunction in the antecedent.  */
	theorem _3anandis (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ ps ) /\ ( ph /\ ch ) /\ ( ph /\ th ) ) -> ta ) ;
		-----------------
		prop : wff = |- ( ( ph /\ ( ps /\ ch /\ th ) ) -> ta ) ;
	}

	/*  [21-Apr-2007]  */ /*  [18-Apr-2007]  */ 
	proof of _3anandis {
		step 1 : wff = theorem _3simp1 () |- ( ( ps /\ ch /\ th ) -> ps ) ;
		step 2 : wff = theorem anim2i (step 1) |- ( ( ph /\ ( ps /\ ch /\ th ) ) -> ( ph /\ ps ) ) ;
		step 3 : wff = theorem _3simp2 () |- ( ( ps /\ ch /\ th ) -> ch ) ;
		step 4 : wff = theorem anim2i (step 3) |- ( ( ph /\ ( ps /\ ch /\ th ) ) -> ( ph /\ ch ) ) ;
		step 5 : wff = theorem _3simp3 () |- ( ( ps /\ ch /\ th ) -> th ) ;
		step 6 : wff = theorem anim2i (step 5) |- ( ( ph /\ ( ps /\ ch /\ th ) ) -> ( ph /\ th ) ) ;
		step 7 : wff = theorem syl3anc (hyp 1, step 2, step 4, step 6) |- ( ( ph /\ ( ps /\ ch /\ th ) ) -> ta ) ;
		qed prop = step 7 ;
	}

	/*  Inference that undistributes a triple conjunction in the antecedent.  */
	theorem _3anandirs (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		hyp 1 : wff = |- ( ( ( ph /\ th ) /\ ( ps /\ th ) /\ ( ch /\ th ) ) -> ta ) ;
		-----------------
		prop : wff = |- ( ( ( ph /\ ps /\ ch ) /\ th ) -> ta ) ;
	}

	/*  [18-Apr-2007]  */ /*  [25-Jul-2006]  */ 
	proof of _3anandirs {
		step 1 : wff = theorem _3simp1 () |- ( ( ph /\ ps /\ ch ) -> ph ) ;
		step 2 : wff = theorem anim1i (step 1) |- ( ( ( ph /\ ps /\ ch ) /\ th ) -> ( ph /\ th ) ) ;
		step 3 : wff = theorem _3simp2 () |- ( ( ph /\ ps /\ ch ) -> ps ) ;
		step 4 : wff = theorem anim1i (step 3) |- ( ( ( ph /\ ps /\ ch ) /\ th ) -> ( ps /\ th ) ) ;
		step 5 : wff = theorem _3simp3 () |- ( ( ph /\ ps /\ ch ) -> ch ) ;
		step 6 : wff = theorem anim1i (step 5) |- ( ( ( ph /\ ps /\ ch ) /\ th ) -> ( ch /\ th ) ) ;
		step 7 : wff = theorem syl3anc (hyp 1, step 2, step 4, step 6) |- ( ( ( ph /\ ps /\ ch ) /\ th ) -> ta ) ;
		qed prop = step 7 ;
	}

	/*  Deduction for elimination by cases.  */
	theorem ecase23d (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( ph -> -. ch ) ;
		hyp 2 : wff = |- ( ph -> -. th ) ;
		hyp 3 : wff = |- ( ph -> ( ps \/ ch \/ th ) ) ;
		-----------------
		prop : wff = |- ( ph -> ps ) ;
	}

	/*  [15-Jul-2005]  */ /*  [22-Apr-1994]  */ 
	proof of ecase23d {
		step 1 : wff = theorem jca (hyp 1, hyp 2) |- ( ph -> ( -. ch /\ -. th ) ) ;
		step 2 : wff = theorem ioran () |- ( -. ( ch \/ th ) <-> ( -. ch /\ -. th ) ) ;
		step 3 : wff = theorem sylibr (step 1, step 2) |- ( ph -> -. ( ch \/ th ) ) ;
		step 4 : wff = theorem _3orass () |- ( ( ps \/ ch \/ th ) <-> ( ps \/ ( ch \/ th ) ) ) ;
		step 5 : wff = theorem sylib (hyp 3, step 4) |- ( ph -> ( ps \/ ( ch \/ th ) ) ) ;
		step 6 : wff = theorem ord (step 5) |- ( ph -> ( -. ps -> ( ch \/ th ) ) ) ;
		step 7 : wff = theorem mt3d (step 3, step 6) |- ( ph -> ps ) ;
		qed prop = step 7 ;
	}

	/*  Inference for elimination by cases.  */
	theorem _3ecase (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		hyp 1 : wff = |- ( -. ph -> th ) ;
		hyp 2 : wff = |- ( -. ps -> th ) ;
		hyp 3 : wff = |- ( -. ch -> th ) ;
		hyp 4 : wff = |- ( ( ph /\ ps /\ ch ) -> th ) ;
		-----------------
		prop : wff = |- th ;
	}

	/*  [19-Jul-2005]  */ /*  [13-Jul-2005]  */ 
	proof of _3ecase {
		step 1 : wff = theorem _3exp (hyp 4) |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		step 2 : wff = theorem a1d (hyp 1) |- ( -. ph -> ( ch -> th ) ) ;
		step 3 : wff = theorem a1d (step 2) |- ( -. ph -> ( ps -> ( ch -> th ) ) ) ;
		step 4 : wff = theorem pm2_61i (step 1, step 3) |- ( ps -> ( ch -> th ) ) ;
		step 5 : wff = theorem pm2_61nii (step 4, hyp 2, hyp 3) |- th ;
		qed prop = step 5 ;
	}

	/* 
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	      Other axiomatizations of classical propositional calculus
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	 */
	/*  Carew Meredith's sole axiom for propositional calculus.  This amazing
	     formula is thought to be the shortest possible single axiom for
	     propositional calculus with inference rule ~ ax-mp , where negation and
	     implication are primitive.  Here we prove Meredith's axiom from ~ ax-1 ,
	     ~ ax-2 , and ~ ax-3 .  Then from it we derive the Lukasiewicz axioms
	     ~ luk-1 , ~ luk-2 , and ~ luk-3 .  Using these we finally re-derive our
	     axioms as ~ ax1 , ~ ax2 , and ~ ax3 , thus proving the equivalence of
	     all three systems.  C. A. Meredith, "Single Axioms for the Systems
	     (C,N), (C,O) and (A,N) of the Two-Valued Propositional Calculus," _The
	     Journal of Computing Systems_ vol. 3 (1953), pp. 155-164.  Meredith
	     claimed to be close to a proof that this axiom is the shortest possible,
	     but the proof was apparently never completed.
	
	     An obscure Irish lecturer, Meredith (1904-1976) became enamored with
	     logic somewhat late in life after attending talks by Lukasiewicz and
	     produced many remarkable results such as this axiom.  From his obituary:
	     "He did logic whenever time and opportunity presented themselves, and he
	     did it on whatever materials came to hand:  in a pub, his favored pint
	     of porter within reach, he would use the inside of cigarette packs to
	     write proofs for logical colleagues."  */
	theorem meredith (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		prop : wff = |- ( ( ( ( ( ph -> ps ) -> ( -. ch -> -. th ) ) -> ch ) -> ta ) -> ( ( ta -> ph ) -> ( th -> ph ) ) ) ;
	}

	/*  [14-Dec-2002]  */ 
	proof of meredith {
		step 1 : wff = axiom ax-3 () |- ( ( -. ch -> -. ( -. ch -> ( -. ph -> -. th ) ) ) -> ( ( -. ch -> ( -. ph -> -. th ) ) -> ch ) ) ;
		step 2 : wff = theorem pm2_21 () |- ( -. ph -> ( ph -> ps ) ) ;
		step 3 : wff = theorem imim1i (step 2) |- ( ( ( ph -> ps ) -> ( -. ch -> -. th ) ) -> ( -. ph -> ( -. ch -> -. th ) ) ) ;
		step 4 : wff = theorem com23 (step 3) |- ( ( ( ph -> ps ) -> ( -. ch -> -. th ) ) -> ( -. ch -> ( -. ph -> -. th ) ) ) ;
		step 5 : wff = theorem syl5 (step 1, step 4) |- ( ( -. ch -> -. ( -. ch -> ( -. ph -> -. th ) ) ) -> ( ( ( ph -> ps ) -> ( -. ch -> -. th ) ) -> ch ) ) ;
		step 6 : wff = theorem imim1i (step 5) |- ( ( ( ( ( ph -> ps ) -> ( -. ch -> -. th ) ) -> ch ) -> ta ) -> ( ( -. ch -> -. ( -. ch -> ( -. ph -> -. th ) ) ) -> ta ) ) ;
		step 7 : wff = theorem con3d (step 6) |- ( ( ( ( ( ph -> ps ) -> ( -. ch -> -. th ) ) -> ch ) -> ta ) -> ( -. ta -> -. ( -. ch -> -. ( -. ch -> ( -. ph -> -. th ) ) ) ) ) ;
		step 8 : wff = theorem pm2_27 () |- ( -. ch -> ( ( -. ch -> ( -. ph -> -. th ) ) -> ( -. ph -> -. th ) ) ) ;
		step 9 : wff = theorem impi (step 8) |- ( -. ( -. ch -> -. ( -. ch -> ( -. ph -> -. th ) ) ) -> ( -. ph -> -. th ) ) ;
		step 10 : wff = theorem com12 (step 9) |- ( -. ph -> ( -. ( -. ch -> -. ( -. ch -> ( -. ph -> -. th ) ) ) -> -. th ) ) ;
		step 11 : wff = theorem imim2d (step 10) |- ( -. ph -> ( ( -. ta -> -. ( -. ch -> -. ( -. ch -> ( -. ph -> -. th ) ) ) ) -> ( -. ta -> -. th ) ) ) ;
		step 12 : wff = theorem com12 (step 11) |- ( ( -. ta -> -. ( -. ch -> -. ( -. ch -> ( -. ph -> -. th ) ) ) ) -> ( -. ph -> ( -. ta -> -. th ) ) ) ;
		step 13 : wff = theorem a2d (step 12) |- ( ( -. ta -> -. ( -. ch -> -. ( -. ch -> ( -. ph -> -. th ) ) ) ) -> ( ( -. ph -> -. ta ) -> ( -. ph -> -. th ) ) ) ;
		step 14 : wff = theorem con3 () |- ( ( ta -> ph ) -> ( -. ph -> -. ta ) ) ;
		step 15 : wff = theorem syl5 (step 13, step 14) |- ( ( -. ta -> -. ( -. ch -> -. ( -. ch -> ( -. ph -> -. th ) ) ) ) -> ( ( ta -> ph ) -> ( -. ph -> -. th ) ) ) ;
		step 16 : wff = axiom ax-3 () |- ( ( -. ph -> -. th ) -> ( th -> ph ) ) ;
		step 17 : wff = theorem syl6 (step 15, step 16) |- ( ( -. ta -> -. ( -. ch -> -. ( -. ch -> ( -. ph -> -. th ) ) ) ) -> ( ( ta -> ph ) -> ( th -> ph ) ) ) ;
		step 18 : wff = theorem syl (step 7, step 17) |- ( ( ( ( ( ph -> ps ) -> ( -. ch -> -. th ) ) -> ch ) -> ta ) -> ( ( ta -> ph ) -> ( th -> ph ) ) ) ;
		qed prop = step 18 ;
	}

	/*  Step 3 of Meredith's proof of Lukasiewicz axioms from his sole axiom.
	     (The step numbers refer to Meredith's original paper.)  */
	theorem merlem1 (var ph : wff , var ps : wff , var ch : wff , var ta : wff ) 
	{
		prop : wff = |- ( ( ( ch -> ( -. ph -> ps ) ) -> ta ) -> ( ph -> ta ) ) ;
	}

	/*  [14-Dec-2002]  */ 
	proof of merlem1 {
		step 1 : wff = theorem meredith () |- ( ( ( ( ( -. ph -> ps ) -> ( -. ( -. ta -> -. ch ) -> -. -. ( -. ph -> ps ) ) ) -> ( -. ta -> -. ch ) ) -> ta ) -> ( ( ta -> -. ph ) -> ( -. ( -. ph -> ps ) -> -. ph ) ) ) ;
		step 2 : wff = theorem meredith () |- ( ( ( ( ( ( -. ph -> ps ) -> ( -. ( -. ta -> -. ch ) -> -. -. ( -. ph -> ps ) ) ) -> ( -. ta -> -. ch ) ) -> ta ) -> ( ( ta -> -. ph ) -> ( -. ( -. ph -> ps ) -> -. ph ) ) ) -> ( ( ( ( ta -> -. ph ) -> ( -. ( -. ph -> ps ) -> -. ph ) ) -> ( -. ph -> ps ) ) -> ( ch -> ( -. ph -> ps ) ) ) ) ;
		step 3 : wff = axiom ax-mp (step 1, step 2) |- ( ( ( ( ta -> -. ph ) -> ( -. ( -. ph -> ps ) -> -. ph ) ) -> ( -. ph -> ps ) ) -> ( ch -> ( -. ph -> ps ) ) ) ;
		step 4 : wff = theorem meredith () |- ( ( ( ( ( ta -> -. ph ) -> ( -. ( -. ph -> ps ) -> -. ph ) ) -> ( -. ph -> ps ) ) -> ( ch -> ( -. ph -> ps ) ) ) -> ( ( ( ch -> ( -. ph -> ps ) ) -> ta ) -> ( ph -> ta ) ) ) ;
		step 5 : wff = axiom ax-mp (step 3, step 4) |- ( ( ( ch -> ( -. ph -> ps ) ) -> ta ) -> ( ph -> ta ) ) ;
		qed prop = step 5 ;
	}

	/*  Step 4 of Meredith's proof of Lukasiewicz axioms from his sole axiom.  */
	theorem merlem2 (var ph : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ph ) -> ch ) -> ( th -> ch ) ) ;
	}

	/*  [14-Dec-2002]  */ 
	proof of merlem2 {
		step 1 : wff = theorem merlem1 () |- ( ( ( ( ch -> ch ) -> ( -. ph -> -. th ) ) -> ph ) -> ( ph -> ph ) ) ;
		step 2 : wff = theorem meredith () |- ( ( ( ( ( ch -> ch ) -> ( -. ph -> -. th ) ) -> ph ) -> ( ph -> ph ) ) -> ( ( ( ph -> ph ) -> ch ) -> ( th -> ch ) ) ) ;
		step 3 : wff = axiom ax-mp (step 1, step 2) |- ( ( ( ph -> ph ) -> ch ) -> ( th -> ch ) ) ;
		qed prop = step 3 ;
	}

	/*  Step 7 of Meredith's proof of Lukasiewicz axioms from his sole axiom.  */
	theorem merlem3 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ( ps -> ch ) -> ph ) -> ( ch -> ph ) ) ;
	}

	/*  [14-Dec-2002]  */ 
	proof of merlem3 {
		step 1 : wff = theorem merlem2 () |- ( ( ( -. ch -> -. ch ) -> ( -. ch -> -. ch ) ) -> ( ( ph -> ph ) -> ( -. ch -> -. ch ) ) ) ;
		step 2 : wff = theorem merlem2 () |- ( ( ( ( -. ch -> -. ch ) -> ( -. ch -> -. ch ) ) -> ( ( ph -> ph ) -> ( -. ch -> -. ch ) ) ) -> ( ( ( ( ch -> ph ) -> ( -. ps -> -. ps ) ) -> ps ) -> ( ( ph -> ph ) -> ( -. ch -> -. ch ) ) ) ) ;
		step 3 : wff = axiom ax-mp (step 1, step 2) |- ( ( ( ( ch -> ph ) -> ( -. ps -> -. ps ) ) -> ps ) -> ( ( ph -> ph ) -> ( -. ch -> -. ch ) ) ) ;
		step 4 : wff = theorem meredith () |- ( ( ( ( ( ch -> ph ) -> ( -. ps -> -. ps ) ) -> ps ) -> ( ( ph -> ph ) -> ( -. ch -> -. ch ) ) ) -> ( ( ( ( ph -> ph ) -> ( -. ch -> -. ch ) ) -> ch ) -> ( ps -> ch ) ) ) ;
		step 5 : wff = axiom ax-mp (step 3, step 4) |- ( ( ( ( ph -> ph ) -> ( -. ch -> -. ch ) ) -> ch ) -> ( ps -> ch ) ) ;
		step 6 : wff = theorem meredith () |- ( ( ( ( ( ph -> ph ) -> ( -. ch -> -. ch ) ) -> ch ) -> ( ps -> ch ) ) -> ( ( ( ps -> ch ) -> ph ) -> ( ch -> ph ) ) ) ;
		step 7 : wff = axiom ax-mp (step 5, step 6) |- ( ( ( ps -> ch ) -> ph ) -> ( ch -> ph ) ) ;
		qed prop = step 7 ;
	}

	/*  Step 8 of Meredith's proof of Lukasiewicz axioms from his sole axiom.  */
	theorem merlem4 (var ph : wff , var th : wff , var ta : wff ) 
	{
		prop : wff = |- ( ta -> ( ( ta -> ph ) -> ( th -> ph ) ) ) ;
	}

	/*  [14-Dec-2002]  */ 
	proof of merlem4 {
		step 1 : wff = theorem meredith () |- ( ( ( ( ( ph -> ph ) -> ( -. th -> -. th ) ) -> th ) -> ta ) -> ( ( ta -> ph ) -> ( th -> ph ) ) ) ;
		step 2 : wff = theorem merlem3 () |- ( ( ( ( ( ( ph -> ph ) -> ( -. th -> -. th ) ) -> th ) -> ta ) -> ( ( ta -> ph ) -> ( th -> ph ) ) ) -> ( ta -> ( ( ta -> ph ) -> ( th -> ph ) ) ) ) ;
		step 3 : wff = axiom ax-mp (step 1, step 2) |- ( ta -> ( ( ta -> ph ) -> ( th -> ph ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Step 11 of Meredith's proof of Lukasiewicz axioms from his sole axiom.  */
	theorem merlem5 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( -. -. ph -> ps ) ) ;
	}

	/*  [14-Dec-2002]  */ 
	proof of merlem5 {
		step 1 : wff = theorem meredith () |- ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. ps ) ) -> ps ) -> ps ) -> ( ( ps -> ps ) -> ( ps -> ps ) ) ) ;
		step 2 : wff = theorem meredith () |- ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. -. -. ph ) ) -> ps ) -> ph ) -> ( ( ph -> ps ) -> ( -. -. ph -> ps ) ) ) ;
		step 3 : wff = theorem merlem1 () |- ( ( ( ( ph -> ps ) -> ( -. -. ph -> ps ) ) -> -. ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. ps ) ) -> ps ) -> ps ) -> ( ( ps -> ps ) -> ( ps -> ps ) ) ) ) -> ( -. ph -> -. ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. ps ) ) -> ps ) -> ps ) -> ( ( ps -> ps ) -> ( ps -> ps ) ) ) ) ) ;
		step 4 : wff = theorem merlem4 () |- ( ( ( ( ( ph -> ps ) -> ( -. -. ph -> ps ) ) -> -. ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. ps ) ) -> ps ) -> ps ) -> ( ( ps -> ps ) -> ( ps -> ps ) ) ) ) -> ( -. ph -> -. ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. ps ) ) -> ps ) -> ps ) -> ( ( ps -> ps ) -> ( ps -> ps ) ) ) ) ) -> ( ( ( ( ( ( ph -> ps ) -> ( -. -. ph -> ps ) ) -> -. ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. ps ) ) -> ps ) -> ps ) -> ( ( ps -> ps ) -> ( ps -> ps ) ) ) ) -> ( -. ph -> -. ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. ps ) ) -> ps ) -> ps ) -> ( ( ps -> ps ) -> ( ps -> ps ) ) ) ) ) -> ph ) -> ( ( ( ( ps -> ps ) -> ( -. ps -> -. -. -. ph ) ) -> ps ) -> ph ) ) ) ;
		step 5 : wff = axiom ax-mp (step 3, step 4) |- ( ( ( ( ( ( ph -> ps ) -> ( -. -. ph -> ps ) ) -> -. ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. ps ) ) -> ps ) -> ps ) -> ( ( ps -> ps ) -> ( ps -> ps ) ) ) ) -> ( -. ph -> -. ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. ps ) ) -> ps ) -> ps ) -> ( ( ps -> ps ) -> ( ps -> ps ) ) ) ) ) -> ph ) -> ( ( ( ( ps -> ps ) -> ( -. ps -> -. -. -. ph ) ) -> ps ) -> ph ) ) ;
		step 6 : wff = theorem meredith () |- ( ( ( ( ( ( ( ph -> ps ) -> ( -. -. ph -> ps ) ) -> -. ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. ps ) ) -> ps ) -> ps ) -> ( ( ps -> ps ) -> ( ps -> ps ) ) ) ) -> ( -. ph -> -. ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. ps ) ) -> ps ) -> ps ) -> ( ( ps -> ps ) -> ( ps -> ps ) ) ) ) ) -> ph ) -> ( ( ( ( ps -> ps ) -> ( -. ps -> -. -. -. ph ) ) -> ps ) -> ph ) ) -> ( ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. -. -. ph ) ) -> ps ) -> ph ) -> ( ( ph -> ps ) -> ( -. -. ph -> ps ) ) ) -> ( ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. ps ) ) -> ps ) -> ps ) -> ( ( ps -> ps ) -> ( ps -> ps ) ) ) -> ( ( ph -> ps ) -> ( -. -. ph -> ps ) ) ) ) ) ;
		step 7 : wff = axiom ax-mp (step 5, step 6) |- ( ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. -. -. ph ) ) -> ps ) -> ph ) -> ( ( ph -> ps ) -> ( -. -. ph -> ps ) ) ) -> ( ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. ps ) ) -> ps ) -> ps ) -> ( ( ps -> ps ) -> ( ps -> ps ) ) ) -> ( ( ph -> ps ) -> ( -. -. ph -> ps ) ) ) ) ;
		step 8 : wff = axiom ax-mp (step 2, step 7) |- ( ( ( ( ( ( ps -> ps ) -> ( -. ps -> -. ps ) ) -> ps ) -> ps ) -> ( ( ps -> ps ) -> ( ps -> ps ) ) ) -> ( ( ph -> ps ) -> ( -. -. ph -> ps ) ) ) ;
		step 9 : wff = axiom ax-mp (step 1, step 8) |- ( ( ph -> ps ) -> ( -. -. ph -> ps ) ) ;
		qed prop = step 9 ;
	}

	/*  Step 12 of Meredith's proof of Lukasiewicz axioms from his sole axiom.  */
	theorem merlem6 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ch -> ( ( ( ps -> ch ) -> ph ) -> ( th -> ph ) ) ) ;
	}

	/*  [14-Dec-2002]  */ 
	proof of merlem6 {
		step 1 : wff = theorem merlem4 () |- ( ( ps -> ch ) -> ( ( ( ps -> ch ) -> ph ) -> ( th -> ph ) ) ) ;
		step 2 : wff = theorem merlem3 () |- ( ( ( ps -> ch ) -> ( ( ( ps -> ch ) -> ph ) -> ( th -> ph ) ) ) -> ( ch -> ( ( ( ps -> ch ) -> ph ) -> ( th -> ph ) ) ) ) ;
		step 3 : wff = axiom ax-mp (step 1, step 2) |- ( ch -> ( ( ( ps -> ch ) -> ph ) -> ( th -> ph ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Between steps 14 and 15 of Meredith's proof of Lukasiewicz axioms from his
	     sole axiom.  */
	theorem merlem7 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		prop : wff = |- ( ph -> ( ( ( ps -> ch ) -> th ) -> ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) ) ) ;
	}

	/*  [22-Dec-2002]  */ 
	proof of merlem7 {
		step 1 : wff = theorem merlem4 () |- ( ( ps -> ch ) -> ( ( ( ps -> ch ) -> th ) -> ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) ) ) ;
		step 2 : wff = theorem merlem6 () |- ( ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) -> ( ( ( ( ( ps -> ch ) -> th ) -> ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) ) -> -. ph ) -> ( -. ch -> -. ph ) ) ) ;
		step 3 : wff = theorem meredith () |- ( ( ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) -> ( ( ( ( ( ps -> ch ) -> th ) -> ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) ) -> -. ph ) -> ( -. ch -> -. ph ) ) ) -> ( ( ( ( ( ( ( ps -> ch ) -> th ) -> ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) ) -> -. ph ) -> ( -. ch -> -. ph ) ) -> ch ) -> ( ps -> ch ) ) ) ;
		step 4 : wff = axiom ax-mp (step 2, step 3) |- ( ( ( ( ( ( ( ps -> ch ) -> th ) -> ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) ) -> -. ph ) -> ( -. ch -> -. ph ) ) -> ch ) -> ( ps -> ch ) ) ;
		step 5 : wff = theorem meredith () |- ( ( ( ( ( ( ( ( ps -> ch ) -> th ) -> ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) ) -> -. ph ) -> ( -. ch -> -. ph ) ) -> ch ) -> ( ps -> ch ) ) -> ( ( ( ps -> ch ) -> ( ( ( ps -> ch ) -> th ) -> ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) ) ) -> ( ph -> ( ( ( ps -> ch ) -> th ) -> ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) ) ) ) ) ;
		step 6 : wff = axiom ax-mp (step 4, step 5) |- ( ( ( ps -> ch ) -> ( ( ( ps -> ch ) -> th ) -> ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) ) ) -> ( ph -> ( ( ( ps -> ch ) -> th ) -> ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) ) ) ) ;
		step 7 : wff = axiom ax-mp (step 1, step 6) |- ( ph -> ( ( ( ps -> ch ) -> th ) -> ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) ) ) ;
		qed prop = step 7 ;
	}

	/*  Step 15 of Meredith's proof of Lukasiewicz axioms from his sole axiom.  */
	theorem merlem8 (var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		prop : wff = |- ( ( ( ps -> ch ) -> th ) -> ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) ) ;
	}

	/*  [22-Dec-2002]  */ 
	proof of merlem8 {
		var ph : wff ;
		step 1 : wff = theorem meredith () |- ( ( ( ( ( ph -> ph ) -> ( -. ph -> -. ph ) ) -> ph ) -> ph ) -> ( ( ph -> ph ) -> ( ph -> ph ) ) ) ;
		step 2 : wff = theorem merlem7 () |- ( ( ( ( ( ( ph -> ph ) -> ( -. ph -> -. ph ) ) -> ph ) -> ph ) -> ( ( ph -> ph ) -> ( ph -> ph ) ) ) -> ( ( ( ps -> ch ) -> th ) -> ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) ) ) ;
		step 3 : wff = axiom ax-mp (step 1, step 2) |- ( ( ( ps -> ch ) -> th ) -> ( ( ( ch -> ta ) -> ( -. th -> -. ps ) ) -> th ) ) ;
		qed prop = step 3 ;
	}

	/*  Step 18 of Meredith's proof of Lukasiewicz axioms from his sole
	       axiom.  */
	theorem merlem9 (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff , var et : wff ) 
	{
		prop : wff = |- ( ( ( ph -> ps ) -> ( ch -> ( th -> ( ps -> ta ) ) ) ) -> ( et -> ( ch -> ( th -> ( ps -> ta ) ) ) ) ) ;
	}

	/*  [22-Dec-2002]  */ 
	proof of merlem9 {
		step 1 : wff = theorem merlem6 () |- ( ( th -> ( ps -> ta ) ) -> ( ( ( ch -> ( th -> ( ps -> ta ) ) ) -> -. et ) -> ( -. ps -> -. et ) ) ) ;
		step 2 : wff = theorem merlem8 () |- ( ( ( th -> ( ps -> ta ) ) -> ( ( ( ch -> ( th -> ( ps -> ta ) ) ) -> -. et ) -> ( -. ps -> -. et ) ) ) -> ( ( ( ( ps -> ta ) -> ( -. ( -. ( ( ( ch -> ( th -> ( ps -> ta ) ) ) -> -. et ) -> ( -. ps -> -. et ) ) -> -. th ) -> -. ph ) ) -> ( -. ( ( ( ch -> ( th -> ( ps -> ta ) ) ) -> -. et ) -> ( -. ps -> -. et ) ) -> -. th ) ) -> ( ( ( ch -> ( th -> ( ps -> ta ) ) ) -> -. et ) -> ( -. ps -> -. et ) ) ) ) ;
		step 3 : wff = axiom ax-mp (step 1, step 2) |- ( ( ( ( ps -> ta ) -> ( -. ( -. ( ( ( ch -> ( th -> ( ps -> ta ) ) ) -> -. et ) -> ( -. ps -> -. et ) ) -> -. th ) -> -. ph ) ) -> ( -. ( ( ( ch -> ( th -> ( ps -> ta ) ) ) -> -. et ) -> ( -. ps -> -. et ) ) -> -. th ) ) -> ( ( ( ch -> ( th -> ( ps -> ta ) ) ) -> -. et ) -> ( -. ps -> -. et ) ) ) ;
		step 4 : wff = theorem meredith () |- ( ( ( ( ( ps -> ta ) -> ( -. ( -. ( ( ( ch -> ( th -> ( ps -> ta ) ) ) -> -. et ) -> ( -. ps -> -. et ) ) -> -. th ) -> -. ph ) ) -> ( -. ( ( ( ch -> ( th -> ( ps -> ta ) ) ) -> -. et ) -> ( -. ps -> -. et ) ) -> -. th ) ) -> ( ( ( ch -> ( th -> ( ps -> ta ) ) ) -> -. et ) -> ( -. ps -> -. et ) ) ) -> ( ( ( ( ( ch -> ( th -> ( ps -> ta ) ) ) -> -. et ) -> ( -. ps -> -. et ) ) -> ps ) -> ( ph -> ps ) ) ) ;
		step 5 : wff = axiom ax-mp (step 3, step 4) |- ( ( ( ( ( ch -> ( th -> ( ps -> ta ) ) ) -> -. et ) -> ( -. ps -> -. et ) ) -> ps ) -> ( ph -> ps ) ) ;
		step 6 : wff = theorem meredith () |- ( ( ( ( ( ( ch -> ( th -> ( ps -> ta ) ) ) -> -. et ) -> ( -. ps -> -. et ) ) -> ps ) -> ( ph -> ps ) ) -> ( ( ( ph -> ps ) -> ( ch -> ( th -> ( ps -> ta ) ) ) ) -> ( et -> ( ch -> ( th -> ( ps -> ta ) ) ) ) ) ) ;
		step 7 : wff = axiom ax-mp (step 5, step 6) |- ( ( ( ph -> ps ) -> ( ch -> ( th -> ( ps -> ta ) ) ) ) -> ( et -> ( ch -> ( th -> ( ps -> ta ) ) ) ) ) ;
		qed prop = step 7 ;
	}

	/*  Step 19 of Meredith's proof of Lukasiewicz axioms from his sole axiom.  */
	theorem merlem10 (var ph : wff , var ps : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ph -> ps ) ) -> ( th -> ( ph -> ps ) ) ) ;
	}

	/*  [14-Dec-2002]  */ 
	proof of merlem10 {
		step 1 : wff = theorem meredith () |- ( ( ( ( ( ph -> ph ) -> ( -. ph -> -. ph ) ) -> ph ) -> ph ) -> ( ( ph -> ph ) -> ( ph -> ph ) ) ) ;
		step 2 : wff = theorem meredith () |- ( ( ( ( ( ( ph -> ps ) -> ph ) -> ( -. ph -> -. th ) ) -> ph ) -> ph ) -> ( ( ph -> ( ph -> ps ) ) -> ( th -> ( ph -> ps ) ) ) ) ;
		step 3 : wff = theorem merlem9 () |- ( ( ( ( ( ( ( ph -> ps ) -> ph ) -> ( -. ph -> -. th ) ) -> ph ) -> ph ) -> ( ( ph -> ( ph -> ps ) ) -> ( th -> ( ph -> ps ) ) ) ) -> ( ( ( ( ( ( ph -> ph ) -> ( -. ph -> -. ph ) ) -> ph ) -> ph ) -> ( ( ph -> ph ) -> ( ph -> ph ) ) ) -> ( ( ph -> ( ph -> ps ) ) -> ( th -> ( ph -> ps ) ) ) ) ) ;
		step 4 : wff = axiom ax-mp (step 2, step 3) |- ( ( ( ( ( ( ph -> ph ) -> ( -. ph -> -. ph ) ) -> ph ) -> ph ) -> ( ( ph -> ph ) -> ( ph -> ph ) ) ) -> ( ( ph -> ( ph -> ps ) ) -> ( th -> ( ph -> ps ) ) ) ) ;
		step 5 : wff = axiom ax-mp (step 1, step 4) |- ( ( ph -> ( ph -> ps ) ) -> ( th -> ( ph -> ps ) ) ) ;
		qed prop = step 5 ;
	}

	/*  Step 20 of Meredith's proof of Lukasiewicz axioms from his sole axiom.  */
	theorem merlem11 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ph -> ps ) ) -> ( ph -> ps ) ) ;
	}

	/*  [14-Dec-2002]  */ 
	proof of merlem11 {
		step 1 : wff = theorem meredith () |- ( ( ( ( ( ph -> ph ) -> ( -. ph -> -. ph ) ) -> ph ) -> ph ) -> ( ( ph -> ph ) -> ( ph -> ph ) ) ) ;
		step 2 : wff = theorem merlem10 () |- ( ( ph -> ( ph -> ps ) ) -> ( ( ph -> ( ph -> ps ) ) -> ( ph -> ps ) ) ) ;
		step 3 : wff = theorem merlem10 () |- ( ( ( ph -> ( ph -> ps ) ) -> ( ( ph -> ( ph -> ps ) ) -> ( ph -> ps ) ) ) -> ( ( ( ( ( ( ph -> ph ) -> ( -. ph -> -. ph ) ) -> ph ) -> ph ) -> ( ( ph -> ph ) -> ( ph -> ph ) ) ) -> ( ( ph -> ( ph -> ps ) ) -> ( ph -> ps ) ) ) ) ;
		step 4 : wff = axiom ax-mp (step 2, step 3) |- ( ( ( ( ( ( ph -> ph ) -> ( -. ph -> -. ph ) ) -> ph ) -> ph ) -> ( ( ph -> ph ) -> ( ph -> ph ) ) ) -> ( ( ph -> ( ph -> ps ) ) -> ( ph -> ps ) ) ) ;
		step 5 : wff = axiom ax-mp (step 1, step 4) |- ( ( ph -> ( ph -> ps ) ) -> ( ph -> ps ) ) ;
		qed prop = step 5 ;
	}

	/*  Step 28 of Meredith's proof of Lukasiewicz axioms from his sole axiom.  */
	theorem merlem12 (var ph : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ( th -> ( -. -. ch -> ch ) ) -> ph ) -> ph ) ;
	}

	/*  [14-Dec-2002]  */ 
	proof of merlem12 {
		step 1 : wff = theorem merlem5 () |- ( ( ch -> ch ) -> ( -. -. ch -> ch ) ) ;
		step 2 : wff = theorem merlem2 () |- ( ( ( ch -> ch ) -> ( -. -. ch -> ch ) ) -> ( th -> ( -. -. ch -> ch ) ) ) ;
		step 3 : wff = axiom ax-mp (step 1, step 2) |- ( th -> ( -. -. ch -> ch ) ) ;
		step 4 : wff = theorem merlem4 () |- ( ( th -> ( -. -. ch -> ch ) ) -> ( ( ( th -> ( -. -. ch -> ch ) ) -> ph ) -> ( ( ( th -> ( -. -. ch -> ch ) ) -> ph ) -> ph ) ) ) ;
		step 5 : wff = axiom ax-mp (step 3, step 4) |- ( ( ( th -> ( -. -. ch -> ch ) ) -> ph ) -> ( ( ( th -> ( -. -. ch -> ch ) ) -> ph ) -> ph ) ) ;
		step 6 : wff = theorem merlem11 () |- ( ( ( ( th -> ( -. -. ch -> ch ) ) -> ph ) -> ( ( ( th -> ( -. -. ch -> ch ) ) -> ph ) -> ph ) ) -> ( ( ( th -> ( -. -. ch -> ch ) ) -> ph ) -> ph ) ) ;
		step 7 : wff = axiom ax-mp (step 5, step 6) |- ( ( ( th -> ( -. -. ch -> ch ) ) -> ph ) -> ph ) ;
		qed prop = step 7 ;
	}

	/*  Step 35 of Meredith's proof of Lukasiewicz axioms from his sole axiom.  */
	theorem merlem13 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) -> ps ) ) ;
	}

	/*  [14-Dec-2002]  */ 
	proof of merlem13 {
		step 1 : wff = theorem merlem12 () |- ( ( ( th -> ( -. -. ch -> ch ) ) -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) ;
		step 2 : wff = theorem merlem12 () |- ( ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) -> -. -. ph ) ;
		step 3 : wff = theorem merlem5 () |- ( ( ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) -> -. -. ph ) -> ( -. -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) -> -. -. ph ) ) ;
		step 4 : wff = axiom ax-mp (step 2, step 3) |- ( -. -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) -> -. -. ph ) ;
		step 5 : wff = theorem merlem6 () |- ( ( -. -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) -> -. -. ph ) -> ( ( ( ( -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) -> ps ) -> ( -. -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) -> -. -. ph ) ) -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) -> ( ( th -> ( -. -. ch -> ch ) ) -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) ) ) ;
		step 6 : wff = axiom ax-mp (step 4, step 5) |- ( ( ( ( -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) -> ps ) -> ( -. -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) -> -. -. ph ) ) -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) -> ( ( th -> ( -. -. ch -> ch ) ) -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) ) ;
		step 7 : wff = theorem meredith () |- ( ( ( ( ( -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) -> ps ) -> ( -. -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) -> -. -. ph ) ) -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) -> ( ( th -> ( -. -. ch -> ch ) ) -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) ) -> ( ( ( ( th -> ( -. -. ch -> ch ) ) -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) -> ( -. ph -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) ) ) ;
		step 8 : wff = axiom ax-mp (step 6, step 7) |- ( ( ( ( th -> ( -. -. ch -> ch ) ) -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) -> ( -. ph -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) ) ;
		step 9 : wff = axiom ax-mp (step 1, step 8) |- ( -. ph -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) ;
		step 10 : wff = theorem merlem6 () |- ( ( -. ph -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) -> ( ( ( ( ps -> ps ) -> ( -. ph -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) ) -> ph ) -> ( ( ( ( ps -> ps ) -> ( -. ph -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) ) -> ph ) -> ph ) ) ) ;
		step 11 : wff = axiom ax-mp (step 9, step 10) |- ( ( ( ( ps -> ps ) -> ( -. ph -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) ) -> ph ) -> ( ( ( ( ps -> ps ) -> ( -. ph -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) ) -> ph ) -> ph ) ) ;
		step 12 : wff = theorem merlem11 () |- ( ( ( ( ( ps -> ps ) -> ( -. ph -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) ) -> ph ) -> ( ( ( ( ps -> ps ) -> ( -. ph -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) ) -> ph ) -> ph ) ) -> ( ( ( ( ps -> ps ) -> ( -. ph -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) ) -> ph ) -> ph ) ) ;
		step 13 : wff = axiom ax-mp (step 11, step 12) |- ( ( ( ( ps -> ps ) -> ( -. ph -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) ) -> ph ) -> ph ) ;
		step 14 : wff = theorem meredith () |- ( ( ( ( ( ps -> ps ) -> ( -. ph -> -. ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) ) ) -> ph ) -> ph ) -> ( ( ph -> ps ) -> ( ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) -> ps ) ) ) ;
		step 15 : wff = axiom ax-mp (step 13, step 14) |- ( ( ph -> ps ) -> ( ( ( th -> ( -. -. ch -> ch ) ) -> -. -. ph ) -> ps ) ) ;
		qed prop = step 15 ;
	}

	/*  1 of 3 axioms for propositional calculus due to Lukasiewicz, derived from
	     Meredith's sole axiom.  */
	theorem luk-1 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( ps -> ch ) -> ( ph -> ch ) ) ) ;
	}

	/*  [14-Dec-2002]  */ 
	proof of luk-1 {
		step 1 : wff = theorem meredith () |- ( ( ( ( ( ch -> ch ) -> ( -. -. -. ph -> -. ph ) ) -> -. -. ph ) -> ps ) -> ( ( ps -> ch ) -> ( ph -> ch ) ) ) ;
		step 2 : wff = theorem merlem13 () |- ( ( ph -> ps ) -> ( ( ( ( ch -> ch ) -> ( -. -. -. ph -> -. ph ) ) -> -. -. ph ) -> ps ) ) ;
		step 3 : wff = theorem merlem13 () |- ( ( ( ph -> ps ) -> ( ( ( ( ch -> ch ) -> ( -. -. -. ph -> -. ph ) ) -> -. -. ph ) -> ps ) ) -> ( ( ( ( ( ( ps -> ch ) -> ( ph -> ch ) ) -> ph ) -> ( -. -. -. ( ph -> ps ) -> -. ( ph -> ps ) ) ) -> -. -. ( ph -> ps ) ) -> ( ( ( ( ch -> ch ) -> ( -. -. -. ph -> -. ph ) ) -> -. -. ph ) -> ps ) ) ) ;
		step 4 : wff = axiom ax-mp (step 2, step 3) |- ( ( ( ( ( ( ps -> ch ) -> ( ph -> ch ) ) -> ph ) -> ( -. -. -. ( ph -> ps ) -> -. ( ph -> ps ) ) ) -> -. -. ( ph -> ps ) ) -> ( ( ( ( ch -> ch ) -> ( -. -. -. ph -> -. ph ) ) -> -. -. ph ) -> ps ) ) ;
		step 5 : wff = theorem meredith () |- ( ( ( ( ( ( ( ps -> ch ) -> ( ph -> ch ) ) -> ph ) -> ( -. -. -. ( ph -> ps ) -> -. ( ph -> ps ) ) ) -> -. -. ( ph -> ps ) ) -> ( ( ( ( ch -> ch ) -> ( -. -. -. ph -> -. ph ) ) -> -. -. ph ) -> ps ) ) -> ( ( ( ( ( ( ch -> ch ) -> ( -. -. -. ph -> -. ph ) ) -> -. -. ph ) -> ps ) -> ( ( ps -> ch ) -> ( ph -> ch ) ) ) -> ( ( ph -> ps ) -> ( ( ps -> ch ) -> ( ph -> ch ) ) ) ) ) ;
		step 6 : wff = axiom ax-mp (step 4, step 5) |- ( ( ( ( ( ( ch -> ch ) -> ( -. -. -. ph -> -. ph ) ) -> -. -. ph ) -> ps ) -> ( ( ps -> ch ) -> ( ph -> ch ) ) ) -> ( ( ph -> ps ) -> ( ( ps -> ch ) -> ( ph -> ch ) ) ) ) ;
		step 7 : wff = axiom ax-mp (step 1, step 6) |- ( ( ph -> ps ) -> ( ( ps -> ch ) -> ( ph -> ch ) ) ) ;
		qed prop = step 7 ;
	}

	/*  2 of 3 axioms for propositional calculus due to Lukasiewicz, derived from
	     Meredith's sole axiom.  */
	theorem luk-2 (var ph : wff ) 
	{
		prop : wff = |- ( ( -. ph -> ph ) -> ph ) ;
	}

	/*  [14-Dec-2002]  */ 
	proof of luk-2 {
		step 1 : wff = theorem merlem5 () |- ( ( ph -> -. ( -. ph -> ph ) ) -> ( -. -. ph -> -. ( -. ph -> ph ) ) ) ;
		step 2 : wff = theorem merlem4 () |- ( ( ( ph -> -. ( -. ph -> ph ) ) -> ( -. -. ph -> -. ( -. ph -> ph ) ) ) -> ( ( ( ( ph -> -. ( -. ph -> ph ) ) -> ( -. -. ph -> -. ( -. ph -> ph ) ) ) -> -. ph ) -> ( ( ( ( ph -> -. ( -. ph -> ph ) ) -> ( -. -. ph -> -. ( -. ph -> ph ) ) ) -> -. ph ) -> -. ph ) ) ) ;
		step 3 : wff = axiom ax-mp (step 1, step 2) |- ( ( ( ( ph -> -. ( -. ph -> ph ) ) -> ( -. -. ph -> -. ( -. ph -> ph ) ) ) -> -. ph ) -> ( ( ( ( ph -> -. ( -. ph -> ph ) ) -> ( -. -. ph -> -. ( -. ph -> ph ) ) ) -> -. ph ) -> -. ph ) ) ;
		step 4 : wff = theorem merlem11 () |- ( ( ( ( ( ph -> -. ( -. ph -> ph ) ) -> ( -. -. ph -> -. ( -. ph -> ph ) ) ) -> -. ph ) -> ( ( ( ( ph -> -. ( -. ph -> ph ) ) -> ( -. -. ph -> -. ( -. ph -> ph ) ) ) -> -. ph ) -> -. ph ) ) -> ( ( ( ( ph -> -. ( -. ph -> ph ) ) -> ( -. -. ph -> -. ( -. ph -> ph ) ) ) -> -. ph ) -> -. ph ) ) ;
		step 5 : wff = axiom ax-mp (step 3, step 4) |- ( ( ( ( ph -> -. ( -. ph -> ph ) ) -> ( -. -. ph -> -. ( -. ph -> ph ) ) ) -> -. ph ) -> -. ph ) ;
		step 6 : wff = theorem meredith () |- ( ( ( ( ( ph -> -. ( -. ph -> ph ) ) -> ( -. -. ph -> -. ( -. ph -> ph ) ) ) -> -. ph ) -> -. ph ) -> ( ( -. ph -> ph ) -> ( ( -. ph -> ph ) -> ph ) ) ) ;
		step 7 : wff = axiom ax-mp (step 5, step 6) |- ( ( -. ph -> ph ) -> ( ( -. ph -> ph ) -> ph ) ) ;
		step 8 : wff = theorem merlem11 () |- ( ( ( -. ph -> ph ) -> ( ( -. ph -> ph ) -> ph ) ) -> ( ( -. ph -> ph ) -> ph ) ) ;
		step 9 : wff = axiom ax-mp (step 7, step 8) |- ( ( -. ph -> ph ) -> ph ) ;
		qed prop = step 9 ;
	}

	/*  3 of 3 axioms for propositional calculus due to Lukasiewicz, derived from
	     Meredith's sole axiom.  */
	theorem luk-3 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( -. ph -> ps ) ) ;
	}

	/*  [14-Dec-2002]  */ 
	proof of luk-3 {
		step 1 : wff = theorem merlem11 () |- ( ( -. ph -> ( -. ph -> ps ) ) -> ( -. ph -> ps ) ) ;
		step 2 : wff = theorem merlem1 () |- ( ( ( -. ph -> ( -. ph -> ps ) ) -> ( -. ph -> ps ) ) -> ( ph -> ( -. ph -> ps ) ) ) ;
		step 3 : wff = axiom ax-mp (step 1, step 2) |- ( ph -> ( -. ph -> ps ) ) ;
		qed prop = step 3 ;
	}

	/*  Used to rederive standard propositional axioms from Lukasiewicz'.  */
	theorem luklem1 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ps -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	/*  [23-Dec-2002]  */ 
	proof of luklem1 {
		step 1 : wff = theorem luk-1 () |- ( ( ph -> ps ) -> ( ( ps -> ch ) -> ( ph -> ch ) ) ) ;
		step 2 : wff = axiom ax-mp (hyp 1, step 1) |- ( ( ps -> ch ) -> ( ph -> ch ) ) ;
		step 3 : wff = axiom ax-mp (hyp 2, step 2) |- ( ph -> ch ) ;
		qed prop = step 3 ;
	}

	/*  Used to rederive standard propositional axioms from Lukasiewicz'.  */
	theorem luklem2 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ( ph -> -. ps ) -> ( ( ( ph -> ch ) -> th ) -> ( ps -> th ) ) ) ;
	}

	/*  [22-Dec-2002]  */ 
	proof of luklem2 {
		step 1 : wff = theorem luk-1 () |- ( ( ph -> -. ps ) -> ( ( -. ps -> ch ) -> ( ph -> ch ) ) ) ;
		step 2 : wff = theorem luk-3 () |- ( ps -> ( -. ps -> ch ) ) ;
		step 3 : wff = theorem luk-1 () |- ( ( ps -> ( -. ps -> ch ) ) -> ( ( ( -. ps -> ch ) -> ( ph -> ch ) ) -> ( ps -> ( ph -> ch ) ) ) ) ;
		step 4 : wff = axiom ax-mp (step 2, step 3) |- ( ( ( -. ps -> ch ) -> ( ph -> ch ) ) -> ( ps -> ( ph -> ch ) ) ) ;
		step 5 : wff = theorem luklem1 (step 1, step 4) |- ( ( ph -> -. ps ) -> ( ps -> ( ph -> ch ) ) ) ;
		step 6 : wff = theorem luk-1 () |- ( ( ps -> ( ph -> ch ) ) -> ( ( ( ph -> ch ) -> th ) -> ( ps -> th ) ) ) ;
		step 7 : wff = theorem luklem1 (step 5, step 6) |- ( ( ph -> -. ps ) -> ( ( ( ph -> ch ) -> th ) -> ( ps -> th ) ) ) ;
		qed prop = step 7 ;
	}

	/*  Used to rederive standard propositional axioms from Lukasiewicz'.  */
	theorem luklem3 (var ph : wff , var ps : wff , var ch : wff , var th : wff ) 
	{
		prop : wff = |- ( ph -> ( ( ( -. ph -> ps ) -> ch ) -> ( th -> ch ) ) ) ;
	}

	/*  [22-Dec-2002]  */ 
	proof of luklem3 {
		step 1 : wff = theorem luk-3 () |- ( ph -> ( -. ph -> -. th ) ) ;
		step 2 : wff = theorem luklem2 () |- ( ( -. ph -> -. th ) -> ( ( ( -. ph -> ps ) -> ch ) -> ( th -> ch ) ) ) ;
		step 3 : wff = theorem luklem1 (step 1, step 2) |- ( ph -> ( ( ( -. ph -> ps ) -> ch ) -> ( th -> ch ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Used to rederive standard propositional axioms from Lukasiewicz'.  */
	theorem luklem4 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ( ( -. ph -> ph ) -> ph ) -> ps ) -> ps ) ;
	}

	/*  [22-Dec-2002]  */ 
	proof of luklem4 {
		step 1 : wff = theorem luk-2 () |- ( ( -. ( ( -. ph -> ph ) -> ph ) -> ( ( -. ph -> ph ) -> ph ) ) -> ( ( -. ph -> ph ) -> ph ) ) ;
		step 2 : wff = theorem luk-2 () |- ( ( -. ph -> ph ) -> ph ) ;
		step 3 : wff = theorem luklem3 () |- ( ( ( -. ph -> ph ) -> ph ) -> ( ( ( -. ( ( -. ph -> ph ) -> ph ) -> ( ( -. ph -> ph ) -> ph ) ) -> ( ( -. ph -> ph ) -> ph ) ) -> ( -. ps -> ( ( -. ph -> ph ) -> ph ) ) ) ) ;
		step 4 : wff = axiom ax-mp (step 2, step 3) |- ( ( ( -. ( ( -. ph -> ph ) -> ph ) -> ( ( -. ph -> ph ) -> ph ) ) -> ( ( -. ph -> ph ) -> ph ) ) -> ( -. ps -> ( ( -. ph -> ph ) -> ph ) ) ) ;
		step 5 : wff = axiom ax-mp (step 1, step 4) |- ( -. ps -> ( ( -. ph -> ph ) -> ph ) ) ;
		step 6 : wff = theorem luk-1 () |- ( ( -. ps -> ( ( -. ph -> ph ) -> ph ) ) -> ( ( ( ( -. ph -> ph ) -> ph ) -> ps ) -> ( -. ps -> ps ) ) ) ;
		step 7 : wff = axiom ax-mp (step 5, step 6) |- ( ( ( ( -. ph -> ph ) -> ph ) -> ps ) -> ( -. ps -> ps ) ) ;
		step 8 : wff = theorem luk-2 () |- ( ( -. ps -> ps ) -> ps ) ;
		step 9 : wff = theorem luklem1 (step 7, step 8) |- ( ( ( ( -. ph -> ph ) -> ph ) -> ps ) -> ps ) ;
		qed prop = step 9 ;
	}

	/*  Used to rederive standard propositional axioms from Lukasiewicz'.  */
	theorem luklem5 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ps -> ph ) ) ;
	}

	/*  [22-Dec-2002]  */ 
	proof of luklem5 {
		step 1 : wff = theorem luklem3 () |- ( ph -> ( ( ( -. ph -> ph ) -> ph ) -> ( ps -> ph ) ) ) ;
		step 2 : wff = theorem luklem4 () |- ( ( ( ( -. ph -> ph ) -> ph ) -> ( ps -> ph ) ) -> ( ps -> ph ) ) ;
		step 3 : wff = theorem luklem1 (step 1, step 2) |- ( ph -> ( ps -> ph ) ) ;
		qed prop = step 3 ;
	}

	/*  Used to rederive standard propositional axioms from Lukasiewicz'.  */
	theorem luklem6 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ph -> ps ) ) -> ( ph -> ps ) ) ;
	}

	/*  [22-Dec-2002]  */ 
	proof of luklem6 {
		step 1 : wff = theorem luk-1 () |- ( ( ph -> ( ph -> ps ) ) -> ( ( ( ph -> ps ) -> ps ) -> ( ph -> ps ) ) ) ;
		step 2 : wff = theorem luklem5 () |- ( -. ( ph -> ps ) -> ( -. ps -> -. ( ph -> ps ) ) ) ;
		step 3 : wff = theorem luklem2 () |- ( ( -. ps -> -. ( ph -> ps ) ) -> ( ( ( -. ps -> ps ) -> ps ) -> ( ( ph -> ps ) -> ps ) ) ) ;
		step 4 : wff = theorem luklem4 () |- ( ( ( ( -. ps -> ps ) -> ps ) -> ( ( ph -> ps ) -> ps ) ) -> ( ( ph -> ps ) -> ps ) ) ;
		step 5 : wff = theorem luklem1 (step 3, step 4) |- ( ( -. ps -> -. ( ph -> ps ) ) -> ( ( ph -> ps ) -> ps ) ) ;
		step 6 : wff = theorem luklem1 (step 2, step 5) |- ( -. ( ph -> ps ) -> ( ( ph -> ps ) -> ps ) ) ;
		step 7 : wff = theorem luk-1 () |- ( ( -. ( ph -> ps ) -> ( ( ph -> ps ) -> ps ) ) -> ( ( ( ( ph -> ps ) -> ps ) -> ( ph -> ps ) ) -> ( -. ( ph -> ps ) -> ( ph -> ps ) ) ) ) ;
		step 8 : wff = axiom ax-mp (step 6, step 7) |- ( ( ( ( ph -> ps ) -> ps ) -> ( ph -> ps ) ) -> ( -. ( ph -> ps ) -> ( ph -> ps ) ) ) ;
		step 9 : wff = theorem luk-1 () |- ( ( ( ( ( ph -> ps ) -> ps ) -> ( ph -> ps ) ) -> ( -. ( ph -> ps ) -> ( ph -> ps ) ) ) -> ( ( ( -. ( ph -> ps ) -> ( ph -> ps ) ) -> ( ph -> ps ) ) -> ( ( ( ( ph -> ps ) -> ps ) -> ( ph -> ps ) ) -> ( ph -> ps ) ) ) ) ;
		step 10 : wff = axiom ax-mp (step 8, step 9) |- ( ( ( -. ( ph -> ps ) -> ( ph -> ps ) ) -> ( ph -> ps ) ) -> ( ( ( ( ph -> ps ) -> ps ) -> ( ph -> ps ) ) -> ( ph -> ps ) ) ) ;
		step 11 : wff = theorem luklem4 () |- ( ( ( ( -. ( ph -> ps ) -> ( ph -> ps ) ) -> ( ph -> ps ) ) -> ( ( ( ( ph -> ps ) -> ps ) -> ( ph -> ps ) ) -> ( ph -> ps ) ) ) -> ( ( ( ( ph -> ps ) -> ps ) -> ( ph -> ps ) ) -> ( ph -> ps ) ) ) ;
		step 12 : wff = axiom ax-mp (step 10, step 11) |- ( ( ( ( ph -> ps ) -> ps ) -> ( ph -> ps ) ) -> ( ph -> ps ) ) ;
		step 13 : wff = theorem luklem1 (step 1, step 12) |- ( ( ph -> ( ph -> ps ) ) -> ( ph -> ps ) ) ;
		qed prop = step 13 ;
	}

	/*  Used to rederive standard propositional axioms from Lukasiewicz'.  */
	theorem luklem7 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ps -> ch ) ) -> ( ps -> ( ph -> ch ) ) ) ;
	}

	/*  [22-Dec-2002]  */ 
	proof of luklem7 {
		step 1 : wff = theorem luk-1 () |- ( ( ph -> ( ps -> ch ) ) -> ( ( ( ps -> ch ) -> ch ) -> ( ph -> ch ) ) ) ;
		step 2 : wff = theorem luklem5 () |- ( ps -> ( ( ps -> ch ) -> ps ) ) ;
		step 3 : wff = theorem luk-1 () |- ( ( ( ps -> ch ) -> ps ) -> ( ( ps -> ch ) -> ( ( ps -> ch ) -> ch ) ) ) ;
		step 4 : wff = theorem luklem1 (step 2, step 3) |- ( ps -> ( ( ps -> ch ) -> ( ( ps -> ch ) -> ch ) ) ) ;
		step 5 : wff = theorem luklem6 () |- ( ( ( ps -> ch ) -> ( ( ps -> ch ) -> ch ) ) -> ( ( ps -> ch ) -> ch ) ) ;
		step 6 : wff = theorem luklem1 (step 4, step 5) |- ( ps -> ( ( ps -> ch ) -> ch ) ) ;
		step 7 : wff = theorem luk-1 () |- ( ( ps -> ( ( ps -> ch ) -> ch ) ) -> ( ( ( ( ps -> ch ) -> ch ) -> ( ph -> ch ) ) -> ( ps -> ( ph -> ch ) ) ) ) ;
		step 8 : wff = axiom ax-mp (step 6, step 7) |- ( ( ( ( ps -> ch ) -> ch ) -> ( ph -> ch ) ) -> ( ps -> ( ph -> ch ) ) ) ;
		step 9 : wff = theorem luklem1 (step 1, step 8) |- ( ( ph -> ( ps -> ch ) ) -> ( ps -> ( ph -> ch ) ) ) ;
		qed prop = step 9 ;
	}

	/*  Used to rederive standard propositional axioms from Lukasiewicz'.  */
	theorem luklem8 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( ch -> ph ) -> ( ch -> ps ) ) ) ;
	}

	/*  [22-Dec-2002]  */ 
	proof of luklem8 {
		step 1 : wff = theorem luk-1 () |- ( ( ch -> ph ) -> ( ( ph -> ps ) -> ( ch -> ps ) ) ) ;
		step 2 : wff = theorem luklem7 () |- ( ( ( ch -> ph ) -> ( ( ph -> ps ) -> ( ch -> ps ) ) ) -> ( ( ph -> ps ) -> ( ( ch -> ph ) -> ( ch -> ps ) ) ) ) ;
		step 3 : wff = axiom ax-mp (step 1, step 2) |- ( ( ph -> ps ) -> ( ( ch -> ph ) -> ( ch -> ps ) ) ) ;
		qed prop = step 3 ;
	}

	/*  Standard propositional axiom derived from Lukasiewicz axioms.  */
	theorem ax1 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ph -> ( ps -> ph ) ) ;
	}

	/*  [22-Dec-2002]  */ 
	proof of ax1 {
		step 1 : wff = theorem luklem5 () |- ( ph -> ( ps -> ph ) ) ;
		qed prop = step 1 ;
	}

	/*  Standard propositional axiom derived from Lukasiewicz axioms.  */
	theorem ax2 (var ph : wff , var ps : wff , var ch : wff ) 
	{
		prop : wff = |- ( ( ph -> ( ps -> ch ) ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ;
	}

	/*  [22-Dec-2002]  */ 
	proof of ax2 {
		step 1 : wff = theorem luklem7 () |- ( ( ph -> ( ps -> ch ) ) -> ( ps -> ( ph -> ch ) ) ) ;
		step 2 : wff = theorem luklem8 () |- ( ( ps -> ( ph -> ch ) ) -> ( ( ph -> ps ) -> ( ph -> ( ph -> ch ) ) ) ) ;
		step 3 : wff = theorem luklem6 () |- ( ( ph -> ( ph -> ch ) ) -> ( ph -> ch ) ) ;
		step 4 : wff = theorem luklem8 () |- ( ( ( ph -> ( ph -> ch ) ) -> ( ph -> ch ) ) -> ( ( ( ph -> ps ) -> ( ph -> ( ph -> ch ) ) ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ) ;
		step 5 : wff = axiom ax-mp (step 3, step 4) |- ( ( ( ph -> ps ) -> ( ph -> ( ph -> ch ) ) ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ;
		step 6 : wff = theorem luklem1 (step 2, step 5) |- ( ( ps -> ( ph -> ch ) ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ;
		step 7 : wff = theorem luklem1 (step 1, step 6) |- ( ( ph -> ( ps -> ch ) ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ;
		qed prop = step 7 ;
	}

	/*  Standard propositional axiom derived from Lukasiewicz axioms.  */
	theorem ax3 (var ph : wff , var ps : wff ) 
	{
		prop : wff = |- ( ( -. ph -> -. ps ) -> ( ps -> ph ) ) ;
	}

	/*  [22-Dec-2002]  */ 
	proof of ax3 {
		step 1 : wff = theorem luklem2 () |- ( ( -. ph -> -. ps ) -> ( ( ( -. ph -> ph ) -> ph ) -> ( ps -> ph ) ) ) ;
		step 2 : wff = theorem luklem4 () |- ( ( ( ( -. ph -> ph ) -> ph ) -> ( ps -> ph ) ) -> ( ps -> ph ) ) ;
		step 3 : wff = theorem luklem1 (step 1, step 2) |- ( ( -. ph -> -. ps ) -> ( ps -> ph ) ) ;
		qed prop = step 3 ;
	}

	/*  Axiom of Nicod from _Introduction to Mathematical Philosophy_ B. Russell,
	     p. 152.  The axiom is recovered from this raw form by substituting
	     ` ( ph | ps ) ` for ` -. ( ph /\ ps ) ` , where ` | ` is the Sheffer
	     stroke (NAND) connective, so that the Sheffer stroke becomes the sole
	     connective.  See ~ nicodmpraw for the inference rule.  (Based on a proof
	     by Jeff Hoffman, 19-Nov-2007.)  */
	theorem nicodraw (var ph : wff , var ps : wff , var ch : wff , var th : wff , var ta : wff ) 
	{
		prop : wff = |- -. ( -. ( ph /\ -. ( ch /\ ps ) ) /\ -. ( -. ( ta /\ -. ( ta /\ ta ) ) /\ -. ( -. ( th /\ ch ) /\ -. ( -. ( ph /\ th ) /\ -. ( ph /\ th ) ) ) ) ) ;
	}

	/*  [20-Nov-2007]  */ /*  [19-Nov-2007]  */ 
	proof of nicodraw {
		step 1 : wff = theorem iman () |- ( ( ph -> ( ch /\ ps ) ) <-> -. ( ph /\ -. ( ch /\ ps ) ) ) ;
		step 2 : wff = theorem biimpr (step 1) |- ( -. ( ph /\ -. ( ch /\ ps ) ) -> ( ph -> ( ch /\ ps ) ) ) ;
		step 3 : wff = theorem pm3_26 () |- ( ( ch /\ ps ) -> ch ) ;
		step 4 : wff = theorem imim2i (step 3) |- ( ( ph -> ( ch /\ ps ) ) -> ( ph -> ch ) ) ;
		step 5 : wff = theorem con3 () |- ( ( ph -> ch ) -> ( -. ch -> -. ph ) ) ;
		step 6 : wff = theorem imim2d (step 5) |- ( ( ph -> ch ) -> ( ( th -> -. ch ) -> ( th -> -. ph ) ) ) ;
		step 7 : wff = theorem bi2_03 () |- ( ( th -> -. ph ) <-> ( ph -> -. th ) ) ;
		step 8 : wff = theorem imnan () |- ( ( ph -> -. th ) <-> -. ( ph /\ th ) ) ;
		step 9 : wff = theorem bitr2 (step 7, step 8) |- ( -. ( ph /\ th ) <-> ( th -> -. ph ) ) ;
		step 10 : wff = theorem syl6ibr (step 6, step 9) |- ( ( ph -> ch ) -> ( ( th -> -. ch ) -> -. ( ph /\ th ) ) ) ;
		step 11 : wff = theorem imnan () |- ( ( th -> -. ch ) <-> -. ( th /\ ch ) ) ;
		step 12 : wff = theorem syl5ibr (step 10, step 11) |- ( ( ph -> ch ) -> ( -. ( th /\ ch ) -> -. ( ph /\ th ) ) ) ;
		step 13 : wff = theorem iman () |- ( ( -. ( th /\ ch ) -> ( -. ( ph /\ th ) /\ -. ( ph /\ th ) ) ) <-> -. ( -. ( th /\ ch ) /\ -. ( -. ( ph /\ th ) /\ -. ( ph /\ th ) ) ) ) ;
		step 14 : wff = theorem anidm () |- ( ( -. ( ph /\ th ) /\ -. ( ph /\ th ) ) <-> -. ( ph /\ th ) ) ;
		step 15 : wff = theorem imbi2i (step 14) |- ( ( -. ( th /\ ch ) -> ( -. ( ph /\ th ) /\ -. ( ph /\ th ) ) ) <-> ( -. ( th /\ ch ) -> -. ( ph /\ th ) ) ) ;
		step 16 : wff = theorem bitr3 (step 13, step 15) |- ( -. ( -. ( th /\ ch ) /\ -. ( -. ( ph /\ th ) /\ -. ( ph /\ th ) ) ) <-> ( -. ( th /\ ch ) -> -. ( ph /\ th ) ) ) ;
		step 17 : wff = theorem sylibr (step 12, step 16) |- ( ( ph -> ch ) -> -. ( -. ( th /\ ch ) /\ -. ( -. ( ph /\ th ) /\ -. ( ph /\ th ) ) ) ) ;
		step 18 : wff = theorem _3syl (step 2, step 4, step 17) |- ( -. ( ph /\ -. ( ch /\ ps ) ) -> -. ( -. ( th /\ ch ) /\ -. ( -. ( ph /\ th ) /\ -. ( ph /\ th ) ) ) ) ;
		step 19 : wff = theorem pm4_24 () |- ( ta <-> ( ta /\ ta ) ) ;
		step 20 : wff = theorem biimp (step 19) |- ( ta -> ( ta /\ ta ) ) ;
		step 21 : wff = theorem iman () |- ( ( ta -> ( ta /\ ta ) ) <-> -. ( ta /\ -. ( ta /\ ta ) ) ) ;
		step 22 : wff = theorem mpbi (step 20, step 21) |- -. ( ta /\ -. ( ta /\ ta ) ) ;
		step 23 : wff = theorem jctil (step 18, step 22) |- ( -. ( ph /\ -. ( ch /\ ps ) ) -> ( -. ( ta /\ -. ( ta /\ ta ) ) /\ -. ( -. ( th /\ ch ) /\ -. ( -. ( ph /\ th ) /\ -. ( ph /\ th ) ) ) ) ) ;
		step 24 : wff = theorem iman () |- ( ( -. ( ph /\ -. ( ch /\ ps ) ) -> ( -. ( ta /\ -. ( ta /\ ta ) ) /\ -. ( -. ( th /\ ch ) /\ -. ( -. ( ph /\ th ) /\ -. ( ph /\ th ) ) ) ) ) <-> -. ( -. ( ph /\ -. ( ch /\ ps ) ) /\ -. ( -. ( ta /\ -. ( ta /\ ta ) ) /\ -. ( -. ( th /\ ch ) /\ -. ( -. ( ph /\ th ) /\ -. ( ph /\ th ) ) ) ) ) ) ;
		step 25 : wff = theorem mpbi (step 23, step 24) |- -. ( -. ( ph /\ -. ( ch /\ ps ) ) /\ -. ( -. ( ta /\ -. ( ta /\ ta ) ) /\ -. ( -. ( th /\ ch ) /\ -. ( -. ( ph /\ th ) /\ -. ( ph /\ th ) ) ) ) ) ;
		qed prop = step 25 ;
	}

}

