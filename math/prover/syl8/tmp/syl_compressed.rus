/*****************************************************************************/
/* Project name: Russell language pure mathematics library                   */
/* File name:    src.rus                                                     */
/* Description:  Russell language pure mathematics library                   */
/* Created:      automatically decompiled by mm program from metamath base   */
/* Email:        vlasov at academ.org                                        */
/* URL:          http://russellmath.org                                      */
/* License:      Creative Commons Public Domain Dedication                   */
/*****************************************************************************/

theory src ;

contents of src  {

	/* 
	#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
	                           Pre-logic
	#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
	 */
/*  Declare the primitive constant symbols for propositional calculus.  */
/*  Left parenthesis  */

	constant 
	{ 
		symbol ( ;
		ascii ( ;
	} 

	/*  Right parenthesis  */

	constant 
	{ 
		symbol ) ;
		ascii ) ;
	} 

	/*  Right arrow (read:  "implies")  */

	constant 
	{ 
		symbol -> ;
		ascii -> ;
	} 

	/*  Right handle (read:  "not")  */

	constant 
	{ 
		symbol -. ;
		ascii -. ;
	} 

	type wff  ;

	/* 
	#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
	                           Propositional calculus
	#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#
	 */
/* 
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	        Recursively define primitive wffs for propositional calculus
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	 */
/*  If ` ph ` is a wff, so is ` -. ph ` or "not ` ph ` ."  Part of the
	     recursive definition of a wff (well-formed formula).  In classical logic
	     (which is our logic), a wff is interpreted as either true or false.
	     So if ` ph ` is true, then ` -. ph ` is false; if ` ph ` is false, then
	     ` -. ph ` is true.  Traditionally, Greek letters are used to represent
	     wffs, and we follow this convention.  In propositional calculus, we define
	     only wffs built up from other wffs, i.e. there is no starting or "atomic"
	     wff.  Later, in predicate calculus, we will extend the basic wff
	     definition by including atomic wffs ( ~ weq and ~ wel ).  */

	rule wn  (var ph : wff) 
	{
		term : wff = # -. ph ;
	}

	/*  If ` ph ` and ` ps ` are wff's, so is ` ( ph -> ps ) ` or " ` ph ` implies
	     ` ps ` ."  Part of the recursive definition of a wff.  The resulting wff
	     is (interpreted as) false when ` ph ` is true and ` ps ` is false; it is
	     true otherwise.  (Think of the truth table for an OR gate with input
	     ` ph ` connected through an inverter.)  The left-hand wff is called the
	     antecedent, and the right-hand wff is called the consequent.  In the case
	     of ` ( ph -> ( ps -> ch ) ) ` , the middle ` ps ` may be informally called
	     either an antecedent or part of the consequent depending on context.  */

	rule wi  (var ph : wff, var ps : wff) 
	{
		term : wff = # ( ph -> ps ) ;
	}

	/* 
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	        The axioms of propositional calculus
	=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
	 */
/* 
	     Postulate the three axioms of classical propositional calculus.
	   */
/*  Axiom _Simp_.  Axiom A1 of [Margaris] p. 49.  One of the 3 axioms of
	     propositional calculus.  The 3 axioms are also given as Definition 2.1
	     of [Hamilton] p. 28.  This axiom is called _Simp_ or "the principle of
	     simplification" in _Principia Mathematica_ (Theorem *2.02 of
	     [WhiteheadRussell] p. 100) because "it enables us to pass from the joint
	     assertion of ` ph ` and ` ps ` to the assertion of ` ph ` simply."
	
	     _General remarks_:  Propositional calculus (axioms ~ ax-1 through ~ ax-3
	     and rule ~ ax-mp ) can be thought of as asserting formulas that are
	     universally "true" when their variables are replaced by any combination
	     of "true" and "false."  Propositional calculus was first formalized by
	     Frege in 1879, using as his axioms (in addition to rule ~ ax-mp ) the
	     wffs ~ ax-1 , ~ ax-2 , ~ pm2.04 , ~ con3 , ~ nega , and ~ negb .  Around
	     1930, Lukasiewicz simplified the system by eliminating the third (which
	     follows from the first two, as you can see by looking at the proof of
	     ~ pm2.04 ) and replacing the last three with our ~ ax-3 .  (Thanks to Ted
	     Ulrich for this information.)
	
	     The theorems of propositional calculus are also called _tautologies_.
	     Tautologies can be proved very simply using truth tables, based on the
	     true/false interpretation of propositional calculus.  To do this, we
	     assign all possible combinations of true and false to the wff variables
	     and verify that the result (using the rules described in ~ wi and ~ wn )
	     always evaluates to true.  This is called the _semantic_ approach.  Our
	     approach is called the _syntactic_ approach, in which everything is
	     derived from axioms.  A metatheorem called the Completeness Theorem for
	     Propositional Calculus shows that the two approaches are equivalent and
	     even provides an algorithm for automatically generating syntactic proofs
	     from a truth table.  Those proofs, however, tend to be long, and the
	     much shorter proofs that we show here were found manually.  Truth tables
	     grow exponentially with the number of variables, but it is unknown if the
	     same is true of proofs - an answer to this would resolve the P=NP
	     conjecture in complexity theory.  */

	axiom ax-1  (var ph : wff, var ps : wff) 
	{
		prop : wff = |- ( ph -> ( ps -> ph ) ) ;
	}

	/*  Axiom _Frege_.  Axiom A2 of [Margaris] p. 49.  One of the 3 axioms of
	     propositional calculus.  It "distributes" an antecedent over two
	     consequents.  This axiom was part of Frege's original system and is known
	     as _Frege_ in the literature.  It is also proved as Theorem *2.77 of
	     [WhiteheadRussell] p. 108.  The other direction of this axiom also
	     turns out to be true, as demonstrated by ~ pm5.41 .  */

	axiom ax-2  (var ph : wff, var ps : wff, var ch : wff) 
	{
		prop : wff = |- ( ( ph -> ( ps -> ch ) ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) ) ;
	}

	/*  Axiom _Transp_.  Axiom A3 of [Margaris] p. 49.  One of the 3 axioms of
	     propositional calculus.  It swaps or "transposes" the order of the
	     consequents when negation is removed.  An informal example is that the
	     statement "if there are no clouds in the sky, it is not raining" implies
	     the statement "if it is raining, there are clouds in the sky."  This
	     axiom is called _Transp_ or "the principle of transposition" in
	     _Principia Mathematica_ (Theorem *2.17 of [WhiteheadRussell] p. 103).
	     We will also use the term "contraposition" for this principle, although
	     the reader is advised that in the field of philosophical logic,
	     "contraposition" has a different technical meaning.  */

	axiom ax-3  (var ph : wff, var ps : wff) 
	{
		prop : wff = |- ( ( -. ph -> -. ps ) -> ( ps -> ph ) ) ;
	}

	/*  Rule of Modus Ponens.  The postulated inference rule of propositional
	       calculus.  See e.g. Rule 1 of [Hamilton] p. 73.  The rule says, "if
	       ` ph ` is true, and ` ph ` implies ` ps ` , then ` ps ` must also be
	       true."  This rule is sometimes called "detachment," since it detaches
	       the minor premise from the major premise.  */

	axiom ax-mp  (var ph : wff, var ps : wff) 
	{
		hyp 1 : wff = |- ph ;
		hyp 2 : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ps ;
	}

	/*  Inference derived from axiom ~ ax-1 .  See ~ a1d for an explanation of
	       our informal use of the terms "inference" and "deduction."  */

	theorem a1i  (var ph : wff, var ps : wff) 
	{
		hyp : wff = |- ph ;
		-----------------
		prop : wff = |- ( ps -> ph ) ;
	}

	proof of a1i {
		step 1 : wff  = axiom ax-1 () |- ( ph -> ( ps -> ph ) )  ;
		step 2 : wff  = axiom ax-mp (hyp 1, step 1) |- ( ps -> ph )  ;
		qed prop 1 = step 2 ;
	}

	/*  Inference derived from axiom ~ ax-2 .  */

	theorem a2i  (var ph : wff, var ps : wff, var ch : wff) 
	{
		hyp : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ( ph -> ps ) -> ( ph -> ch ) ) ;
	}

	proof of a2i {
		step 1 : wff  = axiom ax-2 () |- ( ( ph -> ( ps -> ch ) ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) )  ;
		step 2 : wff  = axiom ax-mp (hyp 1, step 1) |- ( ( ph -> ps ) -> ( ph -> ch ) )  ;
		qed prop 1 = step 2 ;
	}

	/*  An inference version of the transitive laws for implication ~ imim2 and
	       ~ imim1 , which Russell and Whitehead call "the principle of the
	       syllogism...because...the syllogism in Barbara is derived from them"
	       (quote after Theorem *2.06 of [WhiteheadRussell] p. 101).  Some authors
	       call this law a "hypothetical syllogism."
	
	       (A bit of trivia:  this is the most commonly referenced assertion in our
	       database.  In second place is ~ ax-mp , followed by ~ visset , ~ bitr ,
	       ~ imp , and ~ ex .  The Metamath program command 'show usage' shows the
	       number of references.)  */

	problem syl  (var ph : wff, var ps : wff, var ch : wff) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ps -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ch ) ;
	}

	proof of syl {
		step 1 : wff  = ? |- ( ph -> ( ps -> ch ) )  ;
		step 2 : wff  = ? |- ( ( ph -> ps ) -> ( ph -> ch ) )  ;
		step 3 : wff  = ? |- ( ph -> ch )  ;
		qed prop 1 = step 3 ;
	}

	/*  Inference that swaps (commutes) antecedents in an implication.  */

	theorem com12  (var ph : wff, var ps : wff, var ch : wff) 
	{
		hyp : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ps -> ( ph -> ch ) ) ;
	}

	proof of com12 {
		step 1 : wff  = axiom ax-1 () |- ( ps -> ( ph -> ps ) )  ;
		step 2 : wff  = theorem a2i (hyp 1) |- ( ( ph -> ps ) -> ( ph -> ch ) )  ;
		step 3 : wff  = theorem syl (step 1, step 2) |- ( ps -> ( ph -> ch ) )  ;
		qed prop 1 = step 3 ;
	}

	/*  Deduction introducing an embedded antecedent.  (The proof was revised by
	       Stefan Allan, 20-Mar-06.)
	
	       _Naming convention_:  We often call a theorem a "deduction" and suffix
	       its label with "d" whenever the hypotheses and conclusion are each
	       prefixed with the same antecedent.  This allows us to use the theorem in
	       places where (in traditional textbook formalizations) the standard
	       Deduction Theorem would be used; here ` ph ` would be replaced with a
	       conjunction ( ~ df-an ) of the hypotheses of the would-be deduction.  By
	       contrast, we tend to call the simpler version with no common antecedent
	       an "inference" and suffix its label with "i"; compare theorem ~ a1i .
	       Finally, a "theorem" would be the form with no hypotheses; in this case
	       the "theorem" form would be the original axiom ~ ax-1 .  In
	       propositional calculus we usually prove the theorem form first without a
	       suffix on its label (e.g.  ~ pm2.43 vs.  ~ pm2.43i vs.  ~ pm2.43d ), but
	       (much) later we often suffix the theorem form's label with "t" as in
	       ~ negnegt vs. ~ negneg , especially when our "weak deduction theorem"
	       ~ dedth is used to prove the theorem form from its inference form.  When
	       an inference is converted to a theorem by eliminating an "is a set"
	       hypothesis, we sometimes suffix the theorem form with "g" (for somewhat
	       overstated "generalized") as in ~ uniex vs.  ~ uniexg .  */

	theorem a1d  (var ph : wff, var ps : wff, var ch : wff) 
	{
		hyp : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( ch -> ps ) ) ;
	}

	proof of a1d {
		step 1 : wff  = axiom ax-1 () |- ( ps -> ( ch -> ps ) )  ;
		step 2 : wff  = theorem syl (hyp 1, step 1) |- ( ph -> ( ch -> ps ) )  ;
		qed prop 1 = step 2 ;
	}

	/*  Deduction distributing an embedded antecedent.  */

	theorem a2d  (var ph : wff, var ps : wff, var ch : wff, var th : wff) 
	{
		hyp : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		-----------------
		prop : wff = |- ( ph -> ( ( ps -> ch ) -> ( ps -> th ) ) ) ;
	}

	proof of a2d {
		step 1 : wff  = axiom ax-2 () |- ( ( ps -> ( ch -> th ) ) -> ( ( ps -> ch ) -> ( ps -> th ) ) )  ;
		step 2 : wff  = theorem syl (hyp 1, step 1) |- ( ph -> ( ( ps -> ch ) -> ( ps -> th ) ) )  ;
		qed prop 1 = step 2 ;
	}

	/*  A closed form of syllogism (see ~ syl ).  Theorem *2.05 of
	     [WhiteheadRussell] p. 100.  */

	theorem imim2  (var ph : wff, var ps : wff, var ch : wff) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( ch -> ph ) -> ( ch -> ps ) ) ) ;
	}

	proof of imim2 {
		step 1 : wff  = axiom ax-1 () |- ( ( ph -> ps ) -> ( ch -> ( ph -> ps ) ) )  ;
		step 2 : wff  = theorem a2d (step 1) |- ( ( ph -> ps ) -> ( ( ch -> ph ) -> ( ch -> ps ) ) )  ;
		qed prop 1 = step 2 ;
	}

	/*  A closed form of syllogism (see ~ syl ).  Theorem *2.06 of
	     [WhiteheadRussell] p. 100.  */

	theorem imim1  (var ph : wff, var ps : wff, var ch : wff) 
	{
		prop : wff = |- ( ( ph -> ps ) -> ( ( ps -> ch ) -> ( ph -> ch ) ) ) ;
	}

	proof of imim1 {
		step 1 : wff  = theorem imim2 () |- ( ( ps -> ch ) -> ( ( ph -> ps ) -> ( ph -> ch ) ) )  ;
		step 2 : wff  = theorem com12 (step 1) |- ( ( ph -> ps ) -> ( ( ps -> ch ) -> ( ph -> ch ) ) )  ;
		qed prop 1 = step 2 ;
	}

	/*  Inference adding common consequents in an implication, thereby
	       interchanging the original antecedent and consequent.  */

	theorem imim1i  (var ph : wff, var ps : wff, var ch : wff) 
	{
		hyp : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ( ps -> ch ) -> ( ph -> ch ) ) ;
	}

	proof of imim1i {
		step 1 : wff  = theorem imim1 () |- ( ( ph -> ps ) -> ( ( ps -> ch ) -> ( ph -> ch ) ) )  ;
		step 2 : wff  = axiom ax-mp (hyp 1, step 1) |- ( ( ps -> ch ) -> ( ph -> ch ) )  ;
		qed prop 1 = step 2 ;
	}

	/*  Inference adding common antecedents in an implication.  */

	theorem imim2i  (var ph : wff, var ps : wff, var ch : wff) 
	{
		hyp : wff = |- ( ph -> ps ) ;
		-----------------
		prop : wff = |- ( ( ch -> ph ) -> ( ch -> ps ) ) ;
	}

	proof of imim2i {
		step 1 : wff  = theorem a1i (hyp 1) |- ( ch -> ( ph -> ps ) )  ;
		step 2 : wff  = theorem a2i (step 1) |- ( ( ch -> ph ) -> ( ch -> ps ) )  ;
		qed prop 1 = step 2 ;
	}

	/*  Inference joining two implications.  */

	theorem imim12i  (var ph : wff, var ps : wff, var ch : wff, var th : wff) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ch -> th ) ;
		-----------------
		prop : wff = |- ( ( ps -> ch ) -> ( ph -> th ) ) ;
	}

	proof of imim12i {
		step 1 : wff  = theorem imim2i (hyp 2) |- ( ( ps -> ch ) -> ( ps -> th ) )  ;
		step 2 : wff  = theorem imim1i (hyp 1) |- ( ( ps -> th ) -> ( ph -> th ) )  ;
		step 3 : wff  = theorem syl (step 1, step 2) |- ( ( ps -> ch ) -> ( ph -> th ) )  ;
		qed prop 1 = step 3 ;
	}

	/*  Inference adding three nested antecedents.  */

	theorem imim3i  (var ph : wff, var ps : wff, var ch : wff, var th : wff) 
	{
		hyp : wff = |- ( ph -> ( ps -> ch ) ) ;
		-----------------
		prop : wff = |- ( ( th -> ph ) -> ( ( th -> ps ) -> ( th -> ch ) ) ) ;
	}

	proof of imim3i {
		step 1 : wff  = theorem imim2i (hyp 1) |- ( ( th -> ph ) -> ( th -> ( ps -> ch ) ) )  ;
		step 2 : wff  = theorem a2d (step 1) |- ( ( th -> ph ) -> ( ( th -> ps ) -> ( th -> ch ) ) )  ;
		qed prop 1 = step 2 ;
	}

	/*  Inference chaining two syllogisms.  */

	theorem _3syl  (var ph : wff, var ps : wff, var ch : wff, var th : wff) 
	{
		hyp 1 : wff = |- ( ph -> ps ) ;
		hyp 2 : wff = |- ( ps -> ch ) ;
		hyp 3 : wff = |- ( ch -> th ) ;
		-----------------
		prop : wff = |- ( ph -> th ) ;
	}

	proof of _3syl {
		step 1 : wff  = theorem syl (hyp 1, hyp 2) |- ( ph -> ch )  ;
		step 2 : wff  = theorem syl (step 1, hyp 3) |- ( ph -> th )  ;
		qed prop 1 = step 2 ;
	}

	/*  A syllogism rule of inference.  The second premise is used to replace
	       the second antecedent of the first premise.  */

	theorem syl5  (var ph : wff, var ps : wff, var ch : wff, var th : wff) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( th -> ps ) ;
		-----------------
		prop : wff = |- ( ph -> ( th -> ch ) ) ;
	}

	proof of syl5 {
		step 1 : wff  = theorem imim1i (hyp 2) |- ( ( ps -> ch ) -> ( th -> ch ) )  ;
		step 2 : wff  = theorem syl (hyp 1, step 1) |- ( ph -> ( th -> ch ) )  ;
		qed prop 1 = step 2 ;
	}

	/*  A syllogism rule of inference.  The second premise is used to replace
	       the consequent of the first premise.  */

	theorem syl6  (var ph : wff, var ps : wff, var ch : wff, var th : wff) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ch ) ) ;
		hyp 2 : wff = |- ( ch -> th ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> th ) ) ;
	}

	proof of syl6 {
		step 1 : wff  = theorem imim2i (hyp 2) |- ( ( ps -> ch ) -> ( ps -> th ) )  ;
		step 2 : wff  = theorem syl (hyp 1, step 1) |- ( ph -> ( ps -> th ) )  ;
		qed prop 1 = step 2 ;
	}

	/*  A syllogism rule of inference.  The second premise is used to replace
	       the third antecedent of the first premise.  */

	theorem syl7  (var ph : wff, var ps : wff, var ch : wff, var th : wff, var ta : wff) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		hyp 2 : wff = |- ( ta -> ch ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ta -> th ) ) ) ;
	}

	proof of syl7 {
		step 1 : wff  = theorem imim1i (hyp 2) |- ( ( ch -> th ) -> ( ta -> th ) )  ;
		step 2 : wff  = theorem syl6 (hyp 1, step 1) |- ( ph -> ( ps -> ( ta -> th ) ) )  ;
		qed prop 1 = step 2 ;
	}

	/*  A syllogism rule of inference.  The second premise is used to replace
	       the consequent of the first premise.  */

	theorem syl8  (var ph : wff, var ps : wff, var ch : wff, var th : wff, var ta : wff) 
	{
		hyp 1 : wff = |- ( ph -> ( ps -> ( ch -> th ) ) ) ;
		hyp 2 : wff = |- ( th -> ta ) ;
		-----------------
		prop : wff = |- ( ph -> ( ps -> ( ch -> ta ) ) ) ;
	}

	proof of syl8 {
		step 1 : wff  = theorem imim2i (hyp 2) |- ( ( ch -> th ) -> ( ch -> ta ) )  ;
		step 2 : wff  = theorem syl6 (hyp 1, step 1) |- ( ph -> ( ps -> ( ch -> ta ) ) )  ;
		qed prop 1 = step 2 ;
	}

	evaluation of ax-mp {
	prop 1 =
		w_sum [0.4, 1, 1, -1, -1]
		(
			lexp 
			[
				+ theorem a1i, proof step 1
				- theorem com12, proof step 0
			]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of ax-1 {
	prop 1 =
		w_sum [1, 1, 0.6, -1, 0]
		(
			lexp [+]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of ax-3 {
	prop 1 =
		w_sum [-0.2, 1, 1, -1, 0]
		(
			lexp [+]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of ax-2 {
	prop 1 =
		w_sum [-0.2, 1, 1, -1, 0]
		(
			lexp [+]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of a1i {
	prop 1 =
		w_sum [-0.2, 1, 1, -1, 0]
		(
			lexp 
			[
				+ theorem imim2i, proof step 0
				- theorem imim2i, proof step 1
			]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of syl {
	prop 1 =
		w_sum [1, 1, 0.8, -1, 0]
		(
			lexp [+]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of a2i {
	prop 1 =
		w_sum [-0.2, 1, 1, -1, 0]
		(
			lexp 
			[
				+ theorem com12, proof step 1
				- theorem imim12i, proof step 0
			]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of com12 {
	prop 1 =
		w_sum [-0.2, 1, 1, -1, 0]
		(
			lexp 
			[
				+ theorem imim1, proof step 1
				- theorem imim1i, proof step 0
			]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of a1d {
	prop 1 =
		w_sum [-0.2, 1, 1, -1, 0]
		(
			lexp [+]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of a2d {
	prop 1 =
		w_sum [0.4, 1, 1, -1, -1]
		(
			lexp 
			[
				+ theorem imim2, proof step 1
				- theorem imim1, proof step 0
			]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of imim2 {
	prop 1 =
		w_sum [-0.2, 1, 1, -1, 0]
		(
			lexp [+]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of imim1 {
	prop 1 =
		w_sum [-0.2, 1, 1, -1, 0]
		(
			lexp [+]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of imim1i {
	prop 1 =
		w_sum [1, 1, 0.6, -1, 0]
		(
			lexp [+]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of imim2i {
	prop 1 =
		w_sum [1, 1, 0.8, -1, 0]
		(
			lexp [+]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of imim12i {
	prop 1 =
		w_sum [-0.2, 1, 1, -1, 0]
		(
			lexp [+]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of imim3i {
	prop 1 =
		w_sum [-0.2, 1, 1, -1, 0]
		(
			lexp [+]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of _3syl {
	prop 1 =
		w_sum [-0.2, 1, 1, -1, 0]
		(
			lexp [+]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of syl5 {
	prop 1 =
		w_sum [-0.2, 1, 1, -1, 0]
		(
			lexp [+]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of syl6 {
	prop 1 =
		w_sum [0.4, 1, 1, -1, -1]
		(
			lexp 
			[
				+ theorem syl7, proof step 1
				- theorem syl8, proof step 0
			]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of syl7 {
	prop 1 =
		w_sum [-0.2, 1, 1, -1, 0]
		(
			lexp [+]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

	evaluation of syl8 {
	prop 1 =
		w_sum [-0.2, 1, 1, -1, 0]
		(
			lexp [+]()
			barrier
			(
				exp_avg()
				exp_disp()
				exp_cplx()
			)
			exp_cplx()
			sub_cplx()
			forking()
		)	}

}

